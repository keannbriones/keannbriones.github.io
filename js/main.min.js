! function() {
    return function t(e, n, i) {
        function r(o, s) {
            if (!n[o]) {
                if (!e[o]) {
                    var c = "function" == typeof require && require;
                    if (!s && c) return c(o, !0);
                    if (a) return a(o, !0);
                    var l = new Error("Cannot find module '" + o + "'");
                    throw l.code = "MODULE_NOT_FOUND", l
                }
                var u = n[o] = {
                    exports: {}
                };
                e[o][0].call(u.exports, function(t) {
                    var n = e[o][1][t];
                    return r(n || t)
                }, u, u.exports, t, e, n, i)
            }
            return n[o].exports
        }
        for (var a = "function" == typeof require && require, o = 0; o < i.length; o++) r(i[o]);
        return r
    }
  }()({
    1: [function(t, e, n) {
        ! function(t, i) {
            if ("object" == typeof n && "object" == typeof e) e.exports = i();
            else if ("function" == typeof define && define.amd) define([], i);
            else {
                var r = i();
                for (var a in r)("object" == typeof n ? n : t)[a] = r[a]
            }
        }(this, function() {
            return function(t) {
                var e = {};
  
                function n(i) {
                    if (e[i]) return e[i].exports;
                    var r = e[i] = {
                        i: i,
                        l: !1,
                        exports: {}
                    };
                    return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
                }
                return n.m = t, n.c = e, n.d = function(t, e, i) {
                    n.o(t, e) || Object.defineProperty(t, e, {
                        configurable: !1,
                        enumerable: !0,
                        get: i
                    })
                }, n.n = function(t) {
                    var e = t && t.__esModule ? function() {
                        return t.default
                    } : function() {
                        return t
                    };
                    return n.d(e, "a", e), e
                }, n.o = function(t, e) {
                    return Object.prototype.hasOwnProperty.call(t, e)
                }, n.p = "", n(n.s = 4)
            }([function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.setMatrixArrayType = function(t) {
                    e.ARRAY_TYPE = t
                }, e.toRadian = function(t) {
                    return t * r
                }, e.equals = function(t, e) {
                    return Math.abs(t - e) <= i * Math.max(1, Math.abs(t), Math.abs(e))
                };
                var i = e.EPSILON = 1e-6;
                e.ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, e.RANDOM = Math.random;
                var r = Math.PI / 180
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.sub = e.mul = void 0, e.create = function() {
                    var t = new i.ARRAY_TYPE(9);
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
                }, e.fromMat4 = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t
                }, e.clone = function(t) {
                    var e = new i.ARRAY_TYPE(9);
                    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
                }, e.copy = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
                }, e.fromValues = function(t, e, n, r, a, o, s, c, l) {
                    var u = new i.ARRAY_TYPE(9);
                    return u[0] = t, u[1] = e, u[2] = n, u[3] = r, u[4] = a, u[5] = o, u[6] = s, u[7] = c, u[8] = l, u
                }, e.set = function(t, e, n, i, r, a, o, s, c, l) {
                    return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t[4] = a, t[5] = o, t[6] = s, t[7] = c, t[8] = l, t
                }, e.identity = function(t) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
                }, e.transpose = function(t, e) {
                    if (t === e) {
                        var n = e[1],
                            i = e[2],
                            r = e[5];
                        t[1] = e[3], t[2] = e[6], t[3] = n, t[5] = e[7], t[6] = i, t[7] = r
                    } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
                    return t
                }, e.invert = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = e[4],
                        s = e[5],
                        c = e[6],
                        l = e[7],
                        u = e[8],
                        h = u * o - s * l,
                        d = -u * a + s * c,
                        p = l * a - o * c,
                        f = n * h + i * d + r * p;
                    if (!f) return null;
                    return f = 1 / f, t[0] = h * f, t[1] = (-u * i + r * l) * f, t[2] = (s * i - r * o) * f, t[3] = d * f, t[4] = (u * n - r * c) * f, t[5] = (-s * n + r * a) * f, t[6] = p * f, t[7] = (-l * n + i * c) * f, t[8] = (o * n - i * a) * f, t
                }, e.adjoint = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = e[4],
                        s = e[5],
                        c = e[6],
                        l = e[7],
                        u = e[8];
                    return t[0] = o * u - s * l, t[1] = r * l - i * u, t[2] = i * s - r * o, t[3] = s * c - a * u, t[4] = n * u - r * c, t[5] = r * a - n * s, t[6] = a * l - o * c, t[7] = i * c - n * l, t[8] = n * o - i * a, t
                }, e.determinant = function(t) {
                    var e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        a = t[4],
                        o = t[5],
                        s = t[6],
                        c = t[7],
                        l = t[8];
                    return e * (l * a - o * c) + n * (-l * r + o * s) + i * (c * r - a * s)
                }, e.multiply = r, e.translate = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = e[5],
                        l = e[6],
                        u = e[7],
                        h = e[8],
                        d = n[0],
                        p = n[1];
                    return t[0] = i, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = c, t[6] = d * i + p * o + l, t[7] = d * r + p * s + u, t[8] = d * a + p * c + h, t
                }, e.rotate = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = e[5],
                        l = e[6],
                        u = e[7],
                        h = e[8],
                        d = Math.sin(n),
                        p = Math.cos(n);
                    return t[0] = p * i + d * o, t[1] = p * r + d * s, t[2] = p * a + d * c, t[3] = p * o - d * i, t[4] = p * s - d * r, t[5] = p * c - d * a, t[6] = l, t[7] = u, t[8] = h, t
                }, e.scale = function(t, e, n) {
                    var i = n[0],
                        r = n[1];
                    return t[0] = i * e[0], t[1] = i * e[1], t[2] = i * e[2], t[3] = r * e[3], t[4] = r * e[4], t[5] = r * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
                }, e.fromTranslation = function(t, e) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t
                }, e.fromRotation = function(t, e) {
                    var n = Math.sin(e),
                        i = Math.cos(e);
                    return t[0] = i, t[1] = n, t[2] = 0, t[3] = -n, t[4] = i, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
                }, e.fromScaling = function(t, e) {
                    return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
                }, e.fromMat2d = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t
                }, e.fromQuat = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = n + n,
                        s = i + i,
                        c = r + r,
                        l = n * o,
                        u = i * o,
                        h = i * s,
                        d = r * o,
                        p = r * s,
                        f = r * c,
                        m = a * o,
                        v = a * s,
                        g = a * c;
                    return t[0] = 1 - h - f, t[3] = u - g, t[6] = d + v, t[1] = u + g, t[4] = 1 - l - f, t[7] = p - m, t[2] = d - v, t[5] = p + m, t[8] = 1 - l - h, t
                }, e.normalFromMat4 = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = e[4],
                        s = e[5],
                        c = e[6],
                        l = e[7],
                        u = e[8],
                        h = e[9],
                        d = e[10],
                        p = e[11],
                        f = e[12],
                        m = e[13],
                        v = e[14],
                        g = e[15],
                        y = n * s - i * o,
                        x = n * c - r * o,
                        b = n * l - a * o,
                        w = i * c - r * s,
                        _ = i * l - a * s,
                        M = r * l - a * c,
                        E = u * m - h * f,
                        T = u * v - d * f,
                        S = u * g - p * f,
                        A = h * v - d * m,
                        L = h * g - p * m,
                        P = d * g - p * v,
                        C = y * P - x * L + b * A + w * S - _ * T + M * E;
                    if (!C) return null;
                    return C = 1 / C, t[0] = (s * P - c * L + l * A) * C, t[1] = (c * S - o * P - l * T) * C, t[2] = (o * L - s * S + l * E) * C, t[3] = (r * L - i * P - a * A) * C, t[4] = (n * P - r * S + a * T) * C, t[5] = (i * S - n * L - a * E) * C, t[6] = (m * M - v * _ + g * w) * C, t[7] = (v * b - f * M - g * x) * C, t[8] = (f * _ - m * b + g * y) * C, t
                }, e.projection = function(t, e, n) {
                    return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / n, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t
                }, e.str = function(t) {
                    return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")"
                }, e.frob = function(t) {
                    return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2))
                }, e.add = function(t, e, n) {
                    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t
                }, e.subtract = a, e.multiplyScalar = function(t, e, n) {
                    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t
                }, e.multiplyScalarAndAdd = function(t, e, n, i) {
                    return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t[2] = e[2] + n[2] * i, t[3] = e[3] + n[3] * i, t[4] = e[4] + n[4] * i, t[5] = e[5] + n[5] * i, t[6] = e[6] + n[6] * i, t[7] = e[7] + n[7] * i, t[8] = e[8] + n[8] * i, t
                }, e.exactEquals = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8]
                }, e.equals = function(t, e) {
                    var n = t[0],
                        r = t[1],
                        a = t[2],
                        o = t[3],
                        s = t[4],
                        c = t[5],
                        l = t[6],
                        u = t[7],
                        h = t[8],
                        d = e[0],
                        p = e[1],
                        f = e[2],
                        m = e[3],
                        v = e[4],
                        g = e[5],
                        y = e[6],
                        x = e[7],
                        b = e[8];
                    return Math.abs(n - d) <= i.EPSILON * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(r - p) <= i.EPSILON * Math.max(1, Math.abs(r), Math.abs(p)) && Math.abs(a - f) <= i.EPSILON * Math.max(1, Math.abs(a), Math.abs(f)) && Math.abs(o - m) <= i.EPSILON * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(s - v) <= i.EPSILON * Math.max(1, Math.abs(s), Math.abs(v)) && Math.abs(c - g) <= i.EPSILON * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(l - y) <= i.EPSILON * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - x) <= i.EPSILON * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(h - b) <= i.EPSILON * Math.max(1, Math.abs(h), Math.abs(b))
                };
                var i = function(t) {
                    {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }
                }(n(0));
  
                function r(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = e[5],
                        l = e[6],
                        u = e[7],
                        h = e[8],
                        d = n[0],
                        p = n[1],
                        f = n[2],
                        m = n[3],
                        v = n[4],
                        g = n[5],
                        y = n[6],
                        x = n[7],
                        b = n[8];
                    return t[0] = d * i + p * o + f * l, t[1] = d * r + p * s + f * u, t[2] = d * a + p * c + f * h, t[3] = m * i + v * o + g * l, t[4] = m * r + v * s + g * u, t[5] = m * a + v * c + g * h, t[6] = y * i + x * o + b * l, t[7] = y * r + x * s + b * u, t[8] = y * a + x * c + b * h, t
                }
  
                function a(t, e, n) {
                    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t
                }
                e.mul = r, e.sub = a
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.forEach = e.sqrLen = e.len = e.sqrDist = e.dist = e.div = e.mul = e.sub = void 0, e.create = r, e.clone = function(t) {
                    var e = new i.ARRAY_TYPE(3);
                    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
                }, e.length = a, e.fromValues = o, e.copy = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
                }, e.set = function(t, e, n, i) {
                    return t[0] = e, t[1] = n, t[2] = i, t
                }, e.add = function(t, e, n) {
                    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t
                }, e.subtract = s, e.multiply = c, e.divide = l, e.ceil = function(t, e) {
                    return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t
                }, e.floor = function(t, e) {
                    return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t
                }, e.min = function(t, e, n) {
                    return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t
                }, e.max = function(t, e, n) {
                    return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t
                }, e.round = function(t, e) {
                    return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t
                }, e.scale = function(t, e, n) {
                    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t
                }, e.scaleAndAdd = function(t, e, n, i) {
                    return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t[2] = e[2] + n[2] * i, t
                }, e.distance = u, e.squaredDistance = h, e.squaredLength = d, e.negate = function(t, e) {
                    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t
                }, e.inverse = function(t, e) {
                    return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t
                }, e.normalize = p, e.dot = f, e.cross = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = n[0],
                        s = n[1],
                        c = n[2];
                    return t[0] = r * c - a * s, t[1] = a * o - i * c, t[2] = i * s - r * o, t
                }, e.lerp = function(t, e, n, i) {
                    var r = e[0],
                        a = e[1],
                        o = e[2];
                    return t[0] = r + i * (n[0] - r), t[1] = a + i * (n[1] - a), t[2] = o + i * (n[2] - o), t
                }, e.hermite = function(t, e, n, i, r, a) {
                    var o = a * a,
                        s = o * (2 * a - 3) + 1,
                        c = o * (a - 2) + a,
                        l = o * (a - 1),
                        u = o * (3 - 2 * a);
                    return t[0] = e[0] * s + n[0] * c + i[0] * l + r[0] * u, t[1] = e[1] * s + n[1] * c + i[1] * l + r[1] * u, t[2] = e[2] * s + n[2] * c + i[2] * l + r[2] * u, t
                }, e.bezier = function(t, e, n, i, r, a) {
                    var o = 1 - a,
                        s = o * o,
                        c = a * a,
                        l = s * o,
                        u = 3 * a * s,
                        h = 3 * c * o,
                        d = c * a;
                    return t[0] = e[0] * l + n[0] * u + i[0] * h + r[0] * d, t[1] = e[1] * l + n[1] * u + i[1] * h + r[1] * d, t[2] = e[2] * l + n[2] * u + i[2] * h + r[2] * d, t
                }, e.random = function(t, e) {
                    e = e || 1;
                    var n = 2 * i.RANDOM() * Math.PI,
                        r = 2 * i.RANDOM() - 1,
                        a = Math.sqrt(1 - r * r) * e;
                    return t[0] = Math.cos(n) * a, t[1] = Math.sin(n) * a, t[2] = r * e, t
                }, e.transformMat4 = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = n[3] * i + n[7] * r + n[11] * a + n[15];
                    return o = o || 1, t[0] = (n[0] * i + n[4] * r + n[8] * a + n[12]) / o, t[1] = (n[1] * i + n[5] * r + n[9] * a + n[13]) / o, t[2] = (n[2] * i + n[6] * r + n[10] * a + n[14]) / o, t
                }, e.transformMat3 = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2];
                    return t[0] = i * n[0] + r * n[3] + a * n[6], t[1] = i * n[1] + r * n[4] + a * n[7], t[2] = i * n[2] + r * n[5] + a * n[8], t
                }, e.transformQuat = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = n[0],
                        s = n[1],
                        c = n[2],
                        l = n[3],
                        u = l * i + s * a - c * r,
                        h = l * r + c * i - o * a,
                        d = l * a + o * r - s * i,
                        p = -o * i - s * r - c * a;
                    return t[0] = u * l + p * -o + h * -c - d * -s, t[1] = h * l + p * -s + d * -o - u * -c, t[2] = d * l + p * -c + u * -s - h * -o, t
                }, e.rotateX = function(t, e, n, i) {
                    var r = [],
                        a = [];
                    return r[0] = e[0] - n[0], r[1] = e[1] - n[1], r[2] = e[2] - n[2], a[0] = r[0], a[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i), a[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i), t[0] = a[0] + n[0], t[1] = a[1] + n[1], t[2] = a[2] + n[2], t
                }, e.rotateY = function(t, e, n, i) {
                    var r = [],
                        a = [];
                    return r[0] = e[0] - n[0], r[1] = e[1] - n[1], r[2] = e[2] - n[2], a[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i), a[1] = r[1], a[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i), t[0] = a[0] + n[0], t[1] = a[1] + n[1], t[2] = a[2] + n[2], t
                }, e.rotateZ = function(t, e, n, i) {
                    var r = [],
                        a = [];
                    return r[0] = e[0] - n[0], r[1] = e[1] - n[1], r[2] = e[2] - n[2], a[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i), a[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i), a[2] = r[2], t[0] = a[0] + n[0], t[1] = a[1] + n[1], t[2] = a[2] + n[2], t
                }, e.angle = function(t, e) {
                    var n = o(t[0], t[1], t[2]),
                        i = o(e[0], e[1], e[2]);
                    p(n, n), p(i, i);
                    var r = f(n, i);
                    return r > 1 ? 0 : r < -1 ? Math.PI : Math.acos(r)
                }, e.str = function(t) {
                    return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
                }, e.exactEquals = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2]
                }, e.equals = function(t, e) {
                    var n = t[0],
                        r = t[1],
                        a = t[2],
                        o = e[0],
                        s = e[1],
                        c = e[2];
                    return Math.abs(n - o) <= i.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - s) <= i.EPSILON * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(a - c) <= i.EPSILON * Math.max(1, Math.abs(a), Math.abs(c))
                };
                var i = function(t) {
                    {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }
                }(n(0));
  
                function r() {
                    var t = new i.ARRAY_TYPE(3);
                    return t[0] = 0, t[1] = 0, t[2] = 0, t
                }
  
                function a(t) {
                    var e = t[0],
                        n = t[1],
                        i = t[2];
                    return Math.sqrt(e * e + n * n + i * i)
                }
  
                function o(t, e, n) {
                    var r = new i.ARRAY_TYPE(3);
                    return r[0] = t, r[1] = e, r[2] = n, r
                }
  
                function s(t, e, n) {
                    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t
                }
  
                function c(t, e, n) {
                    return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t
                }
  
                function l(t, e, n) {
                    return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t
                }
  
                function u(t, e) {
                    var n = e[0] - t[0],
                        i = e[1] - t[1],
                        r = e[2] - t[2];
                    return Math.sqrt(n * n + i * i + r * r)
                }
  
                function h(t, e) {
                    var n = e[0] - t[0],
                        i = e[1] - t[1],
                        r = e[2] - t[2];
                    return n * n + i * i + r * r
                }
  
                function d(t) {
                    var e = t[0],
                        n = t[1],
                        i = t[2];
                    return e * e + n * n + i * i
                }
  
                function p(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = n * n + i * i + r * r;
                    return a > 0 && (a = 1 / Math.sqrt(a), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a), t
                }
  
                function f(t, e) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
                }
                var m;
                e.sub = s, e.mul = c, e.div = l, e.dist = u, e.sqrDist = h, e.len = a, e.sqrLen = d, e.forEach = (m = r(), function(t, e, n, i, r, a) {
                    var o = void 0,
                        s = void 0;
                    for (e || (e = 3), n || (n = 0), s = i ? Math.min(i * e + n, t.length) : t.length, o = n; o < s; o += e) m[0] = t[o], m[1] = t[o + 1], m[2] = t[o + 2], r(m, m, a), t[o] = m[0], t[o + 1] = m[1], t[o + 2] = m[2];
                    return t
                })
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.forEach = e.sqrLen = e.len = e.sqrDist = e.dist = e.div = e.mul = e.sub = void 0, e.create = r, e.clone = function(t) {
                    var e = new i.ARRAY_TYPE(4);
                    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
                }, e.fromValues = function(t, e, n, r) {
                    var a = new i.ARRAY_TYPE(4);
                    return a[0] = t, a[1] = e, a[2] = n, a[3] = r, a
                }, e.copy = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
                }, e.set = function(t, e, n, i, r) {
                    return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t
                }, e.add = function(t, e, n) {
                    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t
                }, e.subtract = a, e.multiply = o, e.divide = s, e.ceil = function(t, e) {
                    return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t[3] = Math.ceil(e[3]), t
                }, e.floor = function(t, e) {
                    return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t[3] = Math.floor(e[3]), t
                }, e.min = function(t, e, n) {
                    return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t[3] = Math.min(e[3], n[3]), t
                }, e.max = function(t, e, n) {
                    return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t[3] = Math.max(e[3], n[3]), t
                }, e.round = function(t, e) {
                    return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t[3] = Math.round(e[3]), t
                }, e.scale = c, e.scaleAndAdd = function(t, e, n, i) {
                    return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t[2] = e[2] + n[2] * i, t[3] = e[3] + n[3] * i, t
                }, e.distance = l, e.squaredDistance = u, e.length = h, e.squaredLength = d, e.negate = function(t, e) {
                    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t
                }, e.inverse = function(t, e) {
                    return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t[3] = 1 / e[3], t
                }, e.normalize = p, e.dot = function(t, e) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
                }, e.lerp = function(t, e, n, i) {
                    var r = e[0],
                        a = e[1],
                        o = e[2],
                        s = e[3];
                    return t[0] = r + i * (n[0] - r), t[1] = a + i * (n[1] - a), t[2] = o + i * (n[2] - o), t[3] = s + i * (n[3] - s), t
                }, e.random = function(t, e) {
                    return e = e || 1, t[0] = i.RANDOM(), t[1] = i.RANDOM(), t[2] = i.RANDOM(), t[3] = i.RANDOM(), p(t, t), c(t, t, e), t
                }, e.transformMat4 = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3];
                    return t[0] = n[0] * i + n[4] * r + n[8] * a + n[12] * o, t[1] = n[1] * i + n[5] * r + n[9] * a + n[13] * o, t[2] = n[2] * i + n[6] * r + n[10] * a + n[14] * o, t[3] = n[3] * i + n[7] * r + n[11] * a + n[15] * o, t
                }, e.transformQuat = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = n[0],
                        s = n[1],
                        c = n[2],
                        l = n[3],
                        u = l * i + s * a - c * r,
                        h = l * r + c * i - o * a,
                        d = l * a + o * r - s * i,
                        p = -o * i - s * r - c * a;
                    return t[0] = u * l + p * -o + h * -c - d * -s, t[1] = h * l + p * -s + d * -o - u * -c, t[2] = d * l + p * -c + u * -s - h * -o, t[3] = e[3], t
                }, e.str = function(t) {
                    return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
                }, e.exactEquals = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
                }, e.equals = function(t, e) {
                    var n = t[0],
                        r = t[1],
                        a = t[2],
                        o = t[3],
                        s = e[0],
                        c = e[1],
                        l = e[2],
                        u = e[3];
                    return Math.abs(n - s) <= i.EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(r - c) <= i.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(a - l) <= i.EPSILON * Math.max(1, Math.abs(a), Math.abs(l)) && Math.abs(o - u) <= i.EPSILON * Math.max(1, Math.abs(o), Math.abs(u))
                };
                var i = function(t) {
                    {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }
                }(n(0));
  
                function r() {
                    var t = new i.ARRAY_TYPE(4);
                    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t
                }
  
                function a(t, e, n) {
                    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t
                }
  
                function o(t, e, n) {
                    return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t[3] = e[3] * n[3], t
                }
  
                function s(t, e, n) {
                    return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t[3] = e[3] / n[3], t
                }
  
                function c(t, e, n) {
                    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t
                }
  
                function l(t, e) {
                    var n = e[0] - t[0],
                        i = e[1] - t[1],
                        r = e[2] - t[2],
                        a = e[3] - t[3];
                    return Math.sqrt(n * n + i * i + r * r + a * a)
                }
  
                function u(t, e) {
                    var n = e[0] - t[0],
                        i = e[1] - t[1],
                        r = e[2] - t[2],
                        a = e[3] - t[3];
                    return n * n + i * i + r * r + a * a
                }
  
                function h(t) {
                    var e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3];
                    return Math.sqrt(e * e + n * n + i * i + r * r)
                }
  
                function d(t) {
                    var e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3];
                    return e * e + n * n + i * i + r * r
                }
  
                function p(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = n * n + i * i + r * r + a * a;
                    return o > 0 && (o = 1 / Math.sqrt(o), t[0] = n * o, t[1] = i * o, t[2] = r * o, t[3] = a * o), t
                }
                var f;
                e.sub = a, e.mul = o, e.div = s, e.dist = l, e.sqrDist = u, e.len = h, e.sqrLen = d, e.forEach = (f = r(), function(t, e, n, i, r, a) {
                    var o = void 0,
                        s = void 0;
                    for (e || (e = 4), n || (n = 0), s = i ? Math.min(i * e + n, t.length) : t.length, o = n; o < s; o += e) f[0] = t[o], f[1] = t[o + 1], f[2] = t[o + 2], f[3] = t[o + 3], r(f, f, a), t[o] = f[0], t[o + 1] = f[1], t[o + 2] = f[2], t[o + 3] = f[3];
                    return t
                })
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.vec4 = e.vec3 = e.vec2 = e.quat = e.mat4 = e.mat3 = e.mat2d = e.mat2 = e.glMatrix = void 0;
                var i = d(n(0)),
                    r = d(n(5)),
                    a = d(n(6)),
                    o = d(n(1)),
                    s = d(n(7)),
                    c = d(n(8)),
                    l = d(n(9)),
                    u = d(n(2)),
                    h = d(n(3));
  
                function d(t) {
                    if (t && t.__esModule) return t;
                    var e = {};
                    if (null != t)
                        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                    return e.default = t, e
                }
                e.glMatrix = i, e.mat2 = r, e.mat2d = a, e.mat3 = o, e.mat4 = s, e.quat = c, e.vec2 = l, e.vec3 = u, e.vec4 = h
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.sub = e.mul = void 0, e.create = function() {
                    var t = new i.ARRAY_TYPE(4);
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t
                }, e.clone = function(t) {
                    var e = new i.ARRAY_TYPE(4);
                    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
                }, e.copy = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
                }, e.identity = function(t) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t
                }, e.fromValues = function(t, e, n, r) {
                    var a = new i.ARRAY_TYPE(4);
                    return a[0] = t, a[1] = e, a[2] = n, a[3] = r, a
                }, e.set = function(t, e, n, i, r) {
                    return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t
                }, e.transpose = function(t, e) {
                    if (t === e) {
                        var n = e[1];
                        t[1] = e[2], t[2] = n
                    } else t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3];
                    return t
                }, e.invert = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = n * a - r * i;
                    if (!o) return null;
                    return o = 1 / o, t[0] = a * o, t[1] = -i * o, t[2] = -r * o, t[3] = n * o, t
                }, e.adjoint = function(t, e) {
                    var n = e[0];
                    return t[0] = e[3], t[1] = -e[1], t[2] = -e[2], t[3] = n, t
                }, e.determinant = function(t) {
                    return t[0] * t[3] - t[2] * t[1]
                }, e.multiply = r, e.rotate = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = Math.sin(n),
                        c = Math.cos(n);
                    return t[0] = i * c + a * s, t[1] = r * c + o * s, t[2] = i * -s + a * c, t[3] = r * -s + o * c, t
                }, e.scale = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = n[0],
                        c = n[1];
                    return t[0] = i * s, t[1] = r * s, t[2] = a * c, t[3] = o * c, t
                }, e.fromRotation = function(t, e) {
                    var n = Math.sin(e),
                        i = Math.cos(e);
                    return t[0] = i, t[1] = n, t[2] = -n, t[3] = i, t
                }, e.fromScaling = function(t, e) {
                    return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t
                }, e.str = function(t) {
                    return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
                }, e.frob = function(t) {
                    return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2))
                }, e.LDU = function(t, e, n, i) {
                    return t[2] = i[2] / i[0], n[0] = i[0], n[1] = i[1], n[3] = i[3] - t[2] * n[1], [t, e, n]
                }, e.add = function(t, e, n) {
                    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t
                }, e.subtract = a, e.exactEquals = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
                }, e.equals = function(t, e) {
                    var n = t[0],
                        r = t[1],
                        a = t[2],
                        o = t[3],
                        s = e[0],
                        c = e[1],
                        l = e[2],
                        u = e[3];
                    return Math.abs(n - s) <= i.EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(r - c) <= i.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(a - l) <= i.EPSILON * Math.max(1, Math.abs(a), Math.abs(l)) && Math.abs(o - u) <= i.EPSILON * Math.max(1, Math.abs(o), Math.abs(u))
                }, e.multiplyScalar = function(t, e, n) {
                    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t
                }, e.multiplyScalarAndAdd = function(t, e, n, i) {
                    return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t[2] = e[2] + n[2] * i, t[3] = e[3] + n[3] * i, t
                };
                var i = function(t) {
                    {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }
                }(n(0));
  
                function r(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = n[0],
                        c = n[1],
                        l = n[2],
                        u = n[3];
                    return t[0] = i * s + a * c, t[1] = r * s + o * c, t[2] = i * l + a * u, t[3] = r * l + o * u, t
                }
  
                function a(t, e, n) {
                    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t
                }
                e.mul = r, e.sub = a
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.sub = e.mul = void 0, e.create = function() {
                    var t = new i.ARRAY_TYPE(6);
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
                }, e.clone = function(t) {
                    var e = new i.ARRAY_TYPE(6);
                    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e
                }, e.copy = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
                }, e.identity = function(t) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
                }, e.fromValues = function(t, e, n, r, a, o) {
                    var s = new i.ARRAY_TYPE(6);
                    return s[0] = t, s[1] = e, s[2] = n, s[3] = r, s[4] = a, s[5] = o, s
                }, e.set = function(t, e, n, i, r, a, o) {
                    return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t[4] = a, t[5] = o, t
                }, e.invert = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = e[4],
                        s = e[5],
                        c = n * a - i * r;
                    if (!c) return null;
                    return c = 1 / c, t[0] = a * c, t[1] = -i * c, t[2] = -r * c, t[3] = n * c, t[4] = (r * s - a * o) * c, t[5] = (i * o - n * s) * c, t
                }, e.determinant = function(t) {
                    return t[0] * t[3] - t[1] * t[2]
                }, e.multiply = r, e.rotate = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = e[5],
                        l = Math.sin(n),
                        u = Math.cos(n);
                    return t[0] = i * u + a * l, t[1] = r * u + o * l, t[2] = i * -l + a * u, t[3] = r * -l + o * u, t[4] = s, t[5] = c, t
                }, e.scale = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = e[5],
                        l = n[0],
                        u = n[1];
                    return t[0] = i * l, t[1] = r * l, t[2] = a * u, t[3] = o * u, t[4] = s, t[5] = c, t
                }, e.translate = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = e[5],
                        l = n[0],
                        u = n[1];
                    return t[0] = i, t[1] = r, t[2] = a, t[3] = o, t[4] = i * l + a * u + s, t[5] = r * l + o * u + c, t
                }, e.fromRotation = function(t, e) {
                    var n = Math.sin(e),
                        i = Math.cos(e);
                    return t[0] = i, t[1] = n, t[2] = -n, t[3] = i, t[4] = 0, t[5] = 0, t
                }, e.fromScaling = function(t, e) {
                    return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t[4] = 0, t[5] = 0, t
                }, e.fromTranslation = function(t, e) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = e[0], t[5] = e[1], t
                }, e.str = function(t) {
                    return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
                }, e.frob = function(t) {
                    return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + 1)
                }, e.add = function(t, e, n) {
                    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t
                }, e.subtract = a, e.multiplyScalar = function(t, e, n) {
                    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t
                }, e.multiplyScalarAndAdd = function(t, e, n, i) {
                    return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t[2] = e[2] + n[2] * i, t[3] = e[3] + n[3] * i, t[4] = e[4] + n[4] * i, t[5] = e[5] + n[5] * i, t
                }, e.exactEquals = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5]
                }, e.equals = function(t, e) {
                    var n = t[0],
                        r = t[1],
                        a = t[2],
                        o = t[3],
                        s = t[4],
                        c = t[5],
                        l = e[0],
                        u = e[1],
                        h = e[2],
                        d = e[3],
                        p = e[4],
                        f = e[5];
                    return Math.abs(n - l) <= i.EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(r - u) <= i.EPSILON * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(a - h) <= i.EPSILON * Math.max(1, Math.abs(a), Math.abs(h)) && Math.abs(o - d) <= i.EPSILON * Math.max(1, Math.abs(o), Math.abs(d)) && Math.abs(s - p) <= i.EPSILON * Math.max(1, Math.abs(s), Math.abs(p)) && Math.abs(c - f) <= i.EPSILON * Math.max(1, Math.abs(c), Math.abs(f))
                };
                var i = function(t) {
                    {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }
                }(n(0));
  
                function r(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = e[5],
                        l = n[0],
                        u = n[1],
                        h = n[2],
                        d = n[3],
                        p = n[4],
                        f = n[5];
                    return t[0] = i * l + a * u, t[1] = r * l + o * u, t[2] = i * h + a * d, t[3] = r * h + o * d, t[4] = i * p + a * f + s, t[5] = r * p + o * f + c, t
                }
  
                function a(t, e, n) {
                    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t
                }
                e.mul = r, e.sub = a
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.sub = e.mul = void 0, e.create = function() {
                    var t = new i.ARRAY_TYPE(16);
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
                }, e.clone = function(t) {
                    var e = new i.ARRAY_TYPE(16);
                    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
                }, e.copy = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
                }, e.fromValues = function(t, e, n, r, a, o, s, c, l, u, h, d, p, f, m, v) {
                    var g = new i.ARRAY_TYPE(16);
                    return g[0] = t, g[1] = e, g[2] = n, g[3] = r, g[4] = a, g[5] = o, g[6] = s, g[7] = c, g[8] = l, g[9] = u, g[10] = h, g[11] = d, g[12] = p, g[13] = f, g[14] = m, g[15] = v, g
                }, e.set = function(t, e, n, i, r, a, o, s, c, l, u, h, d, p, f, m, v) {
                    return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t[4] = a, t[5] = o, t[6] = s, t[7] = c, t[8] = l, t[9] = u, t[10] = h, t[11] = d, t[12] = p, t[13] = f, t[14] = m, t[15] = v, t
                }, e.identity = function(t) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
                }, e.transpose = function(t, e) {
                    if (t === e) {
                        var n = e[1],
                            i = e[2],
                            r = e[3],
                            a = e[6],
                            o = e[7],
                            s = e[11];
                        t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[6] = e[9], t[7] = e[13], t[8] = i, t[9] = a, t[11] = e[14], t[12] = r, t[13] = o, t[14] = s
                    } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
                    return t
                }, e.invert = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = e[4],
                        s = e[5],
                        c = e[6],
                        l = e[7],
                        u = e[8],
                        h = e[9],
                        d = e[10],
                        p = e[11],
                        f = e[12],
                        m = e[13],
                        v = e[14],
                        g = e[15],
                        y = n * s - i * o,
                        x = n * c - r * o,
                        b = n * l - a * o,
                        w = i * c - r * s,
                        _ = i * l - a * s,
                        M = r * l - a * c,
                        E = u * m - h * f,
                        T = u * v - d * f,
                        S = u * g - p * f,
                        A = h * v - d * m,
                        L = h * g - p * m,
                        P = d * g - p * v,
                        C = y * P - x * L + b * A + w * S - _ * T + M * E;
                    if (!C) return null;
                    return C = 1 / C, t[0] = (s * P - c * L + l * A) * C, t[1] = (r * L - i * P - a * A) * C, t[2] = (m * M - v * _ + g * w) * C, t[3] = (d * _ - h * M - p * w) * C, t[4] = (c * S - o * P - l * T) * C, t[5] = (n * P - r * S + a * T) * C, t[6] = (v * b - f * M - g * x) * C, t[7] = (u * M - d * b + p * x) * C, t[8] = (o * L - s * S + l * E) * C, t[9] = (i * S - n * L - a * E) * C, t[10] = (f * _ - m * b + g * y) * C, t[11] = (h * b - u * _ - p * y) * C, t[12] = (s * T - o * A - c * E) * C, t[13] = (n * A - i * T + r * E) * C, t[14] = (m * x - f * w - v * y) * C, t[15] = (u * w - h * x + d * y) * C, t
                }, e.adjoint = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = e[4],
                        s = e[5],
                        c = e[6],
                        l = e[7],
                        u = e[8],
                        h = e[9],
                        d = e[10],
                        p = e[11],
                        f = e[12],
                        m = e[13],
                        v = e[14],
                        g = e[15];
                    return t[0] = s * (d * g - p * v) - h * (c * g - l * v) + m * (c * p - l * d), t[1] = -(i * (d * g - p * v) - h * (r * g - a * v) + m * (r * p - a * d)), t[2] = i * (c * g - l * v) - s * (r * g - a * v) + m * (r * l - a * c), t[3] = -(i * (c * p - l * d) - s * (r * p - a * d) + h * (r * l - a * c)), t[4] = -(o * (d * g - p * v) - u * (c * g - l * v) + f * (c * p - l * d)), t[5] = n * (d * g - p * v) - u * (r * g - a * v) + f * (r * p - a * d), t[6] = -(n * (c * g - l * v) - o * (r * g - a * v) + f * (r * l - a * c)), t[7] = n * (c * p - l * d) - o * (r * p - a * d) + u * (r * l - a * c), t[8] = o * (h * g - p * m) - u * (s * g - l * m) + f * (s * p - l * h), t[9] = -(n * (h * g - p * m) - u * (i * g - a * m) + f * (i * p - a * h)), t[10] = n * (s * g - l * m) - o * (i * g - a * m) + f * (i * l - a * s), t[11] = -(n * (s * p - l * h) - o * (i * p - a * h) + u * (i * l - a * s)), t[12] = -(o * (h * v - d * m) - u * (s * v - c * m) + f * (s * d - c * h)), t[13] = n * (h * v - d * m) - u * (i * v - r * m) + f * (i * d - r * h), t[14] = -(n * (s * v - c * m) - o * (i * v - r * m) + f * (i * c - r * s)), t[15] = n * (s * d - c * h) - o * (i * d - r * h) + u * (i * c - r * s), t
                }, e.determinant = function(t) {
                    var e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        a = t[4],
                        o = t[5],
                        s = t[6],
                        c = t[7],
                        l = t[8],
                        u = t[9],
                        h = t[10],
                        d = t[11],
                        p = t[12],
                        f = t[13],
                        m = t[14],
                        v = t[15];
                    return (e * o - n * a) * (h * v - d * m) - (e * s - i * a) * (u * v - d * f) + (e * c - r * a) * (u * m - h * f) + (n * s - i * o) * (l * v - d * p) - (n * c - r * o) * (l * m - h * p) + (i * c - r * s) * (l * f - u * p)
                }, e.multiply = r, e.translate = function(t, e, n) {
                    var i = n[0],
                        r = n[1],
                        a = n[2],
                        o = void 0,
                        s = void 0,
                        c = void 0,
                        l = void 0,
                        u = void 0,
                        h = void 0,
                        d = void 0,
                        p = void 0,
                        f = void 0,
                        m = void 0,
                        v = void 0,
                        g = void 0;
                    e === t ? (t[12] = e[0] * i + e[4] * r + e[8] * a + e[12], t[13] = e[1] * i + e[5] * r + e[9] * a + e[13], t[14] = e[2] * i + e[6] * r + e[10] * a + e[14], t[15] = e[3] * i + e[7] * r + e[11] * a + e[15]) : (o = e[0], s = e[1], c = e[2], l = e[3], u = e[4], h = e[5], d = e[6], p = e[7], f = e[8], m = e[9], v = e[10], g = e[11], t[0] = o, t[1] = s, t[2] = c, t[3] = l, t[4] = u, t[5] = h, t[6] = d, t[7] = p, t[8] = f, t[9] = m, t[10] = v, t[11] = g, t[12] = o * i + u * r + f * a + e[12], t[13] = s * i + h * r + m * a + e[13], t[14] = c * i + d * r + v * a + e[14], t[15] = l * i + p * r + g * a + e[15]);
                    return t
                }, e.scale = function(t, e, n) {
                    var i = n[0],
                        r = n[1],
                        a = n[2];
                    return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
                }, e.rotate = function(t, e, n, r) {
                    var a = r[0],
                        o = r[1],
                        s = r[2],
                        c = Math.sqrt(a * a + o * o + s * s),
                        l = void 0,
                        u = void 0,
                        h = void 0,
                        d = void 0,
                        p = void 0,
                        f = void 0,
                        m = void 0,
                        v = void 0,
                        g = void 0,
                        y = void 0,
                        x = void 0,
                        b = void 0,
                        w = void 0,
                        _ = void 0,
                        M = void 0,
                        E = void 0,
                        T = void 0,
                        S = void 0,
                        A = void 0,
                        L = void 0,
                        P = void 0,
                        C = void 0,
                        R = void 0,
                        O = void 0;
                    if (Math.abs(c) < i.EPSILON) return null;
                    a *= c = 1 / c, o *= c, s *= c, l = Math.sin(n), u = Math.cos(n), h = 1 - u, d = e[0], p = e[1], f = e[2], m = e[3], v = e[4], g = e[5], y = e[6], x = e[7], b = e[8], w = e[9], _ = e[10], M = e[11], E = a * a * h + u, T = o * a * h + s * l, S = s * a * h - o * l, A = a * o * h - s * l, L = o * o * h + u, P = s * o * h + a * l, C = a * s * h + o * l, R = o * s * h - a * l, O = s * s * h + u, t[0] = d * E + v * T + b * S, t[1] = p * E + g * T + w * S, t[2] = f * E + y * T + _ * S, t[3] = m * E + x * T + M * S, t[4] = d * A + v * L + b * P, t[5] = p * A + g * L + w * P, t[6] = f * A + y * L + _ * P, t[7] = m * A + x * L + M * P, t[8] = d * C + v * R + b * O, t[9] = p * C + g * R + w * O, t[10] = f * C + y * R + _ * O, t[11] = m * C + x * R + M * O, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]);
                    return t
                }, e.rotateX = function(t, e, n) {
                    var i = Math.sin(n),
                        r = Math.cos(n),
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        c = e[7],
                        l = e[8],
                        u = e[9],
                        h = e[10],
                        d = e[11];
                    e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]);
                    return t[4] = a * r + l * i, t[5] = o * r + u * i, t[6] = s * r + h * i, t[7] = c * r + d * i, t[8] = l * r - a * i, t[9] = u * r - o * i, t[10] = h * r - s * i, t[11] = d * r - c * i, t
                }, e.rotateY = function(t, e, n) {
                    var i = Math.sin(n),
                        r = Math.cos(n),
                        a = e[0],
                        o = e[1],
                        s = e[2],
                        c = e[3],
                        l = e[8],
                        u = e[9],
                        h = e[10],
                        d = e[11];
                    e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]);
                    return t[0] = a * r - l * i, t[1] = o * r - u * i, t[2] = s * r - h * i, t[3] = c * r - d * i, t[8] = a * i + l * r, t[9] = o * i + u * r, t[10] = s * i + h * r, t[11] = c * i + d * r, t
                }, e.rotateZ = function(t, e, n) {
                    var i = Math.sin(n),
                        r = Math.cos(n),
                        a = e[0],
                        o = e[1],
                        s = e[2],
                        c = e[3],
                        l = e[4],
                        u = e[5],
                        h = e[6],
                        d = e[7];
                    e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]);
                    return t[0] = a * r + l * i, t[1] = o * r + u * i, t[2] = s * r + h * i, t[3] = c * r + d * i, t[4] = l * r - a * i, t[5] = u * r - o * i, t[6] = h * r - s * i, t[7] = d * r - c * i, t
                }, e.fromTranslation = function(t, e) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t
                }, e.fromScaling = function(t, e) {
                    return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
                }, e.fromRotation = function(t, e, n) {
                    var r = n[0],
                        a = n[1],
                        o = n[2],
                        s = Math.sqrt(r * r + a * a + o * o),
                        c = void 0,
                        l = void 0,
                        u = void 0;
                    if (Math.abs(s) < i.EPSILON) return null;
                    return r *= s = 1 / s, a *= s, o *= s, c = Math.sin(e), l = Math.cos(e), u = 1 - l, t[0] = r * r * u + l, t[1] = a * r * u + o * c, t[2] = o * r * u - a * c, t[3] = 0, t[4] = r * a * u - o * c, t[5] = a * a * u + l, t[6] = o * a * u + r * c, t[7] = 0, t[8] = r * o * u + a * c, t[9] = a * o * u - r * c, t[10] = o * o * u + l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
                }, e.fromXRotation = function(t, e) {
                    var n = Math.sin(e),
                        i = Math.cos(e);
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = i, t[6] = n, t[7] = 0, t[8] = 0, t[9] = -n, t[10] = i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
                }, e.fromYRotation = function(t, e) {
                    var n = Math.sin(e),
                        i = Math.cos(e);
                    return t[0] = i, t[1] = 0, t[2] = -n, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = n, t[9] = 0, t[10] = i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
                }, e.fromZRotation = function(t, e) {
                    var n = Math.sin(e),
                        i = Math.cos(e);
                    return t[0] = i, t[1] = n, t[2] = 0, t[3] = 0, t[4] = -n, t[5] = i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
                }, e.fromRotationTranslation = function(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = i + i,
                        c = r + r,
                        l = a + a,
                        u = i * s,
                        h = i * c,
                        d = i * l,
                        p = r * c,
                        f = r * l,
                        m = a * l,
                        v = o * s,
                        g = o * c,
                        y = o * l;
                    return t[0] = 1 - (p + m), t[1] = h + y, t[2] = d - g, t[3] = 0, t[4] = h - y, t[5] = 1 - (u + m), t[6] = f + v, t[7] = 0, t[8] = d + g, t[9] = f - v, t[10] = 1 - (u + p), t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t
                }, e.getTranslation = function(t, e) {
                    return t[0] = e[12], t[1] = e[13], t[2] = e[14], t
                }, e.getScaling = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        c = e[8],
                        l = e[9],
                        u = e[10];
                    return t[0] = Math.sqrt(n * n + i * i + r * r), t[1] = Math.sqrt(a * a + o * o + s * s), t[2] = Math.sqrt(c * c + l * l + u * u), t
                }, e.getRotation = function(t, e) {
                    var n = e[0] + e[5] + e[10],
                        i = 0;
                    n > 0 ? (i = 2 * Math.sqrt(n + 1), t[3] = .25 * i, t[0] = (e[6] - e[9]) / i, t[1] = (e[8] - e[2]) / i, t[2] = (e[1] - e[4]) / i) : e[0] > e[5] & e[0] > e[10] ? (i = 2 * Math.sqrt(1 + e[0] - e[5] - e[10]), t[3] = (e[6] - e[9]) / i, t[0] = .25 * i, t[1] = (e[1] + e[4]) / i, t[2] = (e[8] + e[2]) / i) : e[5] > e[10] ? (i = 2 * Math.sqrt(1 + e[5] - e[0] - e[10]), t[3] = (e[8] - e[2]) / i, t[0] = (e[1] + e[4]) / i, t[1] = .25 * i, t[2] = (e[6] + e[9]) / i) : (i = 2 * Math.sqrt(1 + e[10] - e[0] - e[5]), t[3] = (e[1] - e[4]) / i, t[0] = (e[8] + e[2]) / i, t[1] = (e[6] + e[9]) / i, t[2] = .25 * i);
                    return t
                }, e.fromRotationTranslationScale = function(t, e, n, i) {
                    var r = e[0],
                        a = e[1],
                        o = e[2],
                        s = e[3],
                        c = r + r,
                        l = a + a,
                        u = o + o,
                        h = r * c,
                        d = r * l,
                        p = r * u,
                        f = a * l,
                        m = a * u,
                        v = o * u,
                        g = s * c,
                        y = s * l,
                        x = s * u,
                        b = i[0],
                        w = i[1],
                        _ = i[2];
                    return t[0] = (1 - (f + v)) * b, t[1] = (d + x) * b, t[2] = (p - y) * b, t[3] = 0, t[4] = (d - x) * w, t[5] = (1 - (h + v)) * w, t[6] = (m + g) * w, t[7] = 0, t[8] = (p + y) * _, t[9] = (m - g) * _, t[10] = (1 - (h + f)) * _, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t
                }, e.fromRotationTranslationScaleOrigin = function(t, e, n, i, r) {
                    var a = e[0],
                        o = e[1],
                        s = e[2],
                        c = e[3],
                        l = a + a,
                        u = o + o,
                        h = s + s,
                        d = a * l,
                        p = a * u,
                        f = a * h,
                        m = o * u,
                        v = o * h,
                        g = s * h,
                        y = c * l,
                        x = c * u,
                        b = c * h,
                        w = i[0],
                        _ = i[1],
                        M = i[2],
                        E = r[0],
                        T = r[1],
                        S = r[2];
                    return t[0] = (1 - (m + g)) * w, t[1] = (p + b) * w, t[2] = (f - x) * w, t[3] = 0, t[4] = (p - b) * _, t[5] = (1 - (d + g)) * _, t[6] = (v + y) * _, t[7] = 0, t[8] = (f + x) * M, t[9] = (v - y) * M, t[10] = (1 - (d + m)) * M, t[11] = 0, t[12] = n[0] + E - (t[0] * E + t[4] * T + t[8] * S), t[13] = n[1] + T - (t[1] * E + t[5] * T + t[9] * S), t[14] = n[2] + S - (t[2] * E + t[6] * T + t[10] * S), t[15] = 1, t
                }, e.fromQuat = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = n + n,
                        s = i + i,
                        c = r + r,
                        l = n * o,
                        u = i * o,
                        h = i * s,
                        d = r * o,
                        p = r * s,
                        f = r * c,
                        m = a * o,
                        v = a * s,
                        g = a * c;
                    return t[0] = 1 - h - f, t[1] = u + g, t[2] = d - v, t[3] = 0, t[4] = u - g, t[5] = 1 - l - f, t[6] = p + m, t[7] = 0, t[8] = d + v, t[9] = p - m, t[10] = 1 - l - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
                }, e.frustum = function(t, e, n, i, r, a, o) {
                    var s = 1 / (n - e),
                        c = 1 / (r - i),
                        l = 1 / (a - o);
                    return t[0] = 2 * a * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * a * c, t[6] = 0, t[7] = 0, t[8] = (n + e) * s, t[9] = (r + i) * c, t[10] = (o + a) * l, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = o * a * 2 * l, t[15] = 0, t
                }, e.perspective = function(t, e, n, i, r) {
                    var a = 1 / Math.tan(e / 2),
                        o = 1 / (i - r);
                    return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = (r + i) * o, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = 2 * r * i * o, t[15] = 0, t
                }, e.perspectiveFromFieldOfView = function(t, e, n, i) {
                    var r = Math.tan(e.upDegrees * Math.PI / 180),
                        a = Math.tan(e.downDegrees * Math.PI / 180),
                        o = Math.tan(e.leftDegrees * Math.PI / 180),
                        s = Math.tan(e.rightDegrees * Math.PI / 180),
                        c = 2 / (o + s),
                        l = 2 / (r + a);
                    return t[0] = c, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = l, t[6] = 0, t[7] = 0, t[8] = -(o - s) * c * .5, t[9] = (r - a) * l * .5, t[10] = i / (n - i), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = i * n / (n - i), t[15] = 0, t
                }, e.ortho = function(t, e, n, i, r, a, o) {
                    var s = 1 / (e - n),
                        c = 1 / (i - r),
                        l = 1 / (a - o);
                    return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (e + n) * s, t[13] = (r + i) * c, t[14] = (o + a) * l, t[15] = 1, t
                }, e.lookAt = function(t, e, n, r) {
                    var a = void 0,
                        o = void 0,
                        s = void 0,
                        c = void 0,
                        l = void 0,
                        u = void 0,
                        h = void 0,
                        d = void 0,
                        p = void 0,
                        f = void 0,
                        m = e[0],
                        v = e[1],
                        g = e[2],
                        y = r[0],
                        x = r[1],
                        b = r[2],
                        w = n[0],
                        _ = n[1],
                        M = n[2];
                    if (Math.abs(m - w) < i.EPSILON && Math.abs(v - _) < i.EPSILON && Math.abs(g - M) < i.EPSILON) return mat4.identity(t);
                    h = m - w, d = v - _, p = g - M, f = 1 / Math.sqrt(h * h + d * d + p * p), a = x * (p *= f) - b * (d *= f), o = b * (h *= f) - y * p, s = y * d - x * h, (f = Math.sqrt(a * a + o * o + s * s)) ? (a *= f = 1 / f, o *= f, s *= f) : (a = 0, o = 0, s = 0);
                    c = d * s - p * o, l = p * a - h * s, u = h * o - d * a, (f = Math.sqrt(c * c + l * l + u * u)) ? (c *= f = 1 / f, l *= f, u *= f) : (c = 0, l = 0, u = 0);
                    return t[0] = a, t[1] = c, t[2] = h, t[3] = 0, t[4] = o, t[5] = l, t[6] = d, t[7] = 0, t[8] = s, t[9] = u, t[10] = p, t[11] = 0, t[12] = -(a * m + o * v + s * g), t[13] = -(c * m + l * v + u * g), t[14] = -(h * m + d * v + p * g), t[15] = 1, t
                }, e.targetTo = function(t, e, n, i) {
                    var r = e[0],
                        a = e[1],
                        o = e[2],
                        s = i[0],
                        c = i[1],
                        l = i[2],
                        u = r - n[0],
                        h = a - n[1],
                        d = o - n[2],
                        p = u * u + h * h + d * d;
                    p > 0 && (p = 1 / Math.sqrt(p), u *= p, h *= p, d *= p);
                    var f = c * d - l * h,
                        m = l * u - s * d,
                        v = s * h - c * u;
                    return t[0] = f, t[1] = m, t[2] = v, t[3] = 0, t[4] = h * v - d * m, t[5] = d * f - u * v, t[6] = u * m - h * f, t[7] = 0, t[8] = u, t[9] = h, t[10] = d, t[11] = 0, t[12] = r, t[13] = a, t[14] = o, t[15] = 1, t
                }, e.str = function(t) {
                    return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")"
                }, e.frob = function(t) {
                    return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2) + Math.pow(t[9], 2) + Math.pow(t[10], 2) + Math.pow(t[11], 2) + Math.pow(t[12], 2) + Math.pow(t[13], 2) + Math.pow(t[14], 2) + Math.pow(t[15], 2))
                }, e.add = function(t, e, n) {
                    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t[9] = e[9] + n[9], t[10] = e[10] + n[10], t[11] = e[11] + n[11], t[12] = e[12] + n[12], t[13] = e[13] + n[13], t[14] = e[14] + n[14], t[15] = e[15] + n[15], t
                }, e.subtract = a, e.multiplyScalar = function(t, e, n) {
                    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12] * n, t[13] = e[13] * n, t[14] = e[14] * n, t[15] = e[15] * n, t
                }, e.multiplyScalarAndAdd = function(t, e, n, i) {
                    return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t[2] = e[2] + n[2] * i, t[3] = e[3] + n[3] * i, t[4] = e[4] + n[4] * i, t[5] = e[5] + n[5] * i, t[6] = e[6] + n[6] * i, t[7] = e[7] + n[7] * i, t[8] = e[8] + n[8] * i, t[9] = e[9] + n[9] * i, t[10] = e[10] + n[10] * i, t[11] = e[11] + n[11] * i, t[12] = e[12] + n[12] * i, t[13] = e[13] + n[13] * i, t[14] = e[14] + n[14] * i, t[15] = e[15] + n[15] * i, t
                }, e.exactEquals = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15]
                }, e.equals = function(t, e) {
                    var n = t[0],
                        r = t[1],
                        a = t[2],
                        o = t[3],
                        s = t[4],
                        c = t[5],
                        l = t[6],
                        u = t[7],
                        h = t[8],
                        d = t[9],
                        p = t[10],
                        f = t[11],
                        m = t[12],
                        v = t[13],
                        g = t[14],
                        y = t[15],
                        x = e[0],
                        b = e[1],
                        w = e[2],
                        _ = e[3],
                        M = e[4],
                        E = e[5],
                        T = e[6],
                        S = e[7],
                        A = e[8],
                        L = e[9],
                        P = e[10],
                        C = e[11],
                        R = e[12],
                        O = e[13],
                        I = e[14],
                        N = e[15];
                    return Math.abs(n - x) <= i.EPSILON * Math.max(1, Math.abs(n), Math.abs(x)) && Math.abs(r - b) <= i.EPSILON * Math.max(1, Math.abs(r), Math.abs(b)) && Math.abs(a - w) <= i.EPSILON * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(o - _) <= i.EPSILON * Math.max(1, Math.abs(o), Math.abs(_)) && Math.abs(s - M) <= i.EPSILON * Math.max(1, Math.abs(s), Math.abs(M)) && Math.abs(c - E) <= i.EPSILON * Math.max(1, Math.abs(c), Math.abs(E)) && Math.abs(l - T) <= i.EPSILON * Math.max(1, Math.abs(l), Math.abs(T)) && Math.abs(u - S) <= i.EPSILON * Math.max(1, Math.abs(u), Math.abs(S)) && Math.abs(h - A) <= i.EPSILON * Math.max(1, Math.abs(h), Math.abs(A)) && Math.abs(d - L) <= i.EPSILON * Math.max(1, Math.abs(d), Math.abs(L)) && Math.abs(p - P) <= i.EPSILON * Math.max(1, Math.abs(p), Math.abs(P)) && Math.abs(f - C) <= i.EPSILON * Math.max(1, Math.abs(f), Math.abs(C)) && Math.abs(m - R) <= i.EPSILON * Math.max(1, Math.abs(m), Math.abs(R)) && Math.abs(v - O) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(O)) && Math.abs(g - I) <= i.EPSILON * Math.max(1, Math.abs(g), Math.abs(I)) && Math.abs(y - N) <= i.EPSILON * Math.max(1, Math.abs(y), Math.abs(N))
                };
                var i = function(t) {
                    {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }
                }(n(0));
  
                function r(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = e[5],
                        l = e[6],
                        u = e[7],
                        h = e[8],
                        d = e[9],
                        p = e[10],
                        f = e[11],
                        m = e[12],
                        v = e[13],
                        g = e[14],
                        y = e[15],
                        x = n[0],
                        b = n[1],
                        w = n[2],
                        _ = n[3];
                    return t[0] = x * i + b * s + w * h + _ * m, t[1] = x * r + b * c + w * d + _ * v, t[2] = x * a + b * l + w * p + _ * g, t[3] = x * o + b * u + w * f + _ * y, x = n[4], b = n[5], w = n[6], _ = n[7], t[4] = x * i + b * s + w * h + _ * m, t[5] = x * r + b * c + w * d + _ * v, t[6] = x * a + b * l + w * p + _ * g, t[7] = x * o + b * u + w * f + _ * y, x = n[8], b = n[9], w = n[10], _ = n[11], t[8] = x * i + b * s + w * h + _ * m, t[9] = x * r + b * c + w * d + _ * v, t[10] = x * a + b * l + w * p + _ * g, t[11] = x * o + b * u + w * f + _ * y, x = n[12], b = n[13], w = n[14], _ = n[15], t[12] = x * i + b * s + w * h + _ * m, t[13] = x * r + b * c + w * d + _ * v, t[14] = x * a + b * l + w * p + _ * g, t[15] = x * o + b * u + w * f + _ * y, t
                }
  
                function a(t, e, n) {
                    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t[9] = e[9] - n[9], t[10] = e[10] - n[10], t[11] = e[11] - n[11], t[12] = e[12] - n[12], t[13] = e[13] - n[13], t[14] = e[14] - n[14], t[15] = e[15] - n[15], t
                }
                e.mul = r, e.sub = a
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.setAxes = e.sqlerp = e.rotationTo = e.equals = e.exactEquals = e.normalize = e.sqrLen = e.squaredLength = e.len = e.length = e.lerp = e.dot = e.scale = e.mul = e.add = e.set = e.copy = e.fromValues = e.clone = void 0, e.create = c, e.identity = function(t) {
                    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t
                }, e.setAxisAngle = l, e.getAxisAngle = function(t, e) {
                    var n = 2 * Math.acos(e[3]),
                        i = Math.sin(n / 2);
                    0 != i ? (t[0] = e[0] / i, t[1] = e[1] / i, t[2] = e[2] / i) : (t[0] = 1, t[1] = 0, t[2] = 0);
                    return n
                }, e.multiply = u, e.rotateX = function(t, e, n) {
                    n *= .5;
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = Math.sin(n),
                        c = Math.cos(n);
                    return t[0] = i * c + o * s, t[1] = r * c + a * s, t[2] = a * c - r * s, t[3] = o * c - i * s, t
                }, e.rotateY = function(t, e, n) {
                    n *= .5;
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = Math.sin(n),
                        c = Math.cos(n);
                    return t[0] = i * c - a * s, t[1] = r * c + o * s, t[2] = a * c + i * s, t[3] = o * c - r * s, t
                }, e.rotateZ = function(t, e, n) {
                    n *= .5;
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = Math.sin(n),
                        c = Math.cos(n);
                    return t[0] = i * c + r * s, t[1] = r * c - i * s, t[2] = a * c + o * s, t[3] = o * c - a * s, t
                }, e.calculateW = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2];
                    return t[0] = n, t[1] = i, t[2] = r, t[3] = Math.sqrt(Math.abs(1 - n * n - i * i - r * r)), t
                }, e.slerp = h, e.invert = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = e[2],
                        a = e[3],
                        o = n * n + i * i + r * r + a * a,
                        s = o ? 1 / o : 0;
                    return t[0] = -n * s, t[1] = -i * s, t[2] = -r * s, t[3] = a * s, t
                }, e.conjugate = function(t, e) {
                    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t
                }, e.fromMat3 = d, e.fromEuler = function(t, e, n, i) {
                    var r = .5 * Math.PI / 180;
                    e *= r, n *= r, i *= r;
                    var a = Math.sin(e),
                        o = Math.cos(e),
                        s = Math.sin(n),
                        c = Math.cos(n),
                        l = Math.sin(i),
                        u = Math.cos(i);
                    return t[0] = a * c * u - o * s * l, t[1] = o * s * u + a * c * l, t[2] = o * c * l - a * s * u, t[3] = o * c * u + a * s * l, t
                }, e.str = function(t) {
                    return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
                };
                var i = s(n(0)),
                    r = s(n(1)),
                    a = s(n(2)),
                    o = s(n(3));
  
                function s(t) {
                    if (t && t.__esModule) return t;
                    var e = {};
                    if (null != t)
                        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                    return e.default = t, e
                }
  
                function c() {
                    var t = new i.ARRAY_TYPE(4);
                    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t
                }
  
                function l(t, e, n) {
                    n *= .5;
                    var i = Math.sin(n);
                    return t[0] = i * e[0], t[1] = i * e[1], t[2] = i * e[2], t[3] = Math.cos(n), t
                }
  
                function u(t, e, n) {
                    var i = e[0],
                        r = e[1],
                        a = e[2],
                        o = e[3],
                        s = n[0],
                        c = n[1],
                        l = n[2],
                        u = n[3];
                    return t[0] = i * u + o * s + r * l - a * c, t[1] = r * u + o * c + a * s - i * l, t[2] = a * u + o * l + i * c - r * s, t[3] = o * u - i * s - r * c - a * l, t
                }
  
                function h(t, e, n, i) {
                    var r = e[0],
                        a = e[1],
                        o = e[2],
                        s = e[3],
                        c = n[0],
                        l = n[1],
                        u = n[2],
                        h = n[3],
                        d = void 0,
                        p = void 0,
                        f = void 0,
                        m = void 0,
                        v = void 0;
                    return (p = r * c + a * l + o * u + s * h) < 0 && (p = -p, c = -c, l = -l, u = -u, h = -h), 1 - p > 1e-6 ? (d = Math.acos(p), f = Math.sin(d), m = Math.sin((1 - i) * d) / f, v = Math.sin(i * d) / f) : (m = 1 - i, v = i), t[0] = m * r + v * c, t[1] = m * a + v * l, t[2] = m * o + v * u, t[3] = m * s + v * h, t
                }
  
                function d(t, e) {
                    var n = e[0] + e[4] + e[8],
                        i = void 0;
                    if (n > 0) i = Math.sqrt(n + 1), t[3] = .5 * i, i = .5 / i, t[0] = (e[5] - e[7]) * i, t[1] = (e[6] - e[2]) * i, t[2] = (e[1] - e[3]) * i;
                    else {
                        var r = 0;
                        e[4] > e[0] && (r = 1), e[8] > e[3 * r + r] && (r = 2);
                        var a = (r + 1) % 3,
                            o = (r + 2) % 3;
                        i = Math.sqrt(e[3 * r + r] - e[3 * a + a] - e[3 * o + o] + 1), t[r] = .5 * i, i = .5 / i, t[3] = (e[3 * a + o] - e[3 * o + a]) * i, t[a] = (e[3 * a + r] + e[3 * r + a]) * i, t[o] = (e[3 * o + r] + e[3 * r + o]) * i
                    }
                    return t
                }
                e.clone = o.clone, e.fromValues = o.fromValues, e.copy = o.copy, e.set = o.set, e.add = o.add, e.mul = u, e.scale = o.scale, e.dot = o.dot, e.lerp = o.lerp;
                var p, f, m, v, g, y, x = e.length = o.length,
                    b = (e.len = x, e.squaredLength = o.squaredLength),
                    w = (e.sqrLen = b, e.normalize = o.normalize);
                e.exactEquals = o.exactEquals, e.equals = o.equals, e.rotationTo = (p = a.create(), f = a.fromValues(1, 0, 0), m = a.fromValues(0, 1, 0), function(t, e, n) {
                    var i = a.dot(e, n);
                    return i < -.999999 ? (a.cross(p, f, e), a.len(p) < 1e-6 && a.cross(p, m, e), a.normalize(p, p), l(t, p, Math.PI), t) : i > .999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (a.cross(p, e, n), t[0] = p[0], t[1] = p[1], t[2] = p[2], t[3] = 1 + i, w(t, t))
                }), e.sqlerp = (v = c(), g = c(), function(t, e, n, i, r, a) {
                    return h(v, e, r, a), h(g, n, i, a), h(t, v, g, 2 * a * (1 - a)), t
                }), e.setAxes = (y = r.create(), function(t, e, n, i) {
                    return y[0] = n[0], y[3] = n[1], y[6] = n[2], y[1] = i[0], y[4] = i[1], y[7] = i[2], y[2] = -e[0], y[5] = -e[1], y[8] = -e[2], w(t, d(t, y))
                })
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.forEach = e.sqrLen = e.sqrDist = e.dist = e.div = e.mul = e.sub = e.len = void 0, e.create = r, e.clone = function(t) {
                    var e = new i.ARRAY_TYPE(2);
                    return e[0] = t[0], e[1] = t[1], e
                }, e.fromValues = function(t, e) {
                    var n = new i.ARRAY_TYPE(2);
                    return n[0] = t, n[1] = e, n
                }, e.copy = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t
                }, e.set = function(t, e, n) {
                    return t[0] = e, t[1] = n, t
                }, e.add = function(t, e, n) {
                    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t
                }, e.subtract = a, e.multiply = o, e.divide = s, e.ceil = function(t, e) {
                    return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t
                }, e.floor = function(t, e) {
                    return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t
                }, e.min = function(t, e, n) {
                    return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t
                }, e.max = function(t, e, n) {
                    return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t
                }, e.round = function(t, e) {
                    return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t
                }, e.scale = function(t, e, n) {
                    return t[0] = e[0] * n, t[1] = e[1] * n, t
                }, e.scaleAndAdd = function(t, e, n, i) {
                    return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t
                }, e.distance = c, e.squaredDistance = l, e.length = u, e.squaredLength = h, e.negate = function(t, e) {
                    return t[0] = -e[0], t[1] = -e[1], t
                }, e.inverse = function(t, e) {
                    return t[0] = 1 / e[0], t[1] = 1 / e[1], t
                }, e.normalize = function(t, e) {
                    var n = e[0],
                        i = e[1],
                        r = n * n + i * i;
                    r > 0 && (r = 1 / Math.sqrt(r), t[0] = e[0] * r, t[1] = e[1] * r);
                    return t
                }, e.dot = function(t, e) {
                    return t[0] * e[0] + t[1] * e[1]
                }, e.cross = function(t, e, n) {
                    var i = e[0] * n[1] - e[1] * n[0];
                    return t[0] = t[1] = 0, t[2] = i, t
                }, e.lerp = function(t, e, n, i) {
                    var r = e[0],
                        a = e[1];
                    return t[0] = r + i * (n[0] - r), t[1] = a + i * (n[1] - a), t
                }, e.random = function(t, e) {
                    e = e || 1;
                    var n = 2 * i.RANDOM() * Math.PI;
                    return t[0] = Math.cos(n) * e, t[1] = Math.sin(n) * e, t
                }, e.transformMat2 = function(t, e, n) {
                    var i = e[0],
                        r = e[1];
                    return t[0] = n[0] * i + n[2] * r, t[1] = n[1] * i + n[3] * r, t
                }, e.transformMat2d = function(t, e, n) {
                    var i = e[0],
                        r = e[1];
                    return t[0] = n[0] * i + n[2] * r + n[4], t[1] = n[1] * i + n[3] * r + n[5], t
                }, e.transformMat3 = function(t, e, n) {
                    var i = e[0],
                        r = e[1];
                    return t[0] = n[0] * i + n[3] * r + n[6], t[1] = n[1] * i + n[4] * r + n[7], t
                }, e.transformMat4 = function(t, e, n) {
                    var i = e[0],
                        r = e[1];
                    return t[0] = n[0] * i + n[4] * r + n[12], t[1] = n[1] * i + n[5] * r + n[13], t
                }, e.str = function(t) {
                    return "vec2(" + t[0] + ", " + t[1] + ")"
                }, e.exactEquals = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1]
                }, e.equals = function(t, e) {
                    var n = t[0],
                        r = t[1],
                        a = e[0],
                        o = e[1];
                    return Math.abs(n - a) <= i.EPSILON * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - o) <= i.EPSILON * Math.max(1, Math.abs(r), Math.abs(o))
                };
                var i = function(t) {
                    {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }
                }(n(0));
  
                function r() {
                    var t = new i.ARRAY_TYPE(2);
                    return t[0] = 0, t[1] = 0, t
                }
  
                function a(t, e, n) {
                    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t
                }
  
                function o(t, e, n) {
                    return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t
                }
  
                function s(t, e, n) {
                    return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t
                }
  
                function c(t, e) {
                    var n = e[0] - t[0],
                        i = e[1] - t[1];
                    return Math.sqrt(n * n + i * i)
                }
  
                function l(t, e) {
                    var n = e[0] - t[0],
                        i = e[1] - t[1];
                    return n * n + i * i
                }
  
                function u(t) {
                    var e = t[0],
                        n = t[1];
                    return Math.sqrt(e * e + n * n)
                }
  
                function h(t) {
                    var e = t[0],
                        n = t[1];
                    return e * e + n * n
                }
                var d;
                e.len = u, e.sub = a, e.mul = o, e.div = s, e.dist = c, e.sqrDist = l, e.sqrLen = h, e.forEach = (d = r(), function(t, e, n, i, r, a) {
                    var o = void 0,
                        s = void 0;
                    for (e || (e = 2), n || (n = 0), s = i ? Math.min(i * e + n, t.length) : t.length, o = n; o < s; o += e) d[0] = t[o], d[1] = t[o + 1], r(d, d, a), t[o] = d[0], t[o + 1] = d[1];
                    return t
                })
            }])
        })
    }, {}],
    2: [function(t, e, n) {
        e.exports = function(t) {
            "string" == typeof t && (t = [t]);
            for (var e = [].slice.call(arguments, 1), n = [], i = 0; i < t.length - 1; i++) n.push(t[i], e[i] || "");
            return n.push(t[i]), n.join("")
        }
    }, {}],
    3: [function(t, e, n) {
        ! function(t) {
            var i = !1;
            if ("function" == typeof define && define.amd && (define(t), i = !0), "object" == typeof n && (e.exports = t(), i = !0), !i) {
                var r = window.Cookies,
                    a = window.Cookies = t();
                a.noConflict = function() {
                    return window.Cookies = r, a
                }
            }
        }(function() {
            function t() {
                for (var t = 0, e = {}; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var i in n) e[i] = n[i]
                }
                return e
            }
            return function e(n) {
                function i(e, r, a) {
                    var o;
                    if ("undefined" != typeof document) {
                        if (arguments.length > 1) {
                            if ("number" == typeof(a = t({
                                    path: "/"
                                }, i.defaults, a)).expires) {
                                var s = new Date;
                                s.setMilliseconds(s.getMilliseconds() + 864e5 * a.expires), a.expires = s
                            }
                            a.expires = a.expires ? a.expires.toUTCString() : "";
                            try {
                                o = JSON.stringify(r), /^[\{\[]/.test(o) && (r = o)
                            } catch (t) {}
                            r = n.write ? n.write(r, e) : encodeURIComponent(String(r)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), e = (e = (e = encodeURIComponent(String(e))).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)).replace(/[\(\)]/g, escape);
                            var c = "";
                            for (var l in a) a[l] && (c += "; " + l, !0 !== a[l] && (c += "=" + a[l]));
                            return document.cookie = e + "=" + r + c
                        }
                        e || (o = {});
                        for (var u = document.cookie ? document.cookie.split("; ") : [], h = /(%[0-9A-Z]{2})+/g, d = 0; d < u.length; d++) {
                            var p = u[d].split("="),
                                f = p.slice(1).join("=");
                            this.json || '"' !== f.charAt(0) || (f = f.slice(1, -1));
                            try {
                                var m = p[0].replace(h, decodeURIComponent);
                                if (f = n.read ? n.read(f, m) : n(f, m) || f.replace(h, decodeURIComponent), this.json) try {
                                    f = JSON.parse(f)
                                } catch (t) {}
                                if (e === m) {
                                    o = f;
                                    break
                                }
                                e || (o[m] = f)
                            } catch (t) {}
                        }
                        return o
                    }
                }
                return i.set = i, i.get = function(t) {
                    return i.call(i, t)
                }, i.getJSON = function() {
                    return i.apply({
                        json: !0
                    }, [].slice.call(arguments))
                }, i.defaults = {}, i.remove = function(e, n) {
                    i(e, "", t(n, {
                        expires: -1
                    }))
                }, i.withConverter = e, i
            }(function() {})
        })
    }, {}],
    4: [function(t, e, n) {
        e.exports = function(t) {
            var e = this;
            this.elm = t, this.isTouched = !1, this.elm.addEventListener("touchstart", function() {
                e.isTouched = !0
            }, !1), this.elm.addEventListener("touchstartend", function() {
                e.isTouched = !1
            }, !1), this.elm.addEventListener("mouseover", function() {
                e.isTouched || (e.elm.classList.remove("is-leave"), e.elm.classList.add("is-over"))
            }, !1), this.elm.addEventListener("mouseleave", function() {
                e.isTouched || (e.elm.classList.remove("is-over"), e.elm.classList.add("is-leave"))
            }, !1)
        }
    }, {}],
    5: [function(t, e, n) {
        e.exports = {
            degrees: function(t) {
                return t / Math.PI * 180
            },
            radians: function(t) {
                return t * Math.PI / 180
            },
            clamp: function(t, e, n) {
                return Math.min(Math.max(t, e), n)
            },
            mix: function(t, e, n) {
                return t * (1 - n) + e * n
            },
            spherical: function(t, e, n) {
                return [Math.cos(t) * Math.cos(e) * n, Math.sin(t) * n, Math.cos(t) * Math.sin(e) * n]
            },
            randomArbitrary: function(t, e) {
                return Math.random() * (e - t) + t
            },
            randomInt: function(t, e) {
                return Math.floor(Math.random() * (e - t + 1)) + t
            }
        }
    }, {}],
    6: [function(t, e, n) {
        e.exports = function(t, e) {
            var n;
            return function(i) {
                clearTimeout(n), n = setTimeout(function() {
                    t(i)
                }, e)
            }
        }
    }, {}],
    7: [function(t, e, n) {
        e.exports = function() {
            return navigator.userAgent.indexOf("Android") >= 0
        }
    }, {}],
    8: [function(t, e, n) {
        e.exports = function() {
            var t = navigator.userAgent;
            return t.indexOf("MSIE") > -1 || t.indexOf("rv:11.0") > -1
        }
    }, {}],
    9: [function(t, e, n) {
        e.exports = function() {
            var t = navigator.userAgent;
            return t.indexOf("iPhone") >= 0 || t.indexOf("iPod") >= 0 || t.indexOf("iPad") >= 0
        }
    }, {}],
    10: [function(t, e, n) {
        var i, r;
        i = this, r = function(t) {
            "use strict";
  
            function e() {}
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : +t
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(t) {
                if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), n = 1; n < arguments.length; n++) {
                    var i = arguments[n];
                    if (null != i)
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
                }
                return e
            }), Object.assign(e.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners[t];
                        if (void 0 !== n) {
                            var i = n.indexOf(e); - 1 !== i && n.splice(i, 1)
                        }
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var n = e.slice(0), i = 0, r = n.length; i < r; i++) n[i].call(this, t)
                        }
                    }
                }
            });
            var n, i, r, a, o, s, c, l, u, h, d, p, f, m, v, g, y, x, b, w, _ = "89",
                M = 0,
                E = 1,
                T = 2,
                S = 0,
                A = 1,
                L = 2,
                P = 0,
                C = 1,
                R = 2,
                O = 0,
                I = 1,
                N = 2,
                D = 0,
                U = 1,
                k = 2,
                F = 3,
                z = 4,
                B = 5,
                j = 100,
                G = 101,
                H = 102,
                V = 103,
                W = 104,
                X = 200,
                q = 201,
                Y = 202,
                $ = 203,
                Z = 204,
                J = 205,
                K = 206,
                Q = 207,
                tt = 208,
                et = 209,
                nt = 210,
                it = 0,
                rt = 1,
                at = 2,
                ot = 3,
                st = 4,
                ct = 5,
                lt = 6,
                ut = 7,
                ht = 0,
                dt = 1,
                pt = 2,
                ft = 0,
                mt = 1,
                vt = 2,
                gt = 3,
                yt = 4,
                xt = 301,
                bt = 302,
                wt = 303,
                _t = 304,
                Mt = 305,
                Et = 306,
                Tt = 307,
                St = 1e3,
                At = 1001,
                Lt = 1002,
                Pt = 1003,
                Ct = 1004,
                Rt = 1005,
                Ot = 1006,
                It = 1007,
                Nt = 1008,
                Dt = 1009,
                Ut = 1010,
                kt = 1011,
                Ft = 1012,
                zt = 1013,
                Bt = 1014,
                jt = 1015,
                Gt = 1016,
                Ht = 1017,
                Vt = 1018,
                Wt = 1019,
                Xt = 1020,
                qt = 1021,
                Yt = 1022,
                $t = 1023,
                Zt = 1024,
                Jt = 1025,
                Kt = $t,
                Qt = 1026,
                te = 1027,
                ee = 2001,
                ne = 2002,
                ie = 2003,
                re = 2004,
                ae = 2100,
                oe = 2101,
                se = 2102,
                ce = 2103,
                le = 2151,
                ue = 2201,
                he = 2300,
                de = 2301,
                pe = 2400,
                fe = 2401,
                me = 2402,
                ve = 0,
                ge = 1,
                ye = 2,
                xe = 3e3,
                be = 3001,
                we = 3007,
                _e = 3002,
                Me = 3004,
                Ee = 3005,
                Te = 3006,
                Se = 3200,
                Ae = 3201,
                Le = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16).toUpperCase();
                        return function() {
                            var e = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0;
                            return t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & n] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[63 & i | 128] + t[i >> 8 & 255] + "-" + t[i >> 16 & 255] + t[i >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]
                        }
                    }(),
                    clamp: function(t, e, n) {
                        return Math.max(e, Math.min(n, t))
                    },
                    euclideanModulo: function(t, e) {
                        return (t % e + e) % e
                    },
                    mapLinear: function(t, e, n, i, r) {
                        return i + (t - e) * (r - i) / (n - e)
                    },
                    lerp: function(t, e, n) {
                        return (1 - n) * t + n * e
                    },
                    smoothstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    degToRad: function(t) {
                        return t * Le.DEG2RAD
                    },
                    radToDeg: function(t) {
                        return t * Le.RAD2DEG
                    },
                    isPowerOfTwo: function(t) {
                        return 0 == (t & t - 1) && 0 !== t
                    },
                    ceilPowerOfTwo: function(t) {
                        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                    },
                    floorPowerOfTwo: function(t) {
                        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                    }
                };
  
            function Pe(t, e) {
                this.x = t || 0, this.y = e || 0
            }
  
            function Ce() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
  
            function Re(t, e, n, i) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
            }
  
            function Oe(t, e, n) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0
            }
  
            function Ie() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.defineProperties(Pe.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }
            }), Object.assign(Pe.prototype, {
                isVector2: !0,
                set: function(t, e) {
                    return this.x = t, this.y = e, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                },
                multiply: function(t) {
                    return this.x *= t.x, this.y *= t.y, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = t.elements;
                    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                },
                clampScalar: (n = new Pe, i = new Pe, function(t, e) {
                    return n.set(t, t), i.set(e, e), this.clamp(n, i)
                }),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var t = Math.atan2(this.y, this.x);
                    return t < 0 && (t += 2 * Math.PI), t
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                },
                rotateAround: function(t, e) {
                    var n = Math.cos(e),
                        i = Math.sin(e),
                        r = this.x - t.x,
                        a = this.y - t.y;
                    return this.x = r * n - a * i + t.x, this.y = r * i + a * n + t.y, this
                }
            }), Object.assign(Ce.prototype, {
                isMatrix4: !0,
                set: function(t, e, n, i, r, a, o, s, c, l, u, h, d, p, f, m) {
                    var v = this.elements;
                    return v[0] = t, v[4] = e, v[8] = n, v[12] = i, v[1] = r, v[5] = a, v[9] = o, v[13] = s, v[2] = c, v[6] = l, v[10] = u, v[14] = h, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new Ce).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                },
                copyPosition: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                },
                extractBasis: function(t, e, n) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: (u = new Oe, function(t) {
                    var e = this.elements,
                        n = t.elements,
                        i = 1 / u.setFromMatrixColumn(t, 0).length(),
                        r = 1 / u.setFromMatrixColumn(t, 1).length(),
                        a = 1 / u.setFromMatrixColumn(t, 2).length();
                    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, this
                }),
                makeRotationFromEuler: function(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z,
                        a = Math.cos(n),
                        o = Math.sin(n),
                        s = Math.cos(i),
                        c = Math.sin(i),
                        l = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === t.order) {
                        var h = a * l,
                            d = a * u,
                            p = o * l,
                            f = o * u;
                        e[0] = s * l, e[4] = -s * u, e[8] = c, e[1] = d + p * c, e[5] = h - f * c, e[9] = -o * s, e[2] = f - h * c, e[6] = p + d * c, e[10] = a * s
                    } else if ("YXZ" === t.order) {
                        var m = s * l,
                            v = s * u,
                            g = c * l,
                            y = c * u;
                        e[0] = m + y * o, e[4] = g * o - v, e[8] = a * c, e[1] = a * u, e[5] = a * l, e[9] = -o, e[2] = v * o - g, e[6] = y + m * o, e[10] = a * s
                    } else if ("ZXY" === t.order) {
                        m = s * l, v = s * u, g = c * l, y = c * u;
                        e[0] = m - y * o, e[4] = -a * u, e[8] = g + v * o, e[1] = v + g * o, e[5] = a * l, e[9] = y - m * o, e[2] = -a * c, e[6] = o, e[10] = a * s
                    } else if ("ZYX" === t.order) {
                        h = a * l, d = a * u, p = o * l, f = o * u;
                        e[0] = s * l, e[4] = p * c - d, e[8] = h * c + f, e[1] = s * u, e[5] = f * c + h, e[9] = d * c - p, e[2] = -c, e[6] = o * s, e[10] = a * s
                    } else if ("YZX" === t.order) {
                        var x = a * s,
                            b = a * c,
                            w = o * s,
                            _ = o * c;
                        e[0] = s * l, e[4] = _ - x * u, e[8] = w * u + b, e[1] = u, e[5] = a * l, e[9] = -o * l, e[2] = -c * l, e[6] = b * u + w, e[10] = x - _ * u
                    } else if ("XZY" === t.order) {
                        x = a * s, b = a * c, w = o * s, _ = o * c;
                        e[0] = s * l, e[4] = -u, e[8] = c * l, e[1] = x * u + _, e[5] = a * l, e[9] = b * u - w, e[2] = w * u - b, e[6] = o * l, e[10] = _ * u + x
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                makeRotationFromQuaternion: function(t) {
                    var e = this.elements,
                        n = t._x,
                        i = t._y,
                        r = t._z,
                        a = t._w,
                        o = n + n,
                        s = i + i,
                        c = r + r,
                        l = n * o,
                        u = n * s,
                        h = n * c,
                        d = i * s,
                        p = i * c,
                        f = r * c,
                        m = a * o,
                        v = a * s,
                        g = a * c;
                    return e[0] = 1 - (d + f), e[4] = u - g, e[8] = h + v, e[1] = u + g, e[5] = 1 - (l + f), e[9] = p - m, e[2] = h - v, e[6] = p + m, e[10] = 1 - (l + d), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                lookAt: (s = new Oe, c = new Oe, l = new Oe, function(t, e, n) {
                    var i = this.elements;
                    return l.subVectors(t, e), 0 === l.lengthSq() && (l.z = 1), l.normalize(), s.crossVectors(n, l), 0 === s.lengthSq() && (1 === Math.abs(n.z) ? l.x += 1e-4 : l.z += 1e-4, l.normalize(), s.crossVectors(n, l)), s.normalize(), c.crossVectors(l, s), i[0] = s.x, i[4] = c.x, i[8] = l.x, i[1] = s.y, i[5] = c.y, i[9] = l.y, i[2] = s.z, i[6] = c.z, i[10] = l.z, this
                }),
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[4],
                        s = n[8],
                        c = n[12],
                        l = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        w = i[0],
                        _ = i[4],
                        M = i[8],
                        E = i[12],
                        T = i[1],
                        S = i[5],
                        A = i[9],
                        L = i[13],
                        P = i[2],
                        C = i[6],
                        R = i[10],
                        O = i[14],
                        I = i[3],
                        N = i[7],
                        D = i[11],
                        U = i[15];
                    return r[0] = a * w + o * T + s * P + c * I, r[4] = a * _ + o * S + s * C + c * N, r[8] = a * M + o * A + s * R + c * D, r[12] = a * E + o * L + s * O + c * U, r[1] = l * w + u * T + h * P + d * I, r[5] = l * _ + u * S + h * C + d * N, r[9] = l * M + u * A + h * R + d * D, r[13] = l * E + u * L + h * O + d * U, r[2] = p * w + f * T + m * P + v * I, r[6] = p * _ + f * S + m * C + v * N, r[10] = p * M + f * A + m * R + v * D, r[14] = p * E + f * L + m * O + v * U, r[3] = g * w + y * T + x * P + b * I, r[7] = g * _ + y * S + x * C + b * N, r[11] = g * M + y * A + x * R + b * D, r[15] = g * E + y * L + x * O + b * U, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                },
                applyToBufferAttribute: (o = new Oe, function(t) {
                    for (var e = 0, n = t.count; e < n; e++) o.x = t.getX(e), o.y = t.getY(e), o.z = t.getZ(e), o.applyMatrix4(this), t.setXYZ(e, o.x, o.y, o.z);
                    return t
                }),
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[4],
                        i = t[8],
                        r = t[12],
                        a = t[1],
                        o = t[5],
                        s = t[9],
                        c = t[13],
                        l = t[2],
                        u = t[6],
                        h = t[10],
                        d = t[14];
                    return t[3] * (+r * s * u - i * c * u - r * o * h + n * c * h + i * o * d - n * s * d) + t[7] * (+e * s * d - e * c * h + r * a * h - i * a * d + i * c * l - r * s * l) + t[11] * (+e * c * u - e * o * d - r * a * u + n * a * d + r * o * l - n * c * l) + t[15] * (-i * o * l - e * s * u + e * o * h + i * a * u - n * a * h + n * s * l)
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                },
                setPosition: function(t) {
                    var e = this.elements;
                    return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
                },
                getInverse: function(t, e) {
                    var n = this.elements,
                        i = t.elements,
                        r = i[0],
                        a = i[1],
                        o = i[2],
                        s = i[3],
                        c = i[4],
                        l = i[5],
                        u = i[6],
                        h = i[7],
                        d = i[8],
                        p = i[9],
                        f = i[10],
                        m = i[11],
                        v = i[12],
                        g = i[13],
                        y = i[14],
                        x = i[15],
                        b = p * y * h - g * f * h + g * u * m - l * y * m - p * u * x + l * f * x,
                        w = v * f * h - d * y * h - v * u * m + c * y * m + d * u * x - c * f * x,
                        _ = d * g * h - v * p * h + v * l * m - c * g * m - d * l * x + c * p * x,
                        M = v * p * u - d * g * u - v * l * f + c * g * f + d * l * y - c * p * y,
                        E = r * b + a * w + o * _ + s * M;
                    if (0 === E) {
                        var T = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(T);
                        return console.warn(T), this.identity()
                    }
                    var S = 1 / E;
                    return n[0] = b * S, n[1] = (g * f * s - p * y * s - g * o * m + a * y * m + p * o * x - a * f * x) * S, n[2] = (l * y * s - g * u * s + g * o * h - a * y * h - l * o * x + a * u * x) * S, n[3] = (p * u * s - l * f * s - p * o * h + a * f * h + l * o * m - a * u * m) * S, n[4] = w * S, n[5] = (d * y * s - v * f * s + v * o * m - r * y * m - d * o * x + r * f * x) * S, n[6] = (v * u * s - c * y * s - v * o * h + r * y * h + c * o * x - r * u * x) * S, n[7] = (c * f * s - d * u * s + d * o * h - r * f * h - c * o * m + r * u * m) * S, n[8] = _ * S, n[9] = (v * p * s - d * g * s - v * a * m + r * g * m + d * a * x - r * p * x) * S, n[10] = (c * g * s - v * l * s + v * a * h - r * g * h - c * a * x + r * l * x) * S, n[11] = (d * l * s - c * p * s - d * a * h + r * p * h + c * a * m - r * l * m) * S, n[12] = M * S, n[13] = (d * g * o - v * p * o + v * a * f - r * g * f - d * a * y + r * p * y) * S, n[14] = (v * l * o - c * g * o - v * a * u + r * g * u + c * a * y - r * l * y) * S, n[15] = (c * p * o - d * l * o + d * a * u - r * p * u - c * a * f + r * l * f) * S, this
                },
                scale: function(t) {
                    var e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z;
                    return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                },
                getMaxScaleOnAxis: function() {
                    var t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, i))
                },
                makeTranslation: function(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(t, e) {
                    var n = Math.cos(e),
                        i = Math.sin(e),
                        r = 1 - n,
                        a = t.x,
                        o = t.y,
                        s = t.z,
                        c = r * a,
                        l = r * o;
                    return this.set(c * a + n, c * o - i * s, c * s + i * o, 0, c * o + i * s, l * o + n, l * s - i * a, 0, c * s - i * o, l * s + i * a, r * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function(t, e, n) {
                    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(t, e, n) {
                    return this.makeRotationFromQuaternion(e), this.scale(n), this.setPosition(t), this
                },
                decompose: (r = new Oe, a = new Ce, function(t, e, n) {
                    var i = this.elements,
                        o = r.set(i[0], i[1], i[2]).length(),
                        s = r.set(i[4], i[5], i[6]).length(),
                        c = r.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (o = -o), t.x = i[12], t.y = i[13], t.z = i[14], a.copy(this);
                    var l = 1 / o,
                        u = 1 / s,
                        h = 1 / c;
                    return a.elements[0] *= l, a.elements[1] *= l, a.elements[2] *= l, a.elements[4] *= u, a.elements[5] *= u, a.elements[6] *= u, a.elements[8] *= h, a.elements[9] *= h, a.elements[10] *= h, e.setFromRotationMatrix(a), n.x = o, n.y = s, n.z = c, this
                }),
                makePerspective: function(t, e, n, i, r, a) {
                    void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var o = this.elements,
                        s = 2 * r / (e - t),
                        c = 2 * r / (n - i),
                        l = (e + t) / (e - t),
                        u = (n + i) / (n - i),
                        h = -(a + r) / (a - r),
                        d = -2 * a * r / (a - r);
                    return o[0] = s, o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                },
                makeOrthographic: function(t, e, n, i, r, a) {
                    var o = this.elements,
                        s = 1 / (e - t),
                        c = 1 / (n - i),
                        l = 1 / (a - r),
                        u = (e + t) * s,
                        h = (n + i) * c,
                        d = (a + r) * l;
                    return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                }
            }), Object.assign(Re, {
                slerp: function(t, e, n, i) {
                    return n.copy(t).slerp(e, i)
                },
                slerpFlat: function(t, e, n, i, r, a, o) {
                    var s = n[i + 0],
                        c = n[i + 1],
                        l = n[i + 2],
                        u = n[i + 3],
                        h = r[a + 0],
                        d = r[a + 1],
                        p = r[a + 2],
                        f = r[a + 3];
                    if (u !== f || s !== h || c !== d || l !== p) {
                        var m = 1 - o,
                            v = s * h + c * d + l * p + u * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var x = Math.sqrt(y),
                                b = Math.atan2(x, v * g);
                            m = Math.sin(m * b) / x, o = Math.sin(o * b) / x
                        }
                        var w = o * g;
                        if (s = s * m + h * w, c = c * m + d * w, l = l * m + p * w, u = u * m + f * w, m === 1 - o) {
                            var _ = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                            s *= _, c *= _, l *= _, u *= _
                        }
                    }
                    t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u
                }
            }), Object.defineProperties(Re.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(t) {
                        this._w = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(Re.prototype, {
                set: function(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._w = i, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
                },
                setFromEuler: function(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = t._x,
                        i = t._y,
                        r = t._z,
                        a = t.order,
                        o = Math.cos,
                        s = Math.sin,
                        c = o(n / 2),
                        l = o(i / 2),
                        u = o(r / 2),
                        h = s(n / 2),
                        d = s(i / 2),
                        p = s(r / 2);
                    return "XYZ" === a ? (this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p) : "YXZ" === a ? (this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p) : "ZXY" === a ? (this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p) : "ZYX" === a ? (this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p) : "YZX" === a ? (this._x = h * l * u + c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u - h * d * p) : "XZY" === a && (this._x = h * l * u - c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u + h * d * p), !1 !== e && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(t, e) {
                    var n = e / 2,
                        i = Math.sin(n);
                    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t) {
                    var e, n = t.elements,
                        i = n[0],
                        r = n[4],
                        a = n[8],
                        o = n[1],
                        s = n[5],
                        c = n[9],
                        l = n[2],
                        u = n[6],
                        h = n[10],
                        d = i + s + h;
                    return d > 0 ? (e = .5 / Math.sqrt(d + 1), this._w = .25 / e, this._x = (u - c) * e, this._y = (a - l) * e, this._z = (o - r) * e) : i > s && i > h ? (e = 2 * Math.sqrt(1 + i - s - h), this._w = (u - c) / e, this._x = .25 * e, this._y = (r + o) / e, this._z = (a + l) / e) : s > h ? (e = 2 * Math.sqrt(1 + s - i - h), this._w = (a - l) / e, this._x = (r + o) / e, this._y = .25 * e, this._z = (c + u) / e) : (e = 2 * Math.sqrt(1 + h - i - s), this._w = (o - r) / e, this._x = (a + l) / e, this._y = (c + u) / e, this._z = .25 * e), this.onChangeCallback(), this
                },
                setFromUnitVectors: (d = new Oe, function(t, e) {
                    return void 0 === d && (d = new Oe), (h = t.dot(e) + 1) < 1e-6 ? (h = 0, Math.abs(t.x) > Math.abs(t.z) ? d.set(-t.y, t.x, 0) : d.set(0, -t.z, t.y)) : d.crossVectors(t, e), this._x = d.x, this._y = d.y, this._z = d.z, this._w = h, this.normalize()
                }),
                inverse: function() {
                    return this.conjugate().normalize()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyQuaternions(t, this)
                },
                multiplyQuaternions: function(t, e) {
                    var n = t._x,
                        i = t._y,
                        r = t._z,
                        a = t._w,
                        o = e._x,
                        s = e._y,
                        c = e._z,
                        l = e._w;
                    return this._x = n * l + a * o + i * c - r * s, this._y = i * l + a * s + r * o - n * c, this._z = r * l + a * c + n * s - i * o, this._w = a * l - n * o - i * s - r * c, this.onChangeCallback(), this
                },
                slerp: function(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    var n = this._x,
                        i = this._y,
                        r = this._z,
                        a = this._w,
                        o = a * t._w + n * t._x + i * t._y + r * t._z;
                    if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
                    var s = Math.sqrt(1 - o * o);
                    if (Math.abs(s) < .001) return this._w = .5 * (a + this._w), this._x = .5 * (n + this._x), this._y = .5 * (i + this._y), this._z = .5 * (r + this._z), this;
                    var c = Math.atan2(s, o),
                        l = Math.sin((1 - e) * c) / s,
                        u = Math.sin(e * c) / s;
                    return this._w = a * l + this._w * u, this._x = n * l + this._x * u, this._y = i * l + this._y * u, this._z = r * l + this._z * u, this.onChangeCallback(), this
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(Oe.prototype, {
                isVector3: !0,
                set: function(t, e, n) {
                    return this.x = t, this.y = e, this.z = n, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                },
                multiplyVectors: function(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                },
                applyEuler: (b = new Re, function(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(b.setFromEuler(t))
                }),
                applyAxisAngle: (x = new Re, function(t, e) {
                    return this.applyQuaternion(x.setFromAxisAngle(t, e))
                }),
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements,
                        a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a, this
                },
                applyQuaternion: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.x,
                        a = t.y,
                        o = t.z,
                        s = t.w,
                        c = s * e + a * i - o * n,
                        l = s * n + o * e - r * i,
                        u = s * i + r * n - a * e,
                        h = -r * e - a * n - o * i;
                    return this.x = c * s + h * -r + l * -o - u * -a, this.y = l * s + h * -a + u * -r - c * -o, this.z = u * s + h * -o + c * -a - l * -r, this
                },
                project: (y = new Ce, function(t) {
                    return y.multiplyMatrices(t.projectionMatrix, y.getInverse(t.matrixWorld)), this.applyMatrix4(y)
                }),
                unproject: (g = new Ce, function(t) {
                    return g.multiplyMatrices(t.matrixWorld, g.getInverse(t.projectionMatrix)), this.applyMatrix4(g)
                }),
                transformDirection: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                },
                clampScalar: (m = new Oe, v = new Oe, function(t, e) {
                    return m.set(t, t, t), v.set(e, e, e), this.clamp(m, v)
                }),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                cross: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                },
                crossVectors: function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        a = e.x,
                        o = e.y,
                        s = e.z;
                    return this.x = i * s - r * o, this.y = r * a - n * s, this.z = n * o - i * a, this
                },
                projectOnVector: function(t) {
                    var e = t.dot(this) / t.lengthSq();
                    return this.copy(t).multiplyScalar(e)
                },
                projectOnPlane: (f = new Oe, function(t) {
                    return f.copy(this).projectOnVector(t), this.sub(f)
                }),
                reflect: (p = new Oe, function(t) {
                    return this.sub(p.copy(t).multiplyScalar(2 * this.dot(t)))
                }),
                angleTo: function(t) {
                    var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                    return Math.acos(Le.clamp(e, -1, 1))
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y,
                        i = this.z - t.z;
                    return e * e + n * n + i * i
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                },
                setFromSpherical: function(t) {
                    var e = Math.sin(t.phi) * t.radius;
                    return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this
                },
                setFromCylindrical: function(t) {
                    return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this
                },
                setFromMatrixPosition: function(t) {
                    var e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                },
                setFromMatrixScale: function(t) {
                    var e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        i = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = n, this.z = i, this
                },
                setFromMatrixColumn: function(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
            }), Object.assign(Ie.prototype, {
                isMatrix3: !0,
                set: function(t, e, n, i, r, a, o, s, c) {
                    var l = this.elements;
                    return l[0] = t, l[1] = i, l[2] = o, l[3] = e, l[4] = r, l[5] = s, l[6] = n, l[7] = a, l[8] = c, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                },
                setFromMatrix4: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                },
                applyToBufferAttribute: (w = new Oe, function(t) {
                    for (var e = 0, n = t.count; e < n; e++) w.x = t.getX(e), w.y = t.getY(e), w.z = t.getZ(e), w.applyMatrix3(this), t.setXYZ(e, w.x, w.y, w.z);
                    return t
                }),
                multiply: function(t) {
                    return this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[3],
                        s = n[6],
                        c = n[1],
                        l = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = i[0],
                        m = i[3],
                        v = i[6],
                        g = i[1],
                        y = i[4],
                        x = i[7],
                        b = i[2],
                        w = i[5],
                        _ = i[8];
                    return r[0] = a * f + o * g + s * b, r[3] = a * m + o * y + s * w, r[6] = a * v + o * x + s * _, r[1] = c * f + l * g + u * b, r[4] = c * m + l * y + u * w, r[7] = c * v + l * x + u * _, r[2] = h * f + d * g + p * b, r[5] = h * m + d * y + p * w, r[8] = h * v + d * x + p * _, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                },
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        a = t[4],
                        o = t[5],
                        s = t[6],
                        c = t[7],
                        l = t[8];
                    return e * a * l - e * o * c - n * r * l + n * o * s + i * r * c - i * a * s
                },
                getInverse: function(t, e) {
                    t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = t.elements,
                        i = this.elements,
                        r = n[0],
                        a = n[1],
                        o = n[2],
                        s = n[3],
                        c = n[4],
                        l = n[5],
                        u = n[6],
                        h = n[7],
                        d = n[8],
                        p = d * c - l * h,
                        f = l * u - d * s,
                        m = h * s - c * u,
                        v = r * p + a * f + o * m;
                    if (0 === v) {
                        var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(g);
                        return console.warn(g), this.identity()
                    }
                    var y = 1 / v;
                    return i[0] = p * y, i[1] = (o * h - d * a) * y, i[2] = (l * a - o * c) * y, i[3] = f * y, i[4] = (d * r - o * u) * y, i[5] = (o * s - l * r) * y, i[6] = m * y, i[7] = (a * u - h * r) * y, i[8] = (c * r - a * s) * y, this
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                },
                getNormalMatrix: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                },
                transposeIntoArray: function(t) {
                    var e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                },
                setUvTransform: function(t, e, n, i, r, a, o) {
                    var s = Math.cos(r),
                        c = Math.sin(r);
                    this.set(n * s, n * c, -n * (s * a + c * o) + a + t, -i * c, i * s, -i * (-c * a + s * o) + o + e, 0, 0, 1)
                },
                scale: function(t, e) {
                    var n = this.elements;
                    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t),
                        i = this.elements,
                        r = i[0],
                        a = i[3],
                        o = i[6],
                        s = i[1],
                        c = i[4],
                        l = i[7];
                    return i[0] = e * r + n * s, i[3] = e * a + n * c, i[6] = e * o + n * l, i[1] = -n * r + e * s, i[4] = -n * a + e * c, i[7] = -n * o + e * l, this
                },
                translate: function(t, e) {
                    var n = this.elements;
                    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                }
            });
            var Ne, De, Ue = 0;
  
            function ke(t, e, n, i, r, a, o, s, c, l) {
                Object.defineProperty(this, "id", {
                    value: Ue++
                }), this.uuid = Le.generateUUID(), this.name = "", this.image = void 0 !== t ? t : ke.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : ke.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : At, this.wrapT = void 0 !== i ? i : At, this.magFilter = void 0 !== r ? r : Ot, this.minFilter = void 0 !== a ? a : Nt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== o ? o : $t, this.type = void 0 !== s ? s : Dt, this.offset = new Pe(0, 0), this.repeat = new Pe(1, 1), this.center = new Pe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ie, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : xe, this.version = 0, this.onUpdate = null
            }
  
            function Fe(t, e, n, i) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
            }
  
            function ze(t, e, n) {
                this.uuid = Le.generateUUID(), this.width = t, this.height = e, this.scissor = new Fe(0, 0, t, e), this.scissorTest = !1, this.viewport = new Fe(0, 0, t, e), void 0 === (n = n || {}).minFilter && (n.minFilter = Ot), this.texture = new ke(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }
  
            function Be(t, e, n) {
                ze.call(this, t, e, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0
            }
  
            function je(t, e, n, i, r, a, o, s, c, l, u, h) {
                ke.call(this, null, a, o, s, c, l, i, r, u, h), this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.magFilter = void 0 !== c ? c : Pt, this.minFilter = void 0 !== l ? l : Pt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
  
            function Ge(t, e, n, i, r, a, o, s, c, l) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : xt, ke.call(this, t, e, n, i, r, a, o, s, c, l), this.flipY = !1
            }
            ke.DEFAULT_IMAGE = void 0, ke.DEFAULT_MAPPING = 300, ke.prototype = Object.assign(Object.create(e.prototype), {
                constructor: ke,
                isTexture: !0,
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (void 0 !== this.image) {
                        var i = this.image;
                        void 0 === i.uuid && (i.uuid = Le.generateUUID()), e || void 0 !== t.images[i.uuid] || (t.images[i.uuid] = {
                            uuid: i.uuid,
                            url: function(t) {
                                var e;
                                if (t instanceof HTMLCanvasElement) e = t;
                                else {
                                    (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = t.width, e.height = t.height;
                                    var n = e.getContext("2d");
                                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height)
                                }
                                return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                            }(i)
                        }), n.image = i.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (300 === this.mapping) {
                        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                            case St:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case At:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case Lt:
                                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                        }
                        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                            case St:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case At:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case Lt:
                                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                        }
                        this.flipY && (t.y = 1 - t.y)
                    }
                }
            }), Object.defineProperty(ke.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Fe.prototype, {
                isVector4: !0,
                set: function(t, e, n, i) {
                    return this.x = t, this.y = e, this.z = n, this.w = i, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setW: function(t) {
                    return this.w = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        a = t.elements;
                    return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                setAxisAngleFromQuaternion: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                },
                setAxisAngleFromRotationMatrix: function(t) {
                    var e, n, i, r, a = t.elements,
                        o = a[0],
                        s = a[4],
                        c = a[8],
                        l = a[1],
                        u = a[5],
                        h = a[9],
                        d = a[2],
                        p = a[6],
                        f = a[10];
                    if (Math.abs(s - l) < .01 && Math.abs(c - d) < .01 && Math.abs(h - p) < .01) {
                        if (Math.abs(s + l) < .1 && Math.abs(c + d) < .1 && Math.abs(h + p) < .1 && Math.abs(o + u + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        var m = (o + 1) / 2,
                            v = (u + 1) / 2,
                            g = (f + 1) / 2,
                            y = (s + l) / 4,
                            x = (c + d) / 4,
                            b = (h + p) / 4;
                        return m > v && m > g ? m < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = y / (n = Math.sqrt(m)), r = x / n) : v > g ? v < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = y / (i = Math.sqrt(v)), r = b / i) : g < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = x / (r = Math.sqrt(g)), i = b / r), this.set(n, i, r, e), this
                    }
                    var w = Math.sqrt((p - h) * (p - h) + (c - d) * (c - d) + (l - s) * (l - s));
                    return Math.abs(w) < .001 && (w = 1), this.x = (p - h) / w, this.y = (c - d) / w, this.z = (l - s) / w, this.w = Math.acos((o + u + f - 1) / 2), this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                },
                clampScalar: function(t, e) {
                    return void 0 === Ne && (Ne = new Fe, De = new Fe), Ne.set(t, t, t, t), De.set(e, e, e, e), this.clamp(Ne, De)
                },
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
            }), ze.prototype = Object.assign(Object.create(e.prototype), {
                constructor: ze,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Be.prototype = Object.create(ze.prototype), Be.prototype.constructor = Be, Be.prototype.isWebGLRenderTargetCube = !0, je.prototype = Object.create(ke.prototype), je.prototype.constructor = je, je.prototype.isDataTexture = !0, Ge.prototype = Object.create(ke.prototype), Ge.prototype.constructor = Ge, Ge.prototype.isCubeTexture = !0, Object.defineProperty(Ge.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            });
            var He = new ke,
                Ve = new Ge;
  
            function We() {
                this.seq = [], this.map = {}
            }
            var Xe = [],
                qe = [],
                Ye = new Float32Array(16),
                $e = new Float32Array(9);
  
            function Ze(t, e, n) {
                var i = t[0];
                if (i <= 0 || i > 0) return t;
                var r = e * n,
                    a = Xe[r];
                if (void 0 === a && (a = new Float32Array(r), Xe[r] = a), 0 !== e) {
                    i.toArray(a, 0);
                    for (var o = 1, s = 0; o !== e; ++o) s += n, t[o].toArray(a, s)
                }
                return a
            }
  
            function Je(t, e) {
                var n = qe[e];
                void 0 === n && (n = new Int32Array(e), qe[e] = n);
                for (var i = 0; i !== e; ++i) n[i] = t.allocTextureUnit();
                return n
            }
  
            function Ke(t, e) {
                t.uniform1f(this.addr, e)
            }
  
            function Qe(t, e) {
                t.uniform1i(this.addr, e)
            }
  
            function tn(t, e) {
                void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
            }
  
            function en(t, e) {
                void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
            }
  
            function nn(t, e) {
                void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
            }
  
            function rn(t, e) {
                t.uniformMatrix2fv(this.addr, !1, e.elements || e)
            }
  
            function an(t, e) {
                void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : ($e.set(e.elements), t.uniformMatrix3fv(this.addr, !1, $e))
            }
  
            function on(t, e) {
                void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (Ye.set(e.elements), t.uniformMatrix4fv(this.addr, !1, Ye))
            }
  
            function sn(t, e, n) {
                var i = n.allocTextureUnit();
                t.uniform1i(this.addr, i), n.setTexture2D(e || He, i)
            }
  
            function cn(t, e, n) {
                var i = n.allocTextureUnit();
                t.uniform1i(this.addr, i), n.setTextureCube(e || Ve, i)
            }
  
            function ln(t, e) {
                t.uniform2iv(this.addr, e)
            }
  
            function un(t, e) {
                t.uniform3iv(this.addr, e)
            }
  
            function hn(t, e) {
                t.uniform4iv(this.addr, e)
            }
  
            function dn(t, e) {
                t.uniform1fv(this.addr, e)
            }
  
            function pn(t, e) {
                t.uniform1iv(this.addr, e)
            }
  
            function fn(t, e) {
                t.uniform2fv(this.addr, Ze(e, this.size, 2))
            }
  
            function mn(t, e) {
                t.uniform3fv(this.addr, Ze(e, this.size, 3))
            }
  
            function vn(t, e) {
                t.uniform4fv(this.addr, Ze(e, this.size, 4))
            }
  
            function gn(t, e) {
                t.uniformMatrix2fv(this.addr, !1, Ze(e, this.size, 4))
            }
  
            function yn(t, e) {
                t.uniformMatrix3fv(this.addr, !1, Ze(e, this.size, 9))
            }
  
            function xn(t, e) {
                t.uniformMatrix4fv(this.addr, !1, Ze(e, this.size, 16))
            }
  
            function bn(t, e, n) {
                var i = e.length,
                    r = Je(n, i);
                t.uniform1iv(this.addr, r);
                for (var a = 0; a !== i; ++a) n.setTexture2D(e[a] || He, r[a])
            }
  
            function wn(t, e, n) {
                var i = e.length,
                    r = Je(n, i);
                t.uniform1iv(this.addr, r);
                for (var a = 0; a !== i; ++a) n.setTextureCube(e[a] || Ve, r[a])
            }
  
            function _n(t, e, n) {
                this.id = t, this.addr = n, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Ke;
                        case 35664:
                            return tn;
                        case 35665:
                            return en;
                        case 35666:
                            return nn;
                        case 35674:
                            return rn;
                        case 35675:
                            return an;
                        case 35676:
                            return on;
                        case 35678:
                        case 36198:
                            return sn;
                        case 35680:
                            return cn;
                        case 5124:
                        case 35670:
                            return Qe;
                        case 35667:
                        case 35671:
                            return ln;
                        case 35668:
                        case 35672:
                            return un;
                        case 35669:
                        case 35673:
                            return hn
                    }
                }(e.type)
            }
  
            function Mn(t, e, n) {
                this.id = t, this.addr = n, this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return dn;
                        case 35664:
                            return fn;
                        case 35665:
                            return mn;
                        case 35666:
                            return vn;
                        case 35674:
                            return gn;
                        case 35675:
                            return yn;
                        case 35676:
                            return xn;
                        case 35678:
                            return bn;
                        case 35680:
                            return wn;
                        case 5124:
                        case 35670:
                            return pn;
                        case 35667:
                        case 35671:
                            return ln;
                        case 35668:
                        case 35672:
                            return un;
                        case 35669:
                        case 35673:
                            return hn
                    }
                }(e.type)
            }
  
            function En(t) {
                this.id = t, We.call(this)
            }
            En.prototype.setValue = function(t, e) {
                for (var n = this.seq, i = 0, r = n.length; i !== r; ++i) {
                    var a = n[i];
                    a.setValue(t, e[a.id])
                }
            };
            var Tn = /([\w\d_]+)(\])?(\[|\.)?/g;
  
            function Sn(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }
  
            function An(t, e, n) {
                var i = t.name,
                    r = i.length;
                for (Tn.lastIndex = 0;;) {
                    var a = Tn.exec(i),
                        o = Tn.lastIndex,
                        s = a[1],
                        c = "]" === a[2],
                        l = a[3];
                    if (c && (s |= 0), void 0 === l || "[" === l && o + 2 === r) {
                        Sn(n, void 0 === l ? new _n(s, t, e) : new Mn(s, t, e));
                        break
                    }
                    var u = n.map[s];
                    void 0 === u && Sn(n, u = new En(s)), n = u
                }
            }
  
            function Ln(t, e, n) {
                We.call(this), this.renderer = n;
                for (var i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r < i; ++r) {
                    var a = t.getActiveUniform(e, r),
                        o = a.name;
                    An(a, t.getUniformLocation(e, o), this)
                }
            }
            Ln.prototype.setValue = function(t, e, n) {
                var i = this.map[e];
                void 0 !== i && i.setValue(t, n, this.renderer)
            }, Ln.prototype.setOptional = function(t, e, n) {
                var i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }, Ln.upload = function(t, e, n, i) {
                for (var r = 0, a = e.length; r !== a; ++r) {
                    var o = e[r],
                        s = n[o.id];
                    !1 !== s.needsUpdate && o.setValue(t, s.value, i)
                }
            }, Ln.seqWithValue = function(t, e) {
                for (var n = [], i = 0, r = t.length; i !== r; ++i) {
                    var a = t[i];
                    a.id in e && n.push(a)
                }
                return n
            };
            var Pn = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            };
  
            function Cn(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            Object.assign(Cn.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                },
                setScalar: function(t) {
                    return this.r = t, this.g = t, this.b = t, this
                },
                setHex: function(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                },
                setRGB: function(t, e, n) {
                    return this.r = t, this.g = e, this.b = n, this
                },
                setHSL: function() {
                    function t(t, e, n) {
                        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                    }
                    return function(e, n, i) {
                        if (e = Le.euclideanModulo(e, 1), n = Le.clamp(n, 0, 1), i = Le.clamp(i, 0, 1), 0 === n) this.r = this.g = this.b = i;
                        else {
                            var r = i <= .5 ? i * (1 + n) : i + n - i * n,
                                a = 2 * i - r;
                            this.r = t(a, r, e + 1 / 3), this.g = t(a, r, e), this.b = t(a, r, e - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var i, r = n[1],
                            a = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                                if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                    var o = parseFloat(i[1]) / 360,
                                        s = parseInt(i[2], 10) / 100,
                                        c = parseInt(i[3], 10) / 100;
                                    return e(i[5]), this.setHSL(o, s, c)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var l, u = (l = n[1]).length;
                        if (3 === u) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                        if (6 === u) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
                    }
                    t && t.length > 0 && (void 0 !== (l = Pn[t]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t));
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                },
                copyGammaToLinear: function(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                },
                copyLinearToGamma: function(t, e) {
                    void 0 === e && (e = 2);
                    var n = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                },
                convertGammaToLinear: function() {
                    var t = this.r,
                        e = this.g,
                        n = this.b;
                    return this.r = t * t, this.g = e * e, this.b = n * n, this
                },
                convertLinearToGamma: function() {
                    return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(t) {
                    var e, n, i = t || {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        r = this.r,
                        a = this.g,
                        o = this.b,
                        s = Math.max(r, a, o),
                        c = Math.min(r, a, o),
                        l = (c + s) / 2;
                    if (c === s) e = 0, n = 0;
                    else {
                        var u = s - c;
                        switch (n = l <= .5 ? u / (s + c) : u / (2 - s - c), s) {
                            case r:
                                e = (a - o) / u + (a < o ? 6 : 0);
                                break;
                            case a:
                                e = (o - r) / u + 2;
                                break;
                            case o:
                                e = (r - a) / u + 4
                        }
                        e /= 6
                    }
                    return i.h = e, i.s = n, i.l = l, i
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function(t, e, n) {
                    var i = this.getHSL();
                    return i.h += t, i.s += e, i.l += n, this.setHSL(i.h, i.s, i.l), this
                },
                add: function(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                },
                addColors: function(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                },
                addScalar: function(t) {
                    return this.r += t, this.g += t, this.b += t, this
                },
                sub: function(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                },
                multiply: function(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                },
                multiplyScalar: function(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                },
                lerp: function(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                },
                equals: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                },
                toJSON: function() {
                    return this.getHex()
                }
            });
            var Rn, On, In = {
                    common: {
                        diffuse: {
                            value: new Cn(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Ie
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Pe(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new Cn(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Cn(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Ie
                        }
                    }
                },
                Nn = {
                    merge: function(t) {
                        for (var e = {}, n = 0; n < t.length; n++) {
                            var i = this.clone(t[n]);
                            for (var r in i) e[r] = i[r]
                        }
                        return e
                    },
                    clone: function(t) {
                        var e = {};
                        for (var n in t)
                            for (var i in e[n] = {}, t[n]) {
                                var r = t[n][i];
                                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                            }
                        return e
                    }
                },
                Dn = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "\nvec3 transformed = vec3( position );\n",
                    beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                    bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                    color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                    common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                    defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                    encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                    envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                    fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                    gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                    lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                    lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                    map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                    map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                    normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                    project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
                    dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                    dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                    tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                    uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
                    uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                    cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                    equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                    meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
                    shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
                },
                Un = {
                    basic: {
                        uniforms: Nn.merge([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.fog]),
                        vertexShader: Dn.meshbasic_vert,
                        fragmentShader: Dn.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Nn.merge([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.fog, In.lights, {
                            emissive: {
                                value: new Cn(0)
                            }
                        }]),
                        vertexShader: Dn.meshlambert_vert,
                        fragmentShader: Dn.meshlambert_frag
                    },
                    phong: {
                        uniforms: Nn.merge([In.common, In.specularmap, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.bumpmap, In.normalmap, In.displacementmap, In.gradientmap, In.fog, In.lights, {
                            emissive: {
                                value: new Cn(0)
                            },
                            specular: {
                                value: new Cn(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Dn.meshphong_vert,
                        fragmentShader: Dn.meshphong_frag
                    },
                    standard: {
                        uniforms: Nn.merge([In.common, In.envmap, In.aomap, In.lightmap, In.emissivemap, In.bumpmap, In.normalmap, In.displacementmap, In.roughnessmap, In.metalnessmap, In.fog, In.lights, {
                            emissive: {
                                value: new Cn(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Dn.meshphysical_vert,
                        fragmentShader: Dn.meshphysical_frag
                    },
                    points: {
                        uniforms: Nn.merge([In.points, In.fog]),
                        vertexShader: Dn.points_vert,
                        fragmentShader: Dn.points_frag
                    },
                    dashed: {
                        uniforms: Nn.merge([In.common, In.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Dn.linedashed_vert,
                        fragmentShader: Dn.linedashed_frag
                    },
                    depth: {
                        uniforms: Nn.merge([In.common, In.displacementmap]),
                        vertexShader: Dn.depth_vert,
                        fragmentShader: Dn.depth_frag
                    },
                    normal: {
                        uniforms: Nn.merge([In.common, In.bumpmap, In.normalmap, In.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Dn.normal_vert,
                        fragmentShader: Dn.normal_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: Dn.cube_vert,
                        fragmentShader: Dn.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Dn.equirect_vert,
                        fragmentShader: Dn.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Nn.merge([In.common, In.displacementmap, {
                            referencePosition: {
                                value: new Oe
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Dn.distanceRGBA_vert,
                        fragmentShader: Dn.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Nn.merge([In.lights, In.fog, {
                            color: {
                                value: new Cn(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Dn.shadow_vert,
                        fragmentShader: Dn.shadow_frag
                    }
                };
  
            function kn(t, e) {
                this.min = void 0 !== t ? t : new Pe(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Pe(-1 / 0, -1 / 0)
            }
  
            function Fn(t, e, n, i, r) {
                var a, o, s, c, l, u, h, d;
  
                function p() {
                    var t, i, p, f, m, v = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                        g = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    a = e.createBuffer(), o = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, a), e.bufferData(e.ARRAY_BUFFER, v, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, o), e.bufferData(e.ELEMENT_ARRAY_BUFFER, g, e.STATIC_DRAW), h = e.createTexture(), d = e.createTexture(), n.bindTexture(e.TEXTURE_2D, h), e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 16, 16, 0, e.RGB, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), n.bindTexture(e.TEXTURE_2D, d), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 16, 16, 0, e.RGBA, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), s = {
                        vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "\tvUV = uv;", "\tvec2 pos = position;", "\tif ( renderType == 2 ) {", "\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "\t\tvVisibility =        visibility.r / 9.0;", "\t\tvVisibility *= 1.0 - visibility.g / 9.0;", "\t\tvVisibility *=       visibility.b / 9.0;", "\t\tvVisibility *= 1.0 - visibility.a / 9.0;", "\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "\t}", "\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                        fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "\tif ( renderType == 0 ) {", "\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "\t} else if ( renderType == 1 ) {", "\t\tgl_FragColor = texture2D( map, vUV );", "\t} else {", "\t\tvec4 texture = texture2D( map, vUV );", "\t\ttexture.a *= opacity * vVisibility;", "\t\tgl_FragColor = texture;", "\t\tgl_FragColor.rgb *= color;", "\t}", "}"].join("\n")
                    }, t = s, i = e.createProgram(), p = e.createShader(e.FRAGMENT_SHADER), f = e.createShader(e.VERTEX_SHADER), m = "precision " + r.precision + " float;\n", e.shaderSource(p, m + t.fragmentShader), e.shaderSource(f, m + t.vertexShader), e.compileShader(p), e.compileShader(f), e.attachShader(i, p), e.attachShader(i, f), e.linkProgram(i), c = i, l = {
                        vertex: e.getAttribLocation(c, "position"),
                        uv: e.getAttribLocation(c, "uv")
                    }, u = {
                        renderType: e.getUniformLocation(c, "renderType"),
                        map: e.getUniformLocation(c, "map"),
                        occlusionMap: e.getUniformLocation(c, "occlusionMap"),
                        opacity: e.getUniformLocation(c, "opacity"),
                        color: e.getUniformLocation(c, "color"),
                        scale: e.getUniformLocation(c, "scale"),
                        rotation: e.getUniformLocation(c, "rotation"),
                        screenPosition: e.getUniformLocation(c, "screenPosition")
                    }
                }
                this.render = function(t, r, s, f) {
                    if (0 !== t.length) {
                        var m = new Oe,
                            v = f.w / f.z,
                            g = .5 * f.z,
                            y = .5 * f.w,
                            x = 16 / f.w,
                            b = new Pe(x * v, x),
                            w = new Oe(1, 1, 0),
                            _ = new Pe(1, 1),
                            M = new kn;
                        M.min.set(f.x, f.y), M.max.set(f.x + (f.z - 16), f.y + (f.w - 16)), void 0 === c && p(), n.useProgram(c), n.initAttributes(), n.enableAttribute(l.vertex), n.enableAttribute(l.uv), n.disableUnusedAttributes(), e.uniform1i(u.occlusionMap, 0), e.uniform1i(u.map, 1), e.bindBuffer(e.ARRAY_BUFFER, a), e.vertexAttribPointer(l.vertex, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(l.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, o), n.disable(e.CULL_FACE), n.buffers.depth.setMask(!1);
                        for (var E = 0, T = t.length; E < T; E++) {
                            x = 16 / f.w, b.set(x * v, x);
                            var S = t[E];
                            if (m.set(S.matrixWorld.elements[12], S.matrixWorld.elements[13], S.matrixWorld.elements[14]), m.applyMatrix4(s.matrixWorldInverse), m.applyMatrix4(s.projectionMatrix), w.copy(m), _.x = f.x + w.x * g + g - 8, _.y = f.y + w.y * y + y - 8, !0 === M.containsPoint(_)) {
                                n.activeTexture(e.TEXTURE0), n.bindTexture(e.TEXTURE_2D, null), n.activeTexture(e.TEXTURE1), n.bindTexture(e.TEXTURE_2D, h), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGB, _.x, _.y, 16, 16, 0), e.uniform1i(u.renderType, 0), e.uniform2f(u.scale, b.x, b.y), e.uniform3f(u.screenPosition, w.x, w.y, w.z), n.disable(e.BLEND), n.enable(e.DEPTH_TEST), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), n.activeTexture(e.TEXTURE0), n.bindTexture(e.TEXTURE_2D, d), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, _.x, _.y, 16, 16, 0), e.uniform1i(u.renderType, 1), n.disable(e.DEPTH_TEST), n.activeTexture(e.TEXTURE1), n.bindTexture(e.TEXTURE_2D, h), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), S.positionScreen.copy(w), S.customUpdateCallback ? S.customUpdateCallback(S) : S.updateLensFlares(), e.uniform1i(u.renderType, 2), n.enable(e.BLEND);
                                for (var A = 0, L = S.lensFlares.length; A < L; A++) {
                                    var P = S.lensFlares[A];
                                    P.opacity > .001 && P.scale > .001 && (w.x = P.x, w.y = P.y, w.z = P.z, x = P.size * P.scale / f.w, b.x = x * v, b.y = x, e.uniform3f(u.screenPosition, w.x, w.y, w.z), e.uniform2f(u.scale, b.x, b.y), e.uniform1f(u.rotation, P.rotation), e.uniform1f(u.opacity, P.opacity), e.uniform3f(u.color, P.color.r, P.color.g, P.color.b), n.setBlending(P.blending, P.blendEquation, P.blendSrc, P.blendDst), i.setTexture2D(P.texture, 1), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0))
                                }
                            }
                        }
                        n.enable(e.CULL_FACE), n.enable(e.DEPTH_TEST), n.buffers.depth.setMask(!0), n.reset()
                    }
                }
            }
  
            function zn(t, e, n, i, r, a, o, s, c) {
                ke.call(this, t, e, n, i, r, a, o, s, c), this.needsUpdate = !0
            }
  
            function Bn(t, e, n, i, r) {
                var a, o, s, c, l, u, h = new Oe,
                    d = new Re,
                    p = new Oe;
  
                function f() {
                    var t, n, i, h = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        d = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    a = e.createBuffer(), o = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, a), e.bufferData(e.ARRAY_BUFFER, h, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, o), e.bufferData(e.ELEMENT_ARRAY_BUFFER, d, e.STATIC_DRAW), t = e.createProgram(), n = e.createShader(e.VERTEX_SHADER), i = e.createShader(e.FRAGMENT_SHADER), e.shaderSource(n, ["precision " + r.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = position * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}"].join("\n")), e.shaderSource(i, ["precision " + r.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}"].join("\n")), e.compileShader(n), e.compileShader(i), e.attachShader(t, n), e.attachShader(t, i), e.linkProgram(t), s = t, c = {
                        position: e.getAttribLocation(s, "position"),
                        uv: e.getAttribLocation(s, "uv")
                    }, l = {
                        uvOffset: e.getUniformLocation(s, "uvOffset"),
                        uvScale: e.getUniformLocation(s, "uvScale"),
                        rotation: e.getUniformLocation(s, "rotation"),
                        scale: e.getUniformLocation(s, "scale"),
                        color: e.getUniformLocation(s, "color"),
                        map: e.getUniformLocation(s, "map"),
                        opacity: e.getUniformLocation(s, "opacity"),
                        modelViewMatrix: e.getUniformLocation(s, "modelViewMatrix"),
                        projectionMatrix: e.getUniformLocation(s, "projectionMatrix"),
                        fogType: e.getUniformLocation(s, "fogType"),
                        fogDensity: e.getUniformLocation(s, "fogDensity"),
                        fogNear: e.getUniformLocation(s, "fogNear"),
                        fogFar: e.getUniformLocation(s, "fogFar"),
                        fogColor: e.getUniformLocation(s, "fogColor"),
                        fogDepth: e.getUniformLocation(s, "fogDepth"),
                        alphaTest: e.getUniformLocation(s, "alphaTest")
                    };
                    var p = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    p.width = 8, p.height = 8;
                    var f = p.getContext("2d");
                    f.fillStyle = "white", f.fillRect(0, 0, 8, 8), u = new zn(p)
                }
  
                function m(t, e) {
                    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
                }
                this.render = function(r, v, g) {
                    if (0 !== r.length) {
                        void 0 === s && f(), n.useProgram(s), n.initAttributes(), n.enableAttribute(c.position), n.enableAttribute(c.uv), n.disableUnusedAttributes(), n.disable(e.CULL_FACE), n.enable(e.BLEND), e.bindBuffer(e.ARRAY_BUFFER, a), e.vertexAttribPointer(c.position, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(c.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, o), e.uniformMatrix4fv(l.projectionMatrix, !1, g.projectionMatrix.elements), n.activeTexture(e.TEXTURE0), e.uniform1i(l.map, 0);
                        var y = 0,
                            x = 0,
                            b = v.fog;
                        b ? (e.uniform3f(l.fogColor, b.color.r, b.color.g, b.color.b), b.isFog ? (e.uniform1f(l.fogNear, b.near), e.uniform1f(l.fogFar, b.far), e.uniform1i(l.fogType, 1), y = 1, x = 1) : b.isFogExp2 && (e.uniform1f(l.fogDensity, b.density), e.uniform1i(l.fogType, 2), y = 2, x = 2)) : (e.uniform1i(l.fogType, 0), y = 0, x = 0);
                        for (var w = 0, _ = r.length; w < _; w++) {
                            (E = r[w]).modelViewMatrix.multiplyMatrices(g.matrixWorldInverse, E.matrixWorld), E.z = -E.modelViewMatrix.elements[14]
                        }
                        r.sort(m);
                        var M = [];
                        for (w = 0, _ = r.length; w < _; w++) {
                            var E, T = (E = r[w]).material;
                            if (!1 !== T.visible) {
                                E.onBeforeRender(t, v, g, void 0, T, void 0), e.uniform1f(l.alphaTest, T.alphaTest), e.uniformMatrix4fv(l.modelViewMatrix, !1, E.modelViewMatrix.elements), E.matrixWorld.decompose(h, d, p), M[0] = p.x, M[1] = p.y;
                                var S = 0;
                                v.fog && T.fog && (S = x), y !== S && (e.uniform1i(l.fogType, S), y = S), null !== T.map ? (e.uniform2f(l.uvOffset, T.map.offset.x, T.map.offset.y), e.uniform2f(l.uvScale, T.map.repeat.x, T.map.repeat.y)) : (e.uniform2f(l.uvOffset, 0, 0), e.uniform2f(l.uvScale, 1, 1)), e.uniform1f(l.opacity, T.opacity), e.uniform3f(l.color, T.color.r, T.color.g, T.color.b), e.uniform1f(l.rotation, T.rotation), e.uniform2fv(l.scale, M), n.setBlending(T.blending, T.blendEquation, T.blendSrc, T.blendDst, T.blendEquationAlpha, T.blendSrcAlpha, T.blendDstAlpha, T.premultipliedAlpha), n.buffers.depth.setTest(T.depthTest), n.buffers.depth.setMask(T.depthWrite), n.buffers.color.setMask(T.colorWrite), i.setTexture2D(T.map || u, 0), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), E.onAfterRender(t, v, g, void 0, T, void 0)
                            }
                        }
                        n.enable(e.CULL_FACE), n.reset()
                    }
                }
            }
            Un.physical = {
                uniforms: Nn.merge([Un.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: Dn.meshphysical_vert,
                fragmentShader: Dn.meshphysical_frag
            }, Object.assign(kn.prototype, {
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: (On = new Pe, function(t, e) {
                    var n = On.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                }),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function(t) {
                    var e = t || new Pe;
                    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    var e = t || new Pe;
                    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                },
                getParameter: function(t, e) {
                    return (e || new Pe).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                },
                clampPoint: function(t, e) {
                    return (e || new Pe).copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: (Rn = new Pe, function(t) {
                    return Rn.copy(t).clamp(this.min, this.max).sub(t).length()
                }),
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }), zn.prototype = Object.create(ke.prototype), zn.prototype.constructor = zn;
            var jn, Gn, Hn, Vn, Wn, Xn, qn, Yn, $n, Zn, Jn, Kn, Qn, ti, ei, ni, ii, ri = 0;
  
            function ai() {
                Object.defineProperty(this, "id", {
                    value: ri++
                }), this.uuid = Le.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = U, this.side = P, this.flatShading = !1, this.vertexColors = O, this.opacity = 1, this.transparent = !1, this.blendSrc = Z, this.blendDst = J, this.blendEquation = j, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = ot, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }
  
            function oi(t) {
                ai.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Se, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
            }
  
            function si(t) {
                ai.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Oe, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
            }
  
            function ci(t, e) {
                this.min = void 0 !== t ? t : new Oe(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Oe(-1 / 0, -1 / 0, -1 / 0)
            }
  
            function li(t, e) {
                this.center = void 0 !== t ? t : new Oe, this.radius = void 0 !== e ? e : 0
            }
  
            function ui(t, e) {
                this.normal = void 0 !== t ? t : new Oe(1, 0, 0), this.constant = void 0 !== e ? e : 0
            }
  
            function hi(t, e, n, i, r, a) {
                this.planes = [void 0 !== t ? t : new ui, void 0 !== e ? e : new ui, void 0 !== n ? n : new ui, void 0 !== i ? i : new ui, void 0 !== r ? r : new ui, void 0 !== a ? a : new ui]
            }
  
            function di(t, e, n) {
                for (var i = new hi, r = new Ce, a = new Pe, o = new Pe(n, n), s = new Oe, c = new Oe, l = 1, u = 2, h = 1 + (l | u), d = new Array(h), p = new Array(h), f = {}, m = [new Oe(1, 0, 0), new Oe(-1, 0, 0), new Oe(0, 0, 1), new Oe(0, 0, -1), new Oe(0, 1, 0), new Oe(0, -1, 0)], v = [new Oe(0, 1, 0), new Oe(0, 1, 0), new Oe(0, 1, 0), new Oe(0, 1, 0), new Oe(0, 0, 1), new Oe(0, 0, -1)], g = [new Fe, new Fe, new Fe, new Fe, new Fe, new Fe], y = 0; y !== h; ++y) {
                    var x = 0 != (y & l),
                        b = 0 != (y & u),
                        w = new oi({
                            depthPacking: Ae,
                            morphTargets: x,
                            skinning: b
                        });
                    d[y] = w;
                    var _ = new si({
                        morphTargets: x,
                        skinning: b
                    });
                    p[y] = _
                }
                var M = this;
  
                function E(e, n, i, r, a, o) {
                    var s = e.geometry,
                        c = null,
                        h = d,
                        m = e.customDepthMaterial;
                    if (i && (h = p, m = e.customDistanceMaterial), m) c = m;
                    else {
                        var v = !1;
                        n.morphTargets && (s && s.isBufferGeometry ? v = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (v = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                        var g = e.isSkinnedMesh && n.skinning,
                            y = 0;
                        v && (y |= l), g && (y |= u), c = h[y]
                    }
                    if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                        var x = c.uuid,
                            b = n.uuid,
                            w = f[x];
                        void 0 === w && (w = {}, f[x] = w);
                        var _ = w[b];
                        void 0 === _ && (_ = c.clone(), w[b] = _), c = _
                    }
                    c.visible = n.visible, c.wireframe = n.wireframe;
                    var E = n.side;
                    return M.renderSingleSided && E == R && (E = P), M.renderReverseSided && (E === P ? E = C : E === C && (E = P)), c.side = E, c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, i && c.isMeshDistanceMaterial && (c.referencePosition.copy(r), c.nearDistance = a, c.farDistance = o), c
                }
  
                function T(n, r, a, o) {
                    if (!1 !== n.visible) {
                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                            var s = e.update(n),
                                l = n.material;
                            if (Array.isArray(l))
                                for (var u = s.groups, h = 0, d = u.length; h < d; h++) {
                                    var p = u[h],
                                        f = l[p.materialIndex];
                                    if (f && f.visible) {
                                        var m = E(n, f, o, c, a.near, a.far);
                                        t.renderBufferDirect(a, null, s, m, n, p)
                                    }
                                } else if (l.visible) {
                                    m = E(n, l, o, c, a.near, a.far);
                                    t.renderBufferDirect(a, null, s, m, n, null)
                                }
                        }
                        for (var v = n.children, g = 0, y = v.length; g < y; g++) T(v[g], r, a, o)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = A, this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function(e, n, l) {
                    if (!1 !== M.enabled && (!1 !== M.autoUpdate || !1 !== M.needsUpdate) && 0 !== e.length) {
                        var u, h = t.context,
                            d = t.state;
                        d.disable(h.BLEND), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                        for (var p = 0, f = e.length; p < f; p++) {
                            var y = e[p],
                                x = y.shadow,
                                b = y && y.isPointLight;
                            if (void 0 !== x) {
                                var w = x.camera;
                                if (a.copy(x.mapSize), a.min(o), b) {
                                    var _ = a.x,
                                        E = a.y;
                                    g[0].set(2 * _, E, _, E), g[1].set(0, E, _, E), g[2].set(3 * _, E, _, E), g[3].set(_, E, _, E), g[4].set(3 * _, 0, _, E), g[5].set(_, 0, _, E), a.x *= 4, a.y *= 2
                                }
                                if (null === x.map) {
                                    var S = {
                                        minFilter: Pt,
                                        magFilter: Pt,
                                        format: $t
                                    };
                                    x.map = new ze(a.x, a.y, S), x.map.texture.name = y.name + ".shadowMap", w.updateProjectionMatrix()
                                }
                                x.isSpotLightShadow && x.update(y);
                                var A = x.map,
                                    L = x.matrix;
                                c.setFromMatrixPosition(y.matrixWorld), w.position.copy(c), b ? (u = 6, L.makeTranslation(-c.x, -c.y, -c.z)) : (u = 1, s.setFromMatrixPosition(y.target.matrixWorld), w.lookAt(s), w.updateMatrixWorld(), L.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), L.multiply(w.projectionMatrix), L.multiply(w.matrixWorldInverse)), t.setRenderTarget(A), t.clear();
                                for (var P = 0; P < u; P++) {
                                    if (b) {
                                        s.copy(w.position), s.add(m[P]), w.up.copy(v[P]), w.lookAt(s), w.updateMatrixWorld();
                                        var C = g[P];
                                        d.viewport(C)
                                    }
                                    r.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse), i.setFromMatrix(r), T(n, l, w, b)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", y, "has no shadow.")
                        }
                        M.needsUpdate = !1
                    }
                }
            }
  
            function pi(t) {
                var e = {};
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), e[t.uuid]
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var i = e[n.uuid];
                        i && (t.deleteBuffer(i.buffer), delete e[n.uuid])
                    },
                    update: function(n, i) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var r, a, o, s, c, l = e[n.uuid];
                        void 0 === l ? e[n.uuid] = function(e, n) {
                            var i = e.array,
                                r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                                a = t.createBuffer();
                            t.bindBuffer(n, a), t.bufferData(n, i, r), e.onUploadCallback();
                            var o = t.FLOAT;
                            return i instanceof Float32Array ? o = t.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? o = t.UNSIGNED_SHORT : i instanceof Int16Array ? o = t.SHORT : i instanceof Uint32Array ? o = t.UNSIGNED_INT : i instanceof Int32Array ? o = t.INT : i instanceof Int8Array ? o = t.BYTE : i instanceof Uint8Array && (o = t.UNSIGNED_BYTE), {
                                buffer: a,
                                type: o,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(n, i) : l.version < n.version && (r = l.buffer, o = i, s = (a = n).array, c = a.updateRange, t.bindBuffer(o, r), !1 === a.dynamic ? t.bufferData(o, s, t.STATIC_DRAW) : -1 === c.count ? t.bufferSubData(o, 0, s) : 0 === c.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(o, c.offset * s.BYTES_PER_ELEMENT, s.subarray(c.offset, c.offset + c.count)), c.count = -1), l.version = n.version)
                    }
                }
            }
  
            function fi(t, e, n, i) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || fi.DefaultOrder
            }
  
            function mi() {
                this.mask = 1
            }
            ai.prototype = Object.assign(Object.create(e.prototype), {
                constructor: ai,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var n = t[e];
                            if (void 0 !== n)
                                if ("shading" !== e) {
                                    var i = this[e];
                                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = "overdraw" === e ? Number(n) : n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                        }
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
  
                    function i(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== U && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== P && (n.side = this.side), this.vertexColors !== O && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                        var r = i(t.textures),
                            a = i(t.images);
                        r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                    var e = t.clippingPlanes,
                        n = null;
                    if (null !== e) {
                        var i = e.length;
                        n = new Array(i);
                        for (var r = 0; r !== i; ++r) n[r] = e[r].clone()
                    }
                    return this.clippingPlanes = n, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), oi.prototype = Object.create(ai.prototype), oi.prototype.constructor = oi, oi.prototype.isMeshDepthMaterial = !0, oi.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, si.prototype = Object.create(ai.prototype), si.prototype.constructor = si, si.prototype.isMeshDistanceMaterial = !0, si.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }, Object.assign(ci.prototype, {
                isBox3: !0,
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromArray: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                        var l = t[s],
                            u = t[s + 1],
                            h = t[s + 2];
                        l < e && (e = l), u < n && (n = u), h < i && (i = h), l > r && (r = l), u > a && (a = u), h > o && (o = h)
                    }
                    return this.min.set(e, n, i), this.max.set(r, a, o), this
                },
                setFromBufferAttribute: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.count; s < c; s++) {
                        var l = t.getX(s),
                            u = t.getY(s),
                            h = t.getZ(s);
                        l < e && (e = l), u < n && (n = u), h < i && (i = h), l > r && (r = l), u > a && (a = u), h > o && (o = h)
                    }
                    return this.min.set(e, n, i), this.max.set(r, a, o), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: (Wn = new Oe, function(t, e) {
                    var n = Wn.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                }),
                setFromObject: function(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(t) {
                    var e = t || new Oe;
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    var e = t || new Oe;
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                expandByObject: function() {
                    var t, e, n, i = new Oe;
  
                    function r(r) {
                        var a = r.geometry;
                        if (void 0 !== a)
                            if (a.isGeometry) {
                                var o = a.vertices;
                                for (e = 0, n = o.length; e < n; e++) i.copy(o[e]), i.applyMatrix4(r.matrixWorld), t.expandByPoint(i)
                            } else if (a.isBufferGeometry) {
                            var s = a.attributes.position;
                            if (void 0 !== s)
                                for (e = 0, n = s.count; e < n; e++) i.fromBufferAttribute(s, e).applyMatrix4(r.matrixWorld), t.expandByPoint(i)
                        }
                    }
                    return function(e) {
                        return t = this, e.updateMatrixWorld(!0), e.traverse(r), this
                    }
                }(),
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                },
                getParameter: function(t, e) {
                    return (e || new Oe).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                },
                intersectsSphere: (Vn = new Oe, function(t) {
                    return this.clampPoint(t.center, Vn), Vn.distanceToSquared(t.center) <= t.radius * t.radius
                }),
                intersectsPlane: function(t) {
                    var e, n;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= t.constant && n >= t.constant
                },
                clampPoint: function(t, e) {
                    return (e || new Oe).copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: (Hn = new Oe, function(t) {
                    return Hn.copy(t).clamp(this.min, this.max).sub(t).length()
                }),
                getBoundingSphere: (Gn = new Oe, function(t) {
                    var e = t || new li;
                    return this.getCenter(e.center), e.radius = .5 * this.getSize(Gn).length(), e
                }),
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                applyMatrix4: (jn = [new Oe, new Oe, new Oe, new Oe, new Oe, new Oe, new Oe, new Oe], function(t) {
                    return this.isEmpty() ? this : (jn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), jn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), jn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), jn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), jn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), jn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), jn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), jn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(jn), this)
                }),
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }), Object.assign(li.prototype, {
                set: function(t, e) {
                    return this.center.copy(t), this.radius = e, this
                },
                setFromPoints: (Xn = new ci, function(t, e) {
                    var n = this.center;
                    void 0 !== e ? n.copy(e) : Xn.setFromPoints(t).getCenter(n);
                    for (var i = 0, r = 0, a = t.length; r < a; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                    return this.radius = Math.sqrt(i), this
                }),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(t) {
                    return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(t) {
                    var e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function(t) {
                    return t.intersectsSphere(this)
                },
                intersectsPlane: function(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(t, e) {
                    var n = this.center.distanceToSquared(t),
                        i = e || new Oe;
                    return i.copy(t), n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i
                },
                getBoundingBox: function(t) {
                    var e = t || new ci;
                    return e.set(this.center, this.center), e.expandByScalar(this.radius), e
                },
                applyMatrix4: function(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                },
                translate: function(t) {
                    return this.center.add(t), this
                },
                equals: function(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            }), Object.assign(ui.prototype, {
                set: function(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                },
                setComponents: function(t, e, n, i) {
                    return this.normal.set(t, e, n), this.constant = i, this
                },
                setFromNormalAndCoplanarPoint: function(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                },
                setFromCoplanarPoints: (Zn = new Oe, Jn = new Oe, function(t, e, n) {
                    var i = Zn.subVectors(n, e).cross(Jn.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, t), this
                }),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                },
                normalize: function() {
                    var t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(t) {
                    return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function(t) {
                    return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function(t, e) {
                    return (e || new Oe).copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                },
                intersectLine: ($n = new Oe, function(t, e) {
                    var n = e || new Oe,
                        i = t.delta($n),
                        r = this.normal.dot(i);
                    if (0 === r) return 0 === this.distanceToPoint(t.start) ? n.copy(t.start) : void 0;
                    var a = -(t.start.dot(this.normal) + this.constant) / r;
                    return a < 0 || a > 1 ? void 0 : n.copy(i).multiplyScalar(a).add(t.start)
                }),
                intersectsLine: function(t) {
                    var e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return e < 0 && n > 0 || n < 0 && e > 0
                },
                intersectsBox: function(t) {
                    return t.intersectsPlane(this)
                },
                intersectsSphere: function(t) {
                    return t.intersectsPlane(this)
                },
                coplanarPoint: function(t) {
                    return (t || new Oe).copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: (qn = new Oe, Yn = new Ie, function(t, e) {
                    var n = e || Yn.getNormalMatrix(t),
                        i = this.coplanarPoint(qn).applyMatrix4(t),
                        r = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -i.dot(r), this
                }),
                translate: function(t) {
                    return this.constant -= t.dot(this.normal), this
                },
                equals: function(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            }), Object.assign(hi.prototype, {
                set: function(t, e, n, i, r, a) {
                    var o = this.planes;
                    return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this
                },
                setFromMatrix: function(t) {
                    var e = this.planes,
                        n = t.elements,
                        i = n[0],
                        r = n[1],
                        a = n[2],
                        o = n[3],
                        s = n[4],
                        c = n[5],
                        l = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return e[0].setComponents(o - i, u - s, f - h, y - m).normalize(), e[1].setComponents(o + i, u + s, f + h, y + m).normalize(), e[2].setComponents(o + r, u + c, f + d, y + v).normalize(), e[3].setComponents(o - r, u - c, f - d, y - v).normalize(), e[4].setComponents(o - a, u - l, f - p, y - g).normalize(), e[5].setComponents(o + a, u + l, f + p, y + g).normalize(), this
                },
                intersectsObject: (ei = new li, function(t) {
                    var e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(), ei.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(ei)
                }),
                intersectsSprite: (ti = new li, function(t) {
                    return ti.center.set(0, 0, 0), ti.radius = .7071067811865476, ti.applyMatrix4(t.matrixWorld), this.intersectsSphere(ti)
                }),
                intersectsSphere: function(t) {
                    for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                        if (e[r].distanceToPoint(n) < i) return !1
                    }
                    return !0
                },
                intersectsBox: (Kn = new Oe, Qn = new Oe, function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++) {
                        var i = e[n];
                        Kn.x = i.normal.x > 0 ? t.min.x : t.max.x, Qn.x = i.normal.x > 0 ? t.max.x : t.min.x, Kn.y = i.normal.y > 0 ? t.min.y : t.max.y, Qn.y = i.normal.y > 0 ? t.max.y : t.min.y, Kn.z = i.normal.z > 0 ? t.min.z : t.max.z, Qn.z = i.normal.z > 0 ? t.max.z : t.min.z;
                        var r = i.distanceToPoint(Kn),
                            a = i.distanceToPoint(Qn);
                        if (r < 0 && a < 0) return !1
                    }
                    return !0
                }),
                containsPoint: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++)
                        if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            }), fi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], fi.DefaultOrder = "XYZ", Object.defineProperties(fi.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(t) {
                        this._order = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(fi.prototype, {
                isEuler: !0,
                set: function(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t, e, n) {
                    var i = Le.clamp,
                        r = t.elements,
                        a = r[0],
                        o = r[4],
                        s = r[8],
                        c = r[1],
                        l = r[5],
                        u = r[9],
                        h = r[2],
                        d = r[6],
                        p = r[10];
                    return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, a), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === e ? (this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === e ? (this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === e ? (this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== n && this.onChangeCallback(), this
                },
                setFromQuaternion: (ii = new Ce, function(t, e, n) {
                    return ii.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ii, e, n)
                }),
                setFromVector3: function(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                },
                reorder: (ni = new Re, function(t) {
                    return ni.setFromEuler(this), this.setFromQuaternion(ni, t)
                }),
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                },
                fromArray: function(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                },
                toVector3: function(t) {
                    return t ? t.set(this._x, this._y, this._z) : new Oe(this._x, this._y, this._z)
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(mi.prototype, {
                set: function(t) {
                    this.mask = 1 << t | 0
                },
                enable: function(t) {
                    this.mask |= 1 << t | 0
                },
                toggle: function(t) {
                    this.mask ^= 1 << t | 0
                },
                disable: function(t) {
                    this.mask &= ~(1 << t | 0)
                },
                test: function(t) {
                    return 0 != (this.mask & t.mask)
                }
            });
            var vi, gi, yi, xi, bi, wi, _i, Mi, Ei, Ti, Si, Ai, Li, Pi, Ci, Ri, Oi, Ii, Ni, Di = 0;
  
            function Ui() {
                Object.defineProperty(this, "id", {
                    value: Di++
                }), this.uuid = Le.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ui.DefaultUp.clone();
                var t = new Oe,
                    e = new fi,
                    n = new Re,
                    i = new Oe(1, 1, 1);
                e.onChange(function() {
                    n.setFromEuler(e, !1)
                }), n.onChange(function() {
                    e.setFromQuaternion(n, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Ce
                    },
                    normalMatrix: {
                        value: new Ie
                    }
                }), this.matrix = new Ce, this.matrixWorld = new Ce, this.matrixAutoUpdate = Ui.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new mi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
  
            function ki() {
                Ui.call(this), this.type = "Camera", this.matrixWorldInverse = new Ce, this.projectionMatrix = new Ce
            }
  
            function Fi(t, e, n, i, r, a) {
                ki.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
            }
  
            function zi(t, e, n, i, r, a) {
                this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new Oe, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Cn, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
            }
            Ui.DefaultUp = new Oe(0, 1, 0), Ui.DefaultMatrixAutoUpdate = !0, Ui.prototype = Object.assign(Object.create(e.prototype), {
                constructor: Ui,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(t) {
                    this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: (Ii = new Re, function(t, e) {
                    return Ii.setFromAxisAngle(t, e), this.quaternion.multiply(Ii), this
                }),
                rotateOnWorldAxis: (Oi = new Re, function(t, e) {
                    return Oi.setFromAxisAngle(t, e), this.quaternion.premultiply(Oi), this
                }),
                rotateX: (Ri = new Oe(1, 0, 0), function(t) {
                    return this.rotateOnAxis(Ri, t)
                }),
                rotateY: (Ci = new Oe(0, 1, 0), function(t) {
                    return this.rotateOnAxis(Ci, t)
                }),
                rotateZ: (Pi = new Oe(0, 0, 1), function(t) {
                    return this.rotateOnAxis(Pi, t)
                }),
                translateOnAxis: (Li = new Oe, function(t, e) {
                    return Li.copy(t).applyQuaternion(this.quaternion), this.position.add(Li.multiplyScalar(e)), this
                }),
                translateX: (Ai = new Oe(1, 0, 0), function(t) {
                    return this.translateOnAxis(Ai, t)
                }),
                translateY: (Si = new Oe(0, 1, 0), function(t) {
                    return this.translateOnAxis(Si, t)
                }),
                translateZ: (Ti = new Oe(0, 0, 1), function(t) {
                    return this.translateOnAxis(Ti, t)
                }),
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: (Ei = new Ce, function(t) {
                    return t.applyMatrix4(Ei.getInverse(this.matrixWorld))
                }),
                lookAt: (_i = new Ce, Mi = new Oe, function(t, e, n) {
                    t.isVector3 ? Mi.copy(t) : Mi.set(t, e, n), this.isCamera ? _i.lookAt(this.position, Mi, this.up) : _i.lookAt(Mi, this.position, this.up), this.quaternion.setFromRotationMatrix(_i)
                }),
                add: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                        type: "added"
                    }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    var n = this.children.indexOf(t);
                    return -1 !== n && (t.parent = null, t.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(n, 1)), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (var n = 0, i = this.children.length; n < i; n++) {
                        var r = this.children[n].getObjectByProperty(t, e);
                        if (void 0 !== r) return r
                    }
                },
                getWorldPosition: function(t) {
                    var e = t || new Oe;
                    return this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: (bi = new Oe, wi = new Oe, function(t) {
                    var e = t || new Re;
                    return this.updateMatrixWorld(!0), this.matrixWorld.decompose(bi, e, wi), e
                }),
                getWorldRotation: (xi = new Re, function(t) {
                    var e = t || new fi;
                    return this.getWorldQuaternion(xi), e.setFromQuaternion(xi, this.rotation.order, !1)
                }),
                getWorldScale: (gi = new Oe, yi = new Re, function(t) {
                    var e = t || new Oe;
                    return this.updateMatrixWorld(!0), this.matrixWorld.decompose(gi, yi, e), e
                }),
                getWorldDirection: (vi = new Re, function(t) {
                    var e = t || new Oe;
                    return this.getWorldQuaternion(vi), e.set(0, 0, 1).applyQuaternion(vi)
                }),
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 !== this.visible) {
                        t(this);
                        for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t,
                        n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var i = {};
  
                    function r(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.matrix = this.matrix.toArray(), void 0 !== this.geometry) {
                        i.geometry = r(t.geometries, this.geometry);
                        var a = this.geometry.parameters;
                        if (void 0 !== a && void 0 !== a.shapes) {
                            var o = a.shapes;
                            if (Array.isArray(o))
                                for (var s = 0, c = o.length; s < c; s++) {
                                    var l = o[s];
                                    r(t.shapes, l)
                                } else r(t.shapes, o)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var u = [];
                            for (s = 0, c = this.material.length; s < c; s++) u.push(r(t.materials, this.material[s]));
                            i.material = u
                        } else i.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(t).object)
                    }
                    if (e) {
                        var h = m(t.geometries),
                            d = m(t.materials),
                            p = m(t.textures),
                            f = m(t.images);
                        o = m(t.shapes);
                        h.length > 0 && (n.geometries = h), d.length > 0 && (n.materials = d), p.length > 0 && (n.textures = p), f.length > 0 && (n.images = f), o.length > 0 && (n.shapes = o)
                    }
                    return n.object = i, n;
  
                    function m(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (var n = 0; n < t.children.length; n++) {
                            var i = t.children[n];
                            this.add(i.clone())
                        }
                    return this
                }
            }), ki.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: ki,
                isCamera: !0,
                copy: function(t, e) {
                    return Ui.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
                },
                getWorldDirection: (Ni = new Re, function(t) {
                    var e = t || new Oe;
                    return this.getWorldQuaternion(Ni), e.set(0, 0, -1).applyQuaternion(Ni)
                }),
                updateMatrixWorld: function(t) {
                    Ui.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), Fi.prototype = Object.assign(Object.create(ki.prototype), {
                constructor: Fi,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return ki.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, n, i, r, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2,
                        r = n - t,
                        a = n + t,
                        o = i + e,
                        s = i - e;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            l = this.zoom / (this.view.height / this.view.fullHeight),
                            u = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        a = (r += u * (this.view.offsetX / c)) + u * (this.view.width / c), s = (o -= h * (this.view.offsetY / l)) - h * (this.view.height / l)
                    }
                    this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far)
                },
                toJSON: function(t) {
                    var e = Ui.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), Object.assign(zi.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            });
            var Bi, ji, Gi, Hi, Vi, Wi, Xi = 0;
  
            function qi() {
                Object.defineProperty(this, "id", {
                    value: Xi += 2
                }), this.uuid = Le.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
  
            function Yi(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.uuid = Le.generateUUID(), this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.onUploadCallback = function() {}, this.version = 0
            }
  
            function $i(t, e, n) {
                Yi.call(this, new Int8Array(t), e, n)
            }
  
            function Zi(t, e, n) {
                Yi.call(this, new Uint8Array(t), e, n)
            }
  
            function Ji(t, e, n) {
                Yi.call(this, new Uint8ClampedArray(t), e, n)
            }
  
            function Ki(t, e, n) {
                Yi.call(this, new Int16Array(t), e, n)
            }
  
            function Qi(t, e, n) {
                Yi.call(this, new Uint16Array(t), e, n)
            }
  
            function tr(t, e, n) {
                Yi.call(this, new Int32Array(t), e, n)
            }
  
            function er(t, e, n) {
                Yi.call(this, new Uint32Array(t), e, n)
            }
  
            function nr(t, e, n) {
                Yi.call(this, new Float32Array(t), e, n)
            }
  
            function ir(t, e, n) {
                Yi.call(this, new Float64Array(t), e, n)
            }
  
            function rr() {
                this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
  
            function ar(t) {
                if (0 === t.length) return -1 / 0;
                for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
                return e
            }
            qi.prototype = Object.assign(Object.create(e.prototype), {
                constructor: qi,
                isGeometry: !0,
                applyMatrix: function(t) {
                    for (var e = (new Ie).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                        this.vertices[n].applyMatrix4(t)
                    }
                    for (n = 0, i = this.faces.length; n < i; n++) {
                        var r = this.faces[n];
                        r.normal.applyMatrix3(e).normalize();
                        for (var a = 0, o = r.vertexNormals.length; a < o; a++) r.vertexNormals[a].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: (Wi = new Ce, function(t) {
                    return Wi.makeRotationX(t), this.applyMatrix(Wi), this
                }),
                rotateY: (Vi = new Ce, function(t) {
                    return Vi.makeRotationY(t), this.applyMatrix(Vi), this
                }),
                rotateZ: (Hi = new Ce, function(t) {
                    return Hi.makeRotationZ(t), this.applyMatrix(Hi), this
                }),
                translate: (Gi = new Ce, function(t, e, n) {
                    return Gi.makeTranslation(t, e, n), this.applyMatrix(Gi), this
                }),
                scale: (ji = new Ce, function(t, e, n) {
                    return ji.makeScale(t, e, n), this.applyMatrix(ji), this
                }),
                lookAt: (Bi = new Ui, function(t) {
                    Bi.lookAt(t), Bi.updateMatrix(), this.applyMatrix(Bi.matrix)
                }),
                fromBufferGeometry: function(t) {
                    var e = this,
                        n = null !== t.index ? t.index.array : void 0,
                        i = t.attributes,
                        r = i.position.array,
                        a = void 0 !== i.normal ? i.normal.array : void 0,
                        o = void 0 !== i.color ? i.color.array : void 0,
                        s = void 0 !== i.uv ? i.uv.array : void 0,
                        c = void 0 !== i.uv2 ? i.uv2.array : void 0;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (var l = [], u = [], h = [], d = 0, p = 0; d < r.length; d += 3, p += 2) e.vertices.push(new Oe(r[d], r[d + 1], r[d + 2])), void 0 !== a && l.push(new Oe(a[d], a[d + 1], a[d + 2])), void 0 !== o && e.colors.push(new Cn(o[d], o[d + 1], o[d + 2])), void 0 !== s && u.push(new Pe(s[p], s[p + 1])), void 0 !== c && h.push(new Pe(c[p], c[p + 1]));
  
                    function f(t, n, i, r) {
                        var d = new zi(t, n, i, void 0 !== a ? [l[t].clone(), l[n].clone(), l[i].clone()] : [], void 0 !== o ? [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()] : [], r);
                        e.faces.push(d), void 0 !== s && e.faceVertexUvs[0].push([u[t].clone(), u[n].clone(), u[i].clone()]), void 0 !== c && e.faceVertexUvs[1].push([h[t].clone(), h[n].clone(), h[i].clone()])
                    }
                    var m = t.groups;
                    if (m.length > 0)
                        for (d = 0; d < m.length; d++)
                            for (var v = m[d], g = v.start, y = (p = g, g + v.count); p < y; p += 3) void 0 !== n ? f(n[p], n[p + 1], n[p + 2], v.materialIndex) : f(p, p + 1, p + 2, v.materialIndex);
                    else if (void 0 !== n)
                        for (d = 0; d < n.length; d += 3) f(n[d], n[d + 1], n[d + 2]);
                    else
                        for (d = 0; d < r.length / 3; d += 3) f(d, d + 1, d + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    this.computeBoundingBox();
                    var t = this.boundingBox.getCenter().negate();
                    return this.translate(t.x, t.y, t.z), t
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        n = 0 === e ? 1 : 1 / e,
                        i = new Ce;
                    return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
                },
                computeFaceNormals: function() {
                    for (var t = new Oe, e = new Oe, n = 0, i = this.faces.length; n < i; n++) {
                        var r = this.faces[n],
                            a = this.vertices[r.a],
                            o = this.vertices[r.b],
                            s = this.vertices[r.c];
                        t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), r.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    var e, n, i, r, a, o;
                    for (void 0 === t && (t = !0), o = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) o[e] = new Oe;
                    if (t) {
                        var s, c, l, u = new Oe,
                            h = new Oe;
                        for (i = 0, r = this.faces.length; i < r; i++) a = this.faces[i], s = this.vertices[a.a], c = this.vertices[a.b], l = this.vertices[a.c], u.subVectors(l, c), h.subVectors(s, c), u.cross(h), o[a.a].add(u), o[a.b].add(u), o[a.c].add(u)
                    } else
                        for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) o[(a = this.faces[i]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal);
                    for (e = 0, n = this.vertices.length; e < n; e++) o[e].normalize();
                    for (i = 0, r = this.faces.length; i < r; i++) {
                        var d = (a = this.faces[i]).vertexNormals;
                        3 === d.length ? (d[0].copy(o[a.a]), d[1].copy(o[a.b]), d[2].copy(o[a.c])) : (d[0] = o[a.a].clone(), d[1] = o[a.b].clone(), d[2] = o[a.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var t, e, n;
                    for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                        var i = (n = this.faces[t]).vertexNormals;
                        3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var t, e, n, i, r;
                    for (n = 0, i = this.faces.length; n < i; n++)
                        for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                    var a = new qi;
                    for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                            var o = this.morphNormals[t].faceNormals,
                                s = this.morphNormals[t].vertexNormals;
                            for (n = 0, i = this.faces.length; n < i; n++) c = new Oe, l = {
                                a: new Oe,
                                b: new Oe,
                                c: new Oe
                            }, o.push(c), s.push(l)
                        }
                        var c, l, u = this.morphNormals[t];
                        for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], c = u.faceNormals[n], l = u.vertexNormals[n], c.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2])
                    }
                    for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
                },
                computeLineDistances: function() {
                    for (var t = 0, e = this.vertices, n = 0, i = e.length; n < i; n++) n > 0 && (t += e[n].distanceTo(e[n - 1])), this.lineDistances[n] = t
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new ci), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new li), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, n) {
                    if (t && t.isGeometry) {
                        var i, r = this.vertices.length,
                            a = this.vertices,
                            o = t.vertices,
                            s = this.faces,
                            c = t.faces,
                            l = this.faceVertexUvs[0],
                            u = t.faceVertexUvs[0],
                            h = this.colors,
                            d = t.colors;
                        void 0 === n && (n = 0), void 0 !== e && (i = (new Ie).getNormalMatrix(e));
                        for (var p = 0, f = o.length; p < f; p++) {
                            var m = o[p].clone();
                            void 0 !== e && m.applyMatrix4(e), a.push(m)
                        }
                        for (p = 0, f = d.length; p < f; p++) h.push(d[p].clone());
                        for (p = 0, f = c.length; p < f; p++) {
                            var v, g, y, x = c[p],
                                b = x.vertexNormals,
                                w = x.vertexColors;
                            (v = new zi(x.a + r, x.b + r, x.c + r)).normal.copy(x.normal), void 0 !== i && v.normal.applyMatrix3(i).normalize();
                            for (var _ = 0, M = b.length; _ < M; _++) g = b[_].clone(), void 0 !== i && g.applyMatrix3(i).normalize(), v.vertexNormals.push(g);
                            v.color.copy(x.color);
                            for (_ = 0, M = w.length; _ < M; _++) y = w[_], v.vertexColors.push(y.clone());
                            v.materialIndex = x.materialIndex + n, s.push(v)
                        }
                        for (p = 0, f = u.length; p < f; p++) {
                            var E = u[p],
                                T = [];
                            if (void 0 !== E) {
                                for (_ = 0, M = E.length; _ < M; _++) T.push(E[_].clone());
                                l.push(T)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    var t, e, n, i, r, a, o, s, c = {},
                        l = [],
                        u = [],
                        h = Math.pow(10, 4);
                    for (n = 0, i = this.vertices.length; n < i; n++) t = this.vertices[n], void 0 === c[e = Math.round(t.x * h) + "_" + Math.round(t.y * h) + "_" + Math.round(t.z * h)] ? (c[e] = n, l.push(this.vertices[n]), u[n] = l.length - 1) : u[n] = u[c[e]];
                    var d = [];
                    for (n = 0, i = this.faces.length; n < i; n++) {
                        (r = this.faces[n]).a = u[r.a], r.b = u[r.b], r.c = u[r.c], a = [r.a, r.b, r.c];
                        for (var p = 0; p < 3; p++)
                            if (a[p] === a[(p + 1) % 3]) {
                                d.push(n);
                                break
                            }
                    }
                    for (n = d.length - 1; n >= 0; n--) {
                        var f = d[n];
                        for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(f, 1)
                    }
                    var m = this.vertices.length - l.length;
                    return this.vertices = l, m
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (var e = 0, n = t.length; e < n; e++) {
                        var i = t[e];
                        this.vertices.push(new Oe(i.x, i.y, i.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
                    t.sort(function(t, e) {
                        return t.materialIndex - e.materialIndex
                    });
                    var i, r, a = this.faceVertexUvs[0],
                        o = this.faceVertexUvs[1];
                    a && a.length === e && (i = []), o && o.length === e && (r = []);
                    for (n = 0; n < e; n++) {
                        var s = t[n]._id;
                        i && i.push(a[s]), r && r.push(o[s])
                    }
                    i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    for (var i = [], r = 0; r < this.vertices.length; r++) {
                        var a = this.vertices[r];
                        i.push(a.x, a.y, a.z)
                    }
                    var o = [],
                        s = [],
                        c = {},
                        l = [],
                        u = {},
                        h = [],
                        d = {};
                    for (r = 0; r < this.faces.length; r++) {
                        var p = this.faces[r],
                            f = void 0 !== this.faceVertexUvs[0][r],
                            m = p.normal.length() > 0,
                            v = p.vertexNormals.length > 0,
                            g = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                            y = p.vertexColors.length > 0,
                            x = 0;
                        if (x = M(x = M(x = M(x = M(x = M(x = M(x = M(x = M(x, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, v), 6, g), 7, y), o.push(x), o.push(p.a, p.b, p.c), o.push(p.materialIndex), f) {
                            var b = this.faceVertexUvs[0][r];
                            o.push(S(b[0]), S(b[1]), S(b[2]))
                        }
                        if (m && o.push(E(p.normal)), v) {
                            var w = p.vertexNormals;
                            o.push(E(w[0]), E(w[1]), E(w[2]))
                        }
                        if (g && o.push(T(p.color)), y) {
                            var _ = p.vertexColors;
                            o.push(T(_[0]), T(_[1]), T(_[2]))
                        }
                    }
  
                    function M(t, e, n) {
                        return n ? t | 1 << e : t & ~(1 << e)
                    }
  
                    function E(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e])
                    }
  
                    function T(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== u[e] ? u[e] : (u[e] = l.length, l.push(t.getHex()), u[e])
                    }
  
                    function S(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== d[e] ? d[e] : (d[e] = h.length / 2, h.push(t.x, t.y), d[e])
                    }
                    return t.data = {}, t.data.vertices = i, t.data.normals = s, l.length > 0 && (t.data.colors = l), h.length > 0 && (t.data.uvs = [h]), t.data.faces = o, t
                },
                clone: function() {
                    return (new qi).copy(this)
                },
                copy: function(t) {
                    var e, n, i, r, a, o;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var s = t.vertices;
                    for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
                    var c = t.colors;
                    for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
                    var l = t.faces;
                    for (e = 0, n = l.length; e < n; e++) this.faces.push(l[e].clone());
                    for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                        var u = t.faceVertexUvs[e];
                        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = u.length; i < r; i++) {
                            var h = u[i],
                                d = [];
                            for (a = 0, o = h.length; a < o; a++) {
                                var p = h[a];
                                d.push(p.clone())
                            }
                            this.faceVertexUvs[e].push(d)
                        }
                    }
                    var f = t.morphTargets;
                    for (e = 0, n = f.length; e < n; e++) {
                        var m = {};
                        if (m.name = f[e].name, void 0 !== f[e].vertices)
                            for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++) m.vertices.push(f[e].vertices[i].clone());
                        if (void 0 !== f[e].normals)
                            for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++) m.normals.push(f[e].normals[i].clone());
                        this.morphTargets.push(m)
                    }
                    var v = t.morphNormals;
                    for (e = 0, n = v.length; e < n; e++) {
                        var g = {};
                        if (void 0 !== v[e].vertexNormals)
                            for (g.vertexNormals = [], i = 0, r = v[e].vertexNormals.length; i < r; i++) {
                                var y = v[e].vertexNormals[i],
                                    x = {};
                                x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x)
                            }
                        if (void 0 !== v[e].faceNormals)
                            for (g.faceNormals = [], i = 0, r = v[e].faceNormals.length; i < r; i++) g.faceNormals.push(v[e].faceNormals[i].clone());
                        this.morphNormals.push(g)
                    }
                    var b = t.skinWeights;
                    for (e = 0, n = b.length; e < n; e++) this.skinWeights.push(b[e].clone());
                    var w = t.skinIndices;
                    for (e = 0, n = w.length; e < n; e++) this.skinIndices.push(w[e].clone());
                    var _ = t.lineDistances;
                    for (e = 0, n = _.length; e < n; e++) this.lineDistances.push(_[e]);
                    var M = t.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var E = t.boundingSphere;
                    return null !== E && (this.boundingSphere = E.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(Yi.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Yi.prototype, {
                isBufferAttribute: !0,
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize, n *= e.itemSize;
                    for (var i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new Cn), e[n++] = a.r, e[n++] = a.g, e[n++] = a.b
                    }
                    return this
                },
                copyIndicesArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        e[n++] = a.a, e[n++] = a.b, e[n++] = a.c
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), a = new Pe), e[n++] = a.x, e[n++] = a.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), a = new Oe), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), a = new Fe), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z, e[n++] = a.w
                    }
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), $i.prototype = Object.create(Yi.prototype), $i.prototype.constructor = $i, Zi.prototype = Object.create(Yi.prototype), Zi.prototype.constructor = Zi, Ji.prototype = Object.create(Yi.prototype), Ji.prototype.constructor = Ji, Ki.prototype = Object.create(Yi.prototype), Ki.prototype.constructor = Ki, Qi.prototype = Object.create(Yi.prototype), Qi.prototype.constructor = Qi, tr.prototype = Object.create(Yi.prototype), tr.prototype.constructor = tr, er.prototype = Object.create(Yi.prototype), er.prototype.constructor = er, nr.prototype = Object.create(Yi.prototype), nr.prototype.constructor = nr, ir.prototype = Object.create(Yi.prototype), ir.prototype.constructor = ir, Object.assign(rr.prototype, {
                computeGroups: function(t) {
                    for (var e, n = [], i = void 0, r = t.faces, a = 0; a < r.length; a++) {
                        var o = r[a];
                        o.materialIndex !== i && (i = o.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), e = {
                            start: 3 * a,
                            materialIndex: i
                        })
                    }
                    void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), this.groups = n
                },
                fromGeometry: function(t) {
                    var e, n = t.faces,
                        i = t.vertices,
                        r = t.faceVertexUvs,
                        a = r[0] && r[0].length > 0,
                        o = r[1] && r[1].length > 0,
                        s = t.morphTargets,
                        c = s.length;
                    if (c > 0) {
                        e = [];
                        for (var l = 0; l < c; l++) e[l] = [];
                        this.morphTargets.position = e
                    }
                    var u, h = t.morphNormals,
                        d = h.length;
                    if (d > 0) {
                        u = [];
                        for (l = 0; l < d; l++) u[l] = [];
                        this.morphTargets.normal = u
                    }
                    var p = t.skinIndices,
                        f = t.skinWeights,
                        m = p.length === i.length,
                        v = f.length === i.length;
                    for (l = 0; l < n.length; l++) {
                        var g = n[l];
                        this.vertices.push(i[g.a], i[g.b], i[g.c]);
                        var y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var x = g.normal;
                            this.normals.push(x, x, x)
                        }
                        var b, w = g.vertexColors;
                        if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
                        else {
                            var _ = g.color;
                            this.colors.push(_, _, _)
                        }
                        if (!0 === a) void 0 !== (b = r[0][l]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new Pe, new Pe, new Pe));
                        if (!0 === o) void 0 !== (b = r[1][l]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new Pe, new Pe, new Pe));
                        for (var M = 0; M < c; M++) {
                            var E = s[M].vertices;
                            e[M].push(E[g.a], E[g.b], E[g.c])
                        }
                        for (M = 0; M < d; M++) {
                            var T = h[M].vertexNormals[l];
                            u[M].push(T.a, T.b, T.c)
                        }
                        m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                }
            });
            var or, sr, cr, lr, ur, hr, dr, pr, fr, mr, vr, gr, yr, xr, br, wr, _r, Mr, Er, Tr, Sr, Ar, Lr, Pr, Cr, Rr, Or, Ir, Nr, Dr, Ur, kr, Fr, zr = 1;
  
            function Br() {
                Object.defineProperty(this, "id", {
                    value: zr += 2
                }), this.uuid = Le.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }
            }
  
            function jr(t, e, n, i, r, a) {
                qi.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                }, this.fromBufferGeometry(new Gr(t, e, n, i, r, a)), this.mergeVertices()
            }
  
            function Gr(t, e, n, i, r, a) {
                Br.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                };
                var o = this;
                t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1;
                var s = [],
                    c = [],
                    l = [],
                    u = [],
                    h = 0,
                    d = 0;
  
                function p(t, e, n, i, r, a, p, f, m, v, g) {
                    var y, x, b = a / m,
                        w = p / v,
                        _ = a / 2,
                        M = p / 2,
                        E = f / 2,
                        T = m + 1,
                        S = v + 1,
                        A = 0,
                        L = 0,
                        P = new Oe;
                    for (x = 0; x < S; x++) {
                        var C = x * w - M;
                        for (y = 0; y < T; y++) {
                            var R = y * b - _;
                            P[t] = R * i, P[e] = C * r, P[n] = E, c.push(P.x, P.y, P.z), P[t] = 0, P[e] = 0, P[n] = f > 0 ? 1 : -1, l.push(P.x, P.y, P.z), u.push(y / m), u.push(1 - x / v), A += 1
                        }
                    }
                    for (x = 0; x < v; x++)
                        for (y = 0; y < m; y++) {
                            var O = h + y + T * x,
                                I = h + y + T * (x + 1),
                                N = h + (y + 1) + T * (x + 1),
                                D = h + (y + 1) + T * x;
                            s.push(O, I, D), s.push(I, N, D), L += 6
                        }
                    o.addGroup(d, L, g), d += L, h += A
                }
                p("z", "y", "x", -1, -1, n, e, t, a, r, 0), p("z", "y", "x", 1, -1, n, e, -t, a, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, a, 2), p("x", "z", "y", 1, -1, t, n, -e, i, a, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(s), this.addAttribute("position", new nr(c, 3)), this.addAttribute("normal", new nr(l, 3)), this.addAttribute("uv", new nr(u, 2))
            }
  
            function Hr(t, e, n, i) {
                qi.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                }, this.fromBufferGeometry(new Vr(t, e, n, i)), this.mergeVertices()
            }
  
            function Vr(t, e, n, i) {
                Br.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                var r, a, o = (t = t || 1) / 2,
                    s = (e = e || 1) / 2,
                    c = Math.floor(n) || 1,
                    l = Math.floor(i) || 1,
                    u = c + 1,
                    h = l + 1,
                    d = t / c,
                    p = e / l,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (a = 0; a < h; a++) {
                    var y = a * p - s;
                    for (r = 0; r < u; r++) {
                        var x = r * d - o;
                        m.push(x, -y, 0), v.push(0, 0, 1), g.push(r / c), g.push(1 - a / l)
                    }
                }
                for (a = 0; a < l; a++)
                    for (r = 0; r < c; r++) {
                        var b = r + u * a,
                            w = r + u * (a + 1),
                            _ = r + 1 + u * (a + 1),
                            M = r + 1 + u * a;
                        f.push(b, w, M), f.push(w, _, M)
                    }
                this.setIndex(f), this.addAttribute("position", new nr(m, 3)), this.addAttribute("normal", new nr(v, 3)), this.addAttribute("uv", new nr(g, 2))
            }
  
            function Wr(t) {
                ai.call(this), this.type = "MeshBasicMaterial", this.color = new Cn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ht, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }
  
            function Xr(t) {
                ai.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }
  
            function qr(t, e) {
                this.origin = void 0 !== t ? t : new Oe, this.direction = void 0 !== e ? e : new Oe
            }
  
            function Yr(t, e) {
                this.start = void 0 !== t ? t : new Oe, this.end = void 0 !== e ? e : new Oe
            }
  
            function $r(t, e, n) {
                this.a = void 0 !== t ? t : new Oe, this.b = void 0 !== e ? e : new Oe, this.c = void 0 !== n ? n : new Oe
            }
  
            function Zr(t, e) {
                Ui.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Br, this.material = void 0 !== e ? e : new Wr({
                    color: 16777215 * Math.random()
                }), this.drawMode = ve, this.updateMorphTargets()
            }
  
            function Jr(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }
  
            function Kr(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }
  
            function Qr() {
                var t = {};
                return {
                    get: function(e, n) {
                        var i = e.id + "," + n.id,
                            r = t[i];
                        return void 0 === r && (r = new function() {
                            var t = [],
                                e = 0,
                                n = [],
                                i = [];
                            return {
                                opaque: n,
                                transparent: i,
                                init: function() {
                                    e = 0, n.length = 0, i.length = 0
                                },
                                push: function(r, a, o, s, c) {
                                    var l = t[e];
                                    void 0 === l ? (l = {
                                        id: r.id,
                                        object: r,
                                        geometry: a,
                                        material: o,
                                        program: o.program,
                                        renderOrder: r.renderOrder,
                                        z: s,
                                        group: c
                                    }, t[e] = l) : (l.id = r.id, l.object = r, l.geometry = a, l.material = o, l.program = o.program, l.renderOrder = r.renderOrder, l.z = s, l.group = c), (!0 === o.transparent ? i : n).push(l), e++
                                },
                                sort: function() {
                                    n.length > 1 && n.sort(Jr), i.length > 1 && i.sort(Kr)
                                }
                            }
                        }, t[i] = r), r
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }
  
            function ta(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }
  
            function ea() {
                var t = new function() {
                        var t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                var n;
                                switch (e.type) {
                                    case "DirectionalLight":
                                        n = {
                                            direction: new Oe,
                                            color: new Cn,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Pe
                                        };
                                        break;
                                    case "SpotLight":
                                        n = {
                                            position: new Oe,
                                            direction: new Oe,
                                            color: new Cn,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Pe
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            position: new Oe,
                                            color: new Cn,
                                            distance: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Pe,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        };
                                        break;
                                    case "HemisphereLight":
                                        n = {
                                            direction: new Oe,
                                            skyColor: new Cn,
                                            groundColor: new Cn
                                        };
                                        break;
                                    case "RectAreaLight":
                                        n = {
                                            color: new Cn,
                                            position: new Oe,
                                            halfWidth: new Oe,
                                            halfHeight: new Oe
                                        }
                                }
                                return t[e.id] = n, n
                            }
                        }
                    },
                    e = {
                        hash: "",
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    },
                    n = new Oe,
                    i = new Ce,
                    r = new Ce;
                return {
                    setup: function(a, o, s) {
                        for (var c = 0, l = 0, u = 0, h = 0, d = 0, p = 0, f = 0, m = 0, v = s.matrixWorldInverse, g = 0, y = a.length; g < y; g++) {
                            var x = a[g],
                                b = x.color,
                                w = x.intensity,
                                _ = x.distance,
                                M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                            if (x.isAmbientLight) c += b.r * w, l += b.g * w, u += b.b * w;
                            else if (x.isDirectionalLight) {
                                if ((T = t.get(x)).color.copy(x.color).multiplyScalar(x.intensity), T.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), T.direction.sub(n), T.direction.transformDirection(v), T.shadow = x.castShadow, x.castShadow) {
                                    var E = x.shadow;
                                    T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize
                                }
                                e.directionalShadowMap[h] = M, e.directionalShadowMatrix[h] = x.shadow.matrix, e.directional[h] = T, h++
                            } else if (x.isSpotLight)(T = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), T.color.copy(b).multiplyScalar(w), T.distance = _, T.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), T.direction.sub(n), T.direction.transformDirection(v), T.coneCos = Math.cos(x.angle), T.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), T.decay = 0 === x.distance ? 0 : x.decay, T.shadow = x.castShadow, x.castShadow && (E = x.shadow, T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize), e.spotShadowMap[p] = M, e.spotShadowMatrix[p] = x.shadow.matrix, e.spot[p] = T, p++;
                            else if (x.isRectAreaLight)(T = t.get(x)).color.copy(b).multiplyScalar(w / (x.width * x.height)), T.position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), r.identity(), i.copy(x.matrixWorld), i.premultiply(v), r.extractRotation(i), T.halfWidth.set(.5 * x.width, 0, 0), T.halfHeight.set(0, .5 * x.height, 0), T.halfWidth.applyMatrix4(r), T.halfHeight.applyMatrix4(r), e.rectArea[f] = T, f++;
                            else if (x.isPointLight)(T = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), T.color.copy(x.color).multiplyScalar(x.intensity), T.distance = x.distance, T.decay = 0 === x.distance ? 0 : x.decay, T.shadow = x.castShadow, x.castShadow && (E = x.shadow, T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize, T.shadowCameraNear = E.camera.near, T.shadowCameraFar = E.camera.far), e.pointShadowMap[d] = M, e.pointShadowMatrix[d] = x.shadow.matrix, e.point[d] = T, d++;
                            else if (x.isHemisphereLight) {
                                var T;
                                (T = t.get(x)).direction.setFromMatrixPosition(x.matrixWorld), T.direction.transformDirection(v), T.direction.normalize(), T.skyColor.copy(x.color).multiplyScalar(w), T.groundColor.copy(x.groundColor).multiplyScalar(w), e.hemi[m] = T, m++
                            }
                        }
                        e.ambient[0] = c, e.ambient[1] = l, e.ambient[2] = u, e.directional.length = h, e.spot.length = p, e.rectArea.length = f, e.point.length = d, e.hemi.length = m, e.hash = h + "," + d + "," + p + "," + f + "," + m + "," + o.length
                    },
                    state: e
                }
            }
  
            function na(t, e, n) {
                var i = t.createShader(e);
                return t.shaderSource(i, n), t.compileShader(i), !1 === t.getShaderParameter(i, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(i), function(t) {
                    for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                    return e.join("\n")
                }(n)), i
            }
            Br.prototype = Object.assign(Object.create(e.prototype), {
                constructor: Br,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    Array.isArray(t) ? this.index = new(ar(t) > 65535 ? er : Qi)(t, 1) : this.index = t
                },
                addAttribute: function(t, e) {
                    return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(e)) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(t, new Yi(arguments[1], arguments[2])))
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                removeAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, n) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                    var n = this.attributes.normal;
                    void 0 !== n && ((new Ie).getNormalMatrix(t).applyToBufferAttribute(n), n.needsUpdate = !0);
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: (fr = new Ce, function(t) {
                    return fr.makeRotationX(t), this.applyMatrix(fr), this
                }),
                rotateY: (pr = new Ce, function(t) {
                    return pr.makeRotationY(t), this.applyMatrix(pr), this
                }),
                rotateZ: (dr = new Ce, function(t) {
                    return dr.makeRotationZ(t), this.applyMatrix(dr), this
                }),
                translate: (hr = new Ce, function(t, e, n) {
                    return hr.makeTranslation(t, e, n), this.applyMatrix(hr), this
                }),
                scale: (ur = new Ce, function(t, e, n) {
                    return ur.makeScale(t, e, n), this.applyMatrix(ur), this
                }),
                lookAt: (lr = new Ui, function(t) {
                    lr.lookAt(t), lr.updateMatrix(), this.applyMatrix(lr.matrix)
                }),
                center: function() {
                    this.computeBoundingBox();
                    var t = this.boundingBox.getCenter().negate();
                    return this.translate(t.x, t.y, t.z), t
                },
                setFromObject: function(t) {
                    var e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        var n = new nr(3 * e.vertices.length, 3),
                            i = new nr(3 * e.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            var r = new nr(e.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    for (var e = [], n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.addAttribute("position", new nr(e, 3)), this
                },
                updateFromObject: function(t) {
                    var e, n = t.geometry;
                    if (t.isMesh) {
                        var i = n.__directGeometry;
                        if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n);
                        i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i
                    }
                    return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new rr).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e = new Float32Array(3 * t.vertices.length);
                    if (this.addAttribute("position", new Yi(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        var n = new Float32Array(3 * t.normals.length);
                        this.addAttribute("normal", new Yi(n, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        var i = new Float32Array(3 * t.colors.length);
                        this.addAttribute("color", new Yi(i, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        var r = new Float32Array(2 * t.uvs.length);
                        this.addAttribute("uv", new Yi(r, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        var a = new Float32Array(2 * t.uvs2.length);
                        this.addAttribute("uv2", new Yi(a, 2).copyVector2sArray(t.uvs2))
                    }
                    if (t.indices.length > 0) {
                        var o = new(ar(t.indices) > 65535 ? Uint32Array : Uint16Array)(3 * t.indices.length);
                        this.setIndex(new Yi(o, 1).copyIndicesArray(t.indices))
                    }
                    for (var s in this.groups = t.groups, t.morphTargets) {
                        for (var c = [], l = t.morphTargets[s], u = 0, h = l.length; u < h; u++) {
                            var d = l[u],
                                p = new nr(3 * d.length, 3);
                            c.push(p.copyVector3sArray(d))
                        }
                        this.morphAttributes[s] = c
                    }
                    if (t.skinIndices.length > 0) {
                        var f = new nr(4 * t.skinIndices.length, 4);
                        this.addAttribute("skinIndex", f.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        var m = new nr(4 * t.skinWeights.length, 4);
                        this.addAttribute("skinWeight", m.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new ci);
                    var t = this.attributes.position;
                    void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: (sr = new ci, cr = new Oe, function() {
                    null === this.boundingSphere && (this.boundingSphere = new li);
                    var t = this.attributes.position;
                    if (t) {
                        var e = this.boundingSphere.center;
                        sr.setFromBufferAttribute(t), sr.getCenter(e);
                        for (var n = 0, i = 0, r = t.count; i < r; i++) cr.x = t.getX(i), cr.y = t.getY(i), cr.z = t.getZ(i), n = Math.max(n, e.distanceToSquared(cr));
                        this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index,
                        e = this.attributes,
                        n = this.groups;
                    if (e.position) {
                        var i = e.position.array;
                        if (void 0 === e.normal) this.addAttribute("normal", new Yi(new Float32Array(i.length), 3));
                        else
                            for (var r = e.normal.array, a = 0, o = r.length; a < o; a++) r[a] = 0;
                        var s, c, l, u = e.normal.array,
                            h = new Oe,
                            d = new Oe,
                            p = new Oe,
                            f = new Oe,
                            m = new Oe;
                        if (t) {
                            var v = t.array;
                            0 === n.length && this.addGroup(0, v.length);
                            for (var g = 0, y = n.length; g < y; ++g) {
                                var x = n[g],
                                    b = x.start;
                                for (a = b, o = b + x.count; a < o; a += 3) s = 3 * v[a + 0], c = 3 * v[a + 1], l = 3 * v[a + 2], h.fromArray(i, s), d.fromArray(i, c), p.fromArray(i, l), f.subVectors(p, d), m.subVectors(h, d), f.cross(m), u[s] += f.x, u[s + 1] += f.y, u[s + 2] += f.z, u[c] += f.x, u[c + 1] += f.y, u[c + 2] += f.z, u[l] += f.x, u[l + 1] += f.y, u[l + 2] += f.z
                            }
                        } else
                            for (a = 0, o = i.length; a < o; a += 9) h.fromArray(i, a), d.fromArray(i, a + 3), p.fromArray(i, a + 6), f.subVectors(p, d), m.subVectors(h, d), f.cross(m), u[a] = f.x, u[a + 1] = f.y, u[a + 2] = f.z, u[a + 3] = f.x, u[a + 4] = f.y, u[a + 5] = f.z, u[a + 6] = f.x, u[a + 7] = f.y, u[a + 8] = f.z;
                        this.normalizeNormals(), e.normal.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (t && t.isBufferGeometry) {
                        void 0 === e && (e = 0);
                        var n = this.attributes;
                        for (var i in n)
                            if (void 0 !== t.attributes[i])
                                for (var r = n[i].array, a = t.attributes[i], o = a.array, s = 0, c = a.itemSize * e; s < o.length; s++, c++) r[c] = o[s];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
                },
                normalizeNormals: (or = new Oe, function() {
                    for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++) or.x = t.getX(e), or.y = t.getY(e), or.z = t.getZ(e), or.normalize(), t.setXYZ(e, or.x, or.y, or.z)
                }),
                toNonIndexed: function() {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var t = new Br,
                        e = this.index.array,
                        n = this.attributes;
                    for (var i in n) {
                        for (var r = n[i], a = r.array, o = r.itemSize, s = new a.constructor(e.length * o), c = 0, l = 0, u = 0, h = e.length; u < h; u++) {
                            c = e[u] * o;
                            for (var d = 0; d < o; d++) s[l++] = a[c++]
                        }
                        t.addAttribute(i, new Yi(s, o))
                    }
                    return t
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var i = this.index;
                    if (null !== i) {
                        var r = Array.prototype.slice.call(i.array);
                        t.data.index = {
                            type: i.array.constructor.name,
                            array: r
                        }
                    }
                    var a = this.attributes;
                    for (var n in a) {
                        var o = a[n];
                        r = Array.prototype.slice.call(o.array);
                        t.data.attributes[n] = {
                            itemSize: o.itemSize,
                            type: o.array.constructor.name,
                            array: r,
                            normalized: o.normalized
                        }
                    }
                    var s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    var c = this.boundingSphere;
                    return null !== c && (t.data.boundingSphere = {
                        center: c.center.toArray(),
                        radius: c.radius
                    }), t
                },
                clone: function() {
                    return (new Br).copy(this)
                },
                copy: function(t) {
                    var e, n, i;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var r = t.index;
                    null !== r && this.setIndex(r.clone());
                    var a = t.attributes;
                    for (e in a) {
                        var o = a[e];
                        this.addAttribute(e, o.clone())
                    }
                    var s = t.morphAttributes;
                    for (e in s) {
                        var c = [],
                            l = s[e];
                        for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
                        this.morphAttributes[e] = c
                    }
                    var u = t.groups;
                    for (n = 0, i = u.length; n < i; n++) {
                        var h = u[n];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    var d = t.boundingBox;
                    null !== d && (this.boundingBox = d.clone());
                    var p = t.boundingSphere;
                    return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), jr.prototype = Object.create(qi.prototype), jr.prototype.constructor = jr, Gr.prototype = Object.create(Br.prototype), Gr.prototype.constructor = Gr, Hr.prototype = Object.create(qi.prototype), Hr.prototype.constructor = Hr, Vr.prototype = Object.create(Br.prototype), Vr.prototype.constructor = Vr, Wr.prototype = Object.create(ai.prototype), Wr.prototype.constructor = Wr, Wr.prototype.isMeshBasicMaterial = !0, Wr.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            }, Xr.prototype = Object.create(ai.prototype), Xr.prototype.constructor = Xr, Xr.prototype.isShaderMaterial = !0, Xr.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Nn.clone(t.uniforms), this.defines = t.defines, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
            }, Xr.prototype.toJSON = function(t) {
                var e = ai.prototype.toJSON.call(this, t);
                return e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
            }, Object.assign(qr.prototype, {
                set: function(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                },
                at: function(t, e) {
                    return (e || new Oe).copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                },
                recast: (Tr = new Oe, function(t) {
                    return this.origin.copy(this.at(t, Tr)), this
                }),
                closestPointToPoint: function(t, e) {
                    var n = e || new Oe;
                    n.subVectors(t, this.origin);
                    var i = n.dot(this.direction);
                    return i < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(i).add(this.origin)
                },
                distanceToPoint: function(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: (Er = new Oe, function(t) {
                    var e = Er.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (Er.copy(this.direction).multiplyScalar(e).add(this.origin), Er.distanceToSquared(t))
                }),
                distanceSqToSegment: (wr = new Oe, _r = new Oe, Mr = new Oe, function(t, e, n, i) {
                    wr.copy(t).add(e).multiplyScalar(.5), _r.copy(e).sub(t).normalize(), Mr.copy(this.origin).sub(wr);
                    var r, a, o, s, c = .5 * t.distanceTo(e),
                        l = -this.direction.dot(_r),
                        u = Mr.dot(this.direction),
                        h = -Mr.dot(_r),
                        d = Mr.lengthSq(),
                        p = Math.abs(1 - l * l);
                    if (p > 0)
                        if (a = l * u - h, s = c * p, (r = l * h - u) >= 0)
                            if (a >= -s)
                                if (a <= s) {
                                    var f = 1 / p;
                                    o = (r *= f) * (r + l * (a *= f) + 2 * u) + a * (l * r + a + 2 * h) + d
                                } else a = c, o = -(r = Math.max(0, -(l * a + u))) * r + a * (a + 2 * h) + d;
                    else a = -c, o = -(r = Math.max(0, -(l * a + u))) * r + a * (a + 2 * h) + d;
                    else a <= -s ? o = -(r = Math.max(0, -(-l * c + u))) * r + (a = r > 0 ? -c : Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d : a <= s ? (r = 0, o = (a = Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d) : o = -(r = Math.max(0, -(l * c + u))) * r + (a = r > 0 ? c : Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d;
                    else a = l > 0 ? -c : c, o = -(r = Math.max(0, -(l * a + u))) * r + a * (a + 2 * h) + d;
                    return n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy(_r).multiplyScalar(a).add(wr), o
                }),
                intersectSphere: (br = new Oe, function(t, e) {
                    br.subVectors(t.center, this.origin);
                    var n = br.dot(this.direction),
                        i = br.dot(br) - n * n,
                        r = t.radius * t.radius;
                    if (i > r) return null;
                    var a = Math.sqrt(r - i),
                        o = n - a,
                        s = n + a;
                    return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e)
                }),
                intersectsSphere: function(t) {
                    return this.distanceToPoint(t.center) <= t.radius
                },
                distanceToPlane: function(t) {
                    var e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null
                },
                intersectPlane: function(t, e) {
                    var n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e)
                },
                intersectsPlane: function(t) {
                    var e = t.distanceToPoint(this.origin);
                    return 0 === e || t.normal.dot(this.direction) * e < 0
                },
                intersectBox: function(t, e) {
                    var n, i, r, a, o, s, c = 1 / this.direction.x,
                        l = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return c >= 0 ? (n = (t.min.x - h.x) * c, i = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, i = (t.min.x - h.x) * c), l >= 0 ? (r = (t.min.y - h.y) * l, a = (t.max.y - h.y) * l) : (r = (t.max.y - h.y) * l, a = (t.min.y - h.y) * l), n > a || r > i ? null : ((r > n || n != n) && (n = r), (a < i || i != i) && (i = a), u >= 0 ? (o = (t.min.z - h.z) * u, s = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, s = (t.min.z - h.z) * u), n > s || o > i ? null : ((o > n || n != n) && (n = o), (s < i || i != i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                },
                intersectsBox: (xr = new Oe, function(t) {
                    return null !== this.intersectBox(t, xr)
                }),
                intersectTriangle: (mr = new Oe, vr = new Oe, gr = new Oe, yr = new Oe, function(t, e, n, i, r) {
                    vr.subVectors(e, t), gr.subVectors(n, t), yr.crossVectors(vr, gr);
                    var a, o = this.direction.dot(yr);
                    if (o > 0) {
                        if (i) return null;
                        a = 1
                    } else {
                        if (!(o < 0)) return null;
                        a = -1, o = -o
                    }
                    mr.subVectors(this.origin, t);
                    var s = a * this.direction.dot(gr.crossVectors(mr, gr));
                    if (s < 0) return null;
                    var c = a * this.direction.dot(vr.cross(mr));
                    if (c < 0) return null;
                    if (s + c > o) return null;
                    var l = -a * mr.dot(yr);
                    return l < 0 ? null : this.at(l / o, r)
                }),
                applyMatrix4: function(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                },
                equals: function(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            }), Object.assign(Yr.prototype, {
                set: function(t, e) {
                    return this.start.copy(t), this.end.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.start.copy(t.start), this.end.copy(t.end), this
                },
                getCenter: function(t) {
                    return (t || new Oe).addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(t) {
                    return (t || new Oe).subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(t, e) {
                    var n = e || new Oe;
                    return this.delta(n).multiplyScalar(t).add(this.start)
                },
                closestPointToPointParameter: (Sr = new Oe, Ar = new Oe, function(t, e) {
                    Sr.subVectors(t, this.start), Ar.subVectors(this.end, this.start);
                    var n = Ar.dot(Ar),
                        i = Ar.dot(Sr) / n;
                    return e && (i = Le.clamp(i, 0, 1)), i
                }),
                closestPointToPoint: function(t, e, n) {
                    var i = this.closestPointToPointParameter(t, e),
                        r = n || new Oe;
                    return this.delta(r).multiplyScalar(i).add(this.start)
                },
                applyMatrix4: function(t) {
                    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                },
                equals: function(t) {
                    return t.start.equals(this.start) && t.end.equals(this.end)
                }
            }), Object.assign($r, {
                normal: (Or = new Oe, function(t, e, n, i) {
                    var r = i || new Oe;
                    r.subVectors(n, e), Or.subVectors(t, e), r.cross(Or);
                    var a = r.lengthSq();
                    return a > 0 ? r.multiplyScalar(1 / Math.sqrt(a)) : r.set(0, 0, 0)
                }),
                barycoordFromPoint: (Pr = new Oe, Cr = new Oe, Rr = new Oe, function(t, e, n, i, r) {
                    Pr.subVectors(i, e), Cr.subVectors(n, e), Rr.subVectors(t, e);
                    var a = Pr.dot(Pr),
                        o = Pr.dot(Cr),
                        s = Pr.dot(Rr),
                        c = Cr.dot(Cr),
                        l = Cr.dot(Rr),
                        u = a * c - o * o,
                        h = r || new Oe;
                    if (0 === u) return h.set(-2, -1, -1);
                    var d = 1 / u,
                        p = (c * s - o * l) * d,
                        f = (a * l - o * s) * d;
                    return h.set(1 - p - f, f, p)
                }),
                containsPoint: (Lr = new Oe, function(t, e, n, i) {
                    var r = $r.barycoordFromPoint(t, e, n, i, Lr);
                    return r.x >= 0 && r.y >= 0 && r.x + r.y <= 1
                })
            }), Object.assign($r.prototype, {
                set: function(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                },
                setFromPointsAndIndices: function(t, e, n, i) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                },
                area: (kr = new Oe, Fr = new Oe, function() {
                    return kr.subVectors(this.c, this.b), Fr.subVectors(this.a, this.b), .5 * kr.cross(Fr).length()
                }),
                midpoint: function(t) {
                    return (t || new Oe).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                normal: function(t) {
                    return $r.normal(this.a, this.b, this.c, t)
                },
                plane: function(t) {
                    return (t || new ui).setFromCoplanarPoints(this.a, this.b, this.c)
                },
                barycoordFromPoint: function(t, e) {
                    return $r.barycoordFromPoint(t, this.a, this.b, this.c, e)
                },
                containsPoint: function(t) {
                    return $r.containsPoint(t, this.a, this.b, this.c)
                },
                closestPointToPoint: (Ir = new ui, Nr = [new Yr, new Yr, new Yr], Dr = new Oe, Ur = new Oe, function(t, e) {
                    var n = e || new Oe,
                        i = 1 / 0;
                    if (Ir.setFromCoplanarPoints(this.a, this.b, this.c), Ir.projectPoint(t, Dr), !0 === this.containsPoint(Dr)) n.copy(Dr);
                    else {
                        Nr[0].set(this.a, this.b), Nr[1].set(this.b, this.c), Nr[2].set(this.c, this.a);
                        for (var r = 0; r < Nr.length; r++) {
                            Nr[r].closestPointToPoint(Dr, !0, Ur);
                            var a = Dr.distanceToSquared(Ur);
                            a < i && (i = a, n.copy(Ur))
                        }
                    }
                    return n
                }),
                equals: function(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }), Zr.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Zr,
                isMesh: !0,
                setDrawMode: function(t) {
                    this.drawMode = t
                },
                copy: function(t) {
                    return Ui.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
                },
                updateMorphTargets: function() {
                    var t, e, n, i = this.geometry;
                    if (i.isBufferGeometry) {
                        var r = i.morphAttributes,
                            a = Object.keys(r);
                        if (a.length > 0) {
                            var o = r[a[0]];
                            if (void 0 !== o)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++) n = o[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    } else {
                        var s = i.morphTargets;
                        if (void 0 !== s && s.length > 0)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                    }
                },
                raycast: function() {
                    var t = new Ce,
                        e = new qr,
                        n = new li,
                        i = new Oe,
                        r = new Oe,
                        a = new Oe,
                        o = new Oe,
                        s = new Oe,
                        c = new Oe,
                        l = new Pe,
                        u = new Pe,
                        h = new Pe,
                        d = new Oe,
                        p = new Oe,
                        f = new Oe;
  
                    function m(t, e, n, i, r, a, o) {
                        return $r.barycoordFromPoint(t, e, n, i, d), r.multiplyScalar(d.x), a.multiplyScalar(d.y), o.multiplyScalar(d.z), r.add(a).add(o), r.clone()
                    }
  
                    function v(t, e, n, i, r, a, o, s) {
                        if (null === (e.side === C ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, e.side !== R, s))) return null;
                        f.copy(s), f.applyMatrix4(t.matrixWorld);
                        var c = n.ray.origin.distanceTo(f);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: f.clone(),
                            object: t
                        }
                    }
  
                    function g(t, e, n, o, s, c, d, f) {
                        i.fromBufferAttribute(o, c), r.fromBufferAttribute(o, d), a.fromBufferAttribute(o, f);
                        var g = v(t, t.material, e, n, i, r, a, p);
                        return g && (s && (l.fromBufferAttribute(s, c), u.fromBufferAttribute(s, d), h.fromBufferAttribute(s, f), g.uv = m(p, i, r, a, l, u, h)), g.face = new zi(c, d, f, $r.normal(i, r, a)), g.faceIndex = c), g
                    }
                    return function(d, f) {
                        var y, x = this.geometry,
                            b = this.material,
                            w = this.matrixWorld;
                        if (void 0 !== b && (null === x.boundingSphere && x.computeBoundingSphere(), n.copy(x.boundingSphere), n.applyMatrix4(w), !1 !== d.ray.intersectsSphere(n) && (t.getInverse(w), e.copy(d.ray).applyMatrix4(t), null === x.boundingBox || !1 !== e.intersectsBox(x.boundingBox))))
                            if (x.isBufferGeometry) {
                                var _, M, E, T, S, A = x.index,
                                    L = x.attributes.position,
                                    P = x.attributes.uv;
                                if (null !== A)
                                    for (T = 0, S = A.count; T < S; T += 3) _ = A.getX(T), M = A.getX(T + 1), E = A.getX(T + 2), (y = g(this, d, e, L, P, _, M, E)) && (y.faceIndex = Math.floor(T / 3), f.push(y));
                                else if (void 0 !== L)
                                    for (T = 0, S = L.count; T < S; T += 3)(y = g(this, d, e, L, P, _ = T, M = T + 1, E = T + 2)) && (y.index = _, f.push(y))
                            } else if (x.isGeometry) {
                            var C, R, O, I, N = Array.isArray(b),
                                D = x.vertices,
                                U = x.faces,
                                k = x.faceVertexUvs[0];
                            k.length > 0 && (I = k);
                            for (var F = 0, z = U.length; F < z; F++) {
                                var B = U[F],
                                    j = N ? b[B.materialIndex] : b;
                                if (void 0 !== j) {
                                    if (C = D[B.a], R = D[B.b], O = D[B.c], !0 === j.morphTargets) {
                                        var G = x.morphTargets,
                                            H = this.morphTargetInfluences;
                                        i.set(0, 0, 0), r.set(0, 0, 0), a.set(0, 0, 0);
                                        for (var V = 0, W = G.length; V < W; V++) {
                                            var X = H[V];
                                            if (0 !== X) {
                                                var q = G[V].vertices;
                                                i.addScaledVector(o.subVectors(q[B.a], C), X), r.addScaledVector(s.subVectors(q[B.b], R), X), a.addScaledVector(c.subVectors(q[B.c], O), X)
                                            }
                                        }
                                        i.add(C), r.add(R), a.add(O), C = i, R = r, O = a
                                    }
                                    if (y = v(this, j, d, e, C, R, O, p)) {
                                        if (I && I[F]) {
                                            var Y = I[F];
                                            l.copy(Y[0]), u.copy(Y[1]), h.copy(Y[2]), y.uv = m(p, C, R, O, l, u, h)
                                        }
                                        y.face = B, y.faceIndex = F, f.push(y)
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });
            var ia, ra, aa, oa, sa, ca, la, ua, ha, da, pa, fa, ma, va, ga = 0;
  
            function ya(t) {
                switch (t) {
                    case xe:
                        return ["Linear", "( value )"];
                    case be:
                        return ["sRGB", "( value )"];
                    case _e:
                        return ["RGBE", "( value )"];
                    case Me:
                        return ["RGBM", "( value, 7.0 )"];
                    case Ee:
                        return ["RGBM", "( value, 16.0 )"];
                    case Te:
                        return ["RGBD", "( value, 256.0 )"];
                    case we:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + t)
                }
            }
  
            function xa(t, e) {
                var n = ya(e);
                return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }
  
            function ba(t) {
                return "" !== t
            }
  
            function wa(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            }
  
            function _a(t) {
                return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(t, e) {
                    var n = Dn[e];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                    return _a(n)
                })
            }
  
            function Ma(t) {
                return t.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, n, i) {
                    for (var r = "", a = parseInt(e); a < parseInt(n); a++) r += i.replace(/\[ i \]/g, "[ " + a + " ]");
                    return r
                })
            }
  
            function Ea(t, e, n, i, r, a) {
                var o = t.context,
                    s = i.defines,
                    c = r.vertexShader,
                    l = r.fragmentShader,
                    u = "SHADOWMAP_TYPE_BASIC";
                a.shadowMapType === A ? u = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === L && (u = "SHADOWMAP_TYPE_PCF_SOFT");
                var h = "ENVMAP_TYPE_CUBE",
                    d = "ENVMAP_MODE_REFLECTION",
                    p = "ENVMAP_BLENDING_MULTIPLY";
                if (a.envMap) {
                    switch (i.envMap.mapping) {
                        case xt:
                        case bt:
                            h = "ENVMAP_TYPE_CUBE";
                            break;
                        case Et:
                        case Tt:
                            h = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case wt:
                        case _t:
                            h = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case Mt:
                            h = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (i.envMap.mapping) {
                        case bt:
                        case _t:
                            d = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (i.combine) {
                        case ht:
                            p = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case dt:
                            p = "ENVMAP_BLENDING_MIX";
                            break;
                        case pt:
                            p = "ENVMAP_BLENDING_ADD"
                    }
                }
                var f, m, v, g, y, x, b, w, _ = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    M = (f = i.extensions, m = a, v = e, [(f = f || {}).derivatives || m.envMapCubeUV || m.bumpMap || m.normalMap || m.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (f.fragDepth || m.logarithmicDepthBuffer) && v.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", f.drawBuffers && v.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (f.shaderTextureLOD || m.envMap) && v.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ba).join("\n")),
                    E = function(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            !1 !== i && e.push("#define " + n + " " + i)
                        }
                        return e.join("\n")
                    }(s),
                    T = o.createProgram();
                i.isRawShaderMaterial ? ((g = [E].filter(ba).join("\n")).length > 0 && (g += "\n"), (y = [M, E].filter(ba).join("\n")).length > 0 && (y += "\n")) : (g = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, E, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + a.numClippingPlanes, a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ba).join("\n"), y = [M, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, E, a.alphaTest ? "#define ALPHATEST " + a.alphaTest : "", "#define GAMMA_FACTOR " + _, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + h : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + p : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + a.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (a.numClippingPlanes - a.numClipIntersection), a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && e.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== ft ? "#define TONE_MAPPING" : "", a.toneMapping !== ft ? Dn.tonemapping_pars_fragment : "", a.toneMapping !== ft ? function(t, e) {
                    var n;
                    switch (e) {
                        case mt:
                            n = "Linear";
                            break;
                        case vt:
                            n = "Reinhard";
                            break;
                        case gt:
                            n = "Uncharted2";
                            break;
                        case yt:
                            n = "OptimizedCineon";
                            break;
                        default:
                            throw new Error("unsupported toneMapping: " + e)
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? Dn.encodings_pars_fragment : "", a.mapEncoding ? xa("mapTexelToLinear", a.mapEncoding) : "", a.envMapEncoding ? xa("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? xa("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? (x = "linearToOutputTexel", b = a.outputEncoding, w = ya(b), "vec4 " + x + "( vec4 value ) { return LinearTo" + w[0] + w[1] + "; }") : "", a.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(ba).join("\n")), c = wa(c = _a(c), a), l = wa(l = _a(l), a), i.isShaderMaterial || (c = Ma(c), l = Ma(l));
                var S = g + c,
                    P = y + l,
                    C = na(o, o.VERTEX_SHADER, S),
                    R = na(o, o.FRAGMENT_SHADER, P);
                o.attachShader(T, C), o.attachShader(T, R), void 0 !== i.index0AttributeName ? o.bindAttribLocation(T, 0, i.index0AttributeName) : !0 === a.morphTargets && o.bindAttribLocation(T, 0, "position"), o.linkProgram(T);
                var O, I, N = o.getProgramInfoLog(T),
                    D = o.getShaderInfoLog(C),
                    U = o.getShaderInfoLog(R),
                    k = !0,
                    F = !0;
                return !1 === o.getProgramParameter(T, o.LINK_STATUS) ? (k = !1, console.error("THREE.WebGLProgram: shader error: ", o.getError(), "gl.VALIDATE_STATUS", o.getProgramParameter(T, o.VALIDATE_STATUS), "gl.getProgramInfoLog", N, D, U)) : "" !== N ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", N) : "" !== D && "" !== U || (F = !1), F && (this.diagnostics = {
                    runnable: k,
                    material: i,
                    programLog: N,
                    vertexShader: {
                        log: D,
                        prefix: g
                    },
                    fragmentShader: {
                        log: U,
                        prefix: y
                    }
                }), o.deleteShader(C), o.deleteShader(R), this.getUniforms = function() {
                    return void 0 === O && (O = new Ln(o, T, t)), O
                }, this.getAttributes = function() {
                    return void 0 === I && (I = function(t, e) {
                        for (var n = {}, i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0; r < i; r++) {
                            var a = t.getActiveAttrib(e, r).name;
                            n[a] = t.getAttribLocation(e, a)
                        }
                        return n
                    }(o, T)), I
                }, this.destroy = function() {
                    o.deleteProgram(T), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.id = ga++, this.code = n, this.usedTimes = 1, this.program = T, this.vertexShader = C, this.fragmentShader = R, this
            }
  
            function Ta(t, e, n) {
                var i = [],
                    r = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow"
                    },
                    a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
  
                function o(t, e) {
                    var n;
                    return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = xe, n === xe && e && (n = we), n
                }
                this.getParameters = function(e, i, a, s, c, l, u) {
                    var h = r[e.type],
                        d = u.isSkinnedMesh ? function(t) {
                            var e = t.skeleton.bones;
                            if (n.floatVertexTextures) return 1024;
                            var i = n.maxVertexUniforms,
                                r = Math.floor((i - 20) / 4),
                                a = Math.min(r, e.length);
                            return a < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + a + "."), 0) : a
                        }(u) : 0,
                        p = n.precision;
                    null !== e.precision && (p = n.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", p, "instead.");
                    var f = t.getRenderTarget();
                    return {
                        shaderID: h,
                        precision: p,
                        supportsVertexTextures: n.vertexTextures,
                        outputEncoding: o(f ? f.texture : null, t.gammaOutput),
                        map: !!e.map,
                        mapEncoding: o(e.map, t.gammaInput),
                        envMap: !!e.envMap,
                        envMapMode: e.envMap && e.envMap.mapping,
                        envMapEncoding: o(e.envMap, t.gammaInput),
                        envMapCubeUV: !!e.envMap && (e.envMap.mapping === Et || e.envMap.mapping === Tt),
                        lightMap: !!e.lightMap,
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: o(e.emissiveMap, t.gammaInput),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        combine: e.combine,
                        vertexColors: e.vertexColors,
                        fog: !!s,
                        useFog: e.fog,
                        fogExp: s && s.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                        skinning: e.skinning && d > 0,
                        maxBones: d,
                        useVertexTexture: n.floatVertexTextures,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: i.directional.length,
                        numPointLights: i.point.length,
                        numSpotLights: i.spot.length,
                        numRectAreaLights: i.rectArea.length,
                        numHemiLights: i.hemi.length,
                        numClippingPlanes: c,
                        numClipIntersection: l,
                        dithering: e.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && u.receiveShadow && a.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: t.toneMapping,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: e.side === R,
                        flipSided: e.side === C,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking
                    }
                }, this.getProgramCode = function(e, n) {
                    var i = [];
                    if (n.shaderID ? i.push(n.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) i.push(r), i.push(e.defines[r]);
                    for (var o = 0; o < a.length; o++) i.push(n[a[o]]);
                    return i.push(e.onBeforeCompile.toString()), i.push(t.gammaOutput), i.join()
                }, this.acquireProgram = function(n, r, a, o) {
                    for (var s, c = 0, l = i.length; c < l; c++) {
                        var u = i[c];
                        if (u.code === o) {
                            ++(s = u).usedTimes;
                            break
                        }
                    }
                    return void 0 === s && (s = new Ea(t, e, o, n, r, a), i.push(s)), s
                }, this.releaseProgram = function(t) {
                    if (0 == --t.usedTimes) {
                        var e = i.indexOf(t);
                        i[e] = i[i.length - 1], i.pop(), t.destroy()
                    }
                }, this.programs = i
            }
  
            function Sa(t, e, n, i, r, a, o) {
                var s = "undefined" != typeof WebGL2RenderingContext && t instanceof window.WebGL2RenderingContext,
                    c = {};
  
                function l(t, e) {
                    if (t.width > e || t.height > e) {
                        var n = e / Math.max(t.width, t.height),
                            i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return i.width = Math.floor(t.width * n), i.height = Math.floor(t.height * n), i.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t), i
                    }
                    return t
                }
  
                function u(t) {
                    return Le.isPowerOfTwo(t.width) && Le.isPowerOfTwo(t.height)
                }
  
                function h(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== Pt && t.minFilter !== Ot
                }
  
                function d(e) {
                    return e === Pt || e === Ct || e === Rt ? t.NEAREST : t.LINEAR
                }
  
                function p(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", p),
                        function(e) {
                            var n = i.get(e);
                            if (e.image && n.__image__webglTextureCube) t.deleteTexture(n.__image__webglTextureCube);
                            else {
                                if (void 0 === n.__webglInit) return;
                                t.deleteTexture(n.__webglTexture)
                            }
                            i.remove(e)
                        }(n), n.isVideoTexture && delete c[n.id], o.textures--
                }
  
                function f(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", f),
                        function(e) {
                            var n = i.get(e),
                                r = i.get(e.texture);
                            if (!e) return;
                            void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLRenderTargetCube)
                                for (var a = 0; a < 6; a++) t.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                            else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                            i.remove(e.texture), i.remove(e)
                        }(n), o.textures--
                }
  
                function m(e, d) {
                    var f = i.get(e);
                    if (e.version > 0 && f.__version !== e.version) {
                        var m = e.image;
                        if (void 0 === m) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                        else {
                            if (!1 !== m.complete) return void
                            function(e, i, d) {
                                void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", p), e.__webglTexture = t.createTexture(), i.isVideoTexture && (c[i.id] = i), o.textures++);
                                n.activeTexture(t.TEXTURE0 + d), n.bindTexture(t.TEXTURE_2D, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
                                var f = l(i.image, r.maxTextureSize);
                                m = i, (m.wrapS !== At || m.wrapT !== At || m.minFilter !== Pt && m.minFilter !== Ot) && !1 === u(f) && (f = function(t) {
                                    if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap) {
                                        var e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                                        return e.width = Le.floorPowerOfTwo(t.width), e.height = Le.floorPowerOfTwo(t.height), e.getContext("2d").drawImage(t, 0, 0, e.width, e.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + e.width + "x" + e.height, t), e
                                    }
                                    return t
                                }(f));
                                var m;
                                var g = u(f),
                                    y = a.convert(i.format),
                                    x = a.convert(i.type);
                                v(t.TEXTURE_2D, i, g);
                                var b, w = i.mipmaps;
                                if (i.isDepthTexture) {
                                    var _ = t.DEPTH_COMPONENT;
                                    if (i.type === jt) {
                                        if (!s) throw new Error("Float Depth Texture only supported in WebGL2.0");
                                        _ = t.DEPTH_COMPONENT32F
                                    } else s && (_ = t.DEPTH_COMPONENT16);
                                    i.format === Qt && _ === t.DEPTH_COMPONENT && i.type !== Ft && i.type !== Bt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = Ft, x = a.convert(i.type)), i.format === te && (_ = t.DEPTH_STENCIL, i.type !== Xt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Xt, x = a.convert(i.type))), n.texImage2D(t.TEXTURE_2D, 0, _, f.width, f.height, 0, y, x, null)
                                } else if (i.isDataTexture)
                                    if (w.length > 0 && g) {
                                        for (var M = 0, E = w.length; M < E; M++) b = w[M], n.texImage2D(t.TEXTURE_2D, M, y, b.width, b.height, 0, y, x, b.data);
                                        i.generateMipmaps = !1
                                    } else n.texImage2D(t.TEXTURE_2D, 0, y, f.width, f.height, 0, y, x, f.data);
                                else if (i.isCompressedTexture)
                                    for (var M = 0, E = w.length; M < E; M++) b = w[M], i.format !== $t && i.format !== Yt ? n.getCompressedTextureFormats().indexOf(y) > -1 ? n.compressedTexImage2D(t.TEXTURE_2D, M, y, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, M, y, b.width, b.height, 0, y, x, b.data);
                                else if (w.length > 0 && g) {
                                    for (var M = 0, E = w.length; M < E; M++) b = w[M], n.texImage2D(t.TEXTURE_2D, M, y, y, x, b);
                                    i.generateMipmaps = !1
                                } else n.texImage2D(t.TEXTURE_2D, 0, y, y, x, f);
                                h(i, g) && t.generateMipmap(t.TEXTURE_2D);
                                e.__version = i.version, i.onUpdate && i.onUpdate(i)
                            }(f, e, d);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                        }
                    }
                    n.activeTexture(t.TEXTURE0 + d), n.bindTexture(t.TEXTURE_2D, f.__webglTexture)
                }
  
                function v(n, o, s) {
                    var c;
                    if (s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, a.convert(o.wrapS)), t.texParameteri(n, t.TEXTURE_WRAP_T, a.convert(o.wrapT)), t.texParameteri(n, t.TEXTURE_MAG_FILTER, a.convert(o.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, a.convert(o.minFilter))) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), o.wrapS === At && o.wrapT === At || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", o), t.texParameteri(n, t.TEXTURE_MAG_FILTER, d(o.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, d(o.minFilter)), o.minFilter !== Pt && o.minFilter !== Ot && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", o)), c = e.get("EXT_texture_filter_anisotropic")) {
                        if (o.type === jt && null === e.get("OES_texture_float_linear")) return;
                        if (o.type === Gt && null === e.get("OES_texture_half_float_linear")) return;
                        (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
                    }
                }
  
                function g(e, r, o, s) {
                    var c = a.convert(r.texture.format),
                        l = a.convert(r.texture.type);
                    n.texImage2D(s, 0, c, r.width, r.height, 0, c, l, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, o, s, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
                }
  
                function y(e, n) {
                    t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : n.depthBuffer && n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height), t.bindRenderbuffer(t.RENDERBUFFER, null)
                }
  
                function x(e) {
                    var n = i.get(e),
                        r = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, n) {
                            if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(t.FRAMEBUFFER, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), m(n.depthTexture, 0);
                            var r = i.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === Qt) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                            else {
                                if (n.depthTexture.format !== te) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
                            }
                        }(n.__webglFramebuffer, e)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (var a = 0; a < 6; a++) t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[a]), n.__webglDepthbuffer[a] = t.createRenderbuffer(), y(n.__webglDepthbuffer[a], e)
                    } else t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), y(n.__webglDepthbuffer, e);
                    t.bindFramebuffer(t.FRAMEBUFFER, null)
                }
                this.setTexture2D = m, this.setTextureCube = function(e, s) {
                    var c = i.get(e);
                    if (6 === e.image.length)
                        if (e.version > 0 && c.__version !== e.version) {
                            c.__image__webglTextureCube || (e.addEventListener("dispose", p), c.__image__webglTextureCube = t.createTexture(), o.textures++), n.activeTexture(t.TEXTURE0 + s), n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                            for (var d = e && e.isCompressedTexture, f = e.image[0] && e.image[0].isDataTexture, m = [], g = 0; g < 6; g++) m[g] = d || f ? f ? e.image[g].image : e.image[g] : l(e.image[g], r.maxCubemapSize);
                            var y = u(m[0]),
                                x = a.convert(e.format),
                                b = a.convert(e.type);
                            for (v(t.TEXTURE_CUBE_MAP, e, y), g = 0; g < 6; g++)
                                if (d)
                                    for (var w, _ = m[g].mipmaps, M = 0, E = _.length; M < E; M++) w = _[M], e.format !== $t && e.format !== Yt ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, M, x, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, M, x, w.width, w.height, 0, x, b, w.data);
                                else f ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, x, m[g].width, m[g].height, 0, x, b, m[g].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, x, x, b, m[g]);
                            h(e, y) && t.generateMipmap(t.TEXTURE_CUBE_MAP), c.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else n.activeTexture(t.TEXTURE0 + s), n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
                }, this.setTextureCubeDynamic = function(e, r) {
                    n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture)
                }, this.setupRenderTarget = function(e) {
                    var r = i.get(e),
                        a = i.get(e.texture);
                    e.addEventListener("dispose", f), a.__webglTexture = t.createTexture(), o.textures++;
                    var s = !0 === e.isWebGLRenderTargetCube,
                        c = u(e);
                    if (s) {
                        r.__webglFramebuffer = [];
                        for (var l = 0; l < 6; l++) r.__webglFramebuffer[l] = t.createFramebuffer()
                    } else r.__webglFramebuffer = t.createFramebuffer();
                    if (s) {
                        for (n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture), v(t.TEXTURE_CUBE_MAP, e.texture, c), l = 0; l < 6; l++) g(r.__webglFramebuffer[l], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + l);
                        h(e.texture, c) && t.generateMipmap(t.TEXTURE_CUBE_MAP), n.bindTexture(t.TEXTURE_CUBE_MAP, null)
                    } else n.bindTexture(t.TEXTURE_2D, a.__webglTexture), v(t.TEXTURE_2D, e.texture, c), g(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), h(e.texture, c) && t.generateMipmap(t.TEXTURE_2D), n.bindTexture(t.TEXTURE_2D, null);
                    e.depthBuffer && x(e)
                }, this.updateRenderTargetMipmap = function(e) {
                    var r = e.texture;
                    if (h(r, u(e))) {
                        var a = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                            o = i.get(r).__webglTexture;
                        n.bindTexture(a, o), t.generateMipmap(a), n.bindTexture(a, null)
                    }
                }, this.updateVideoTextures = function() {
                    for (var t in c) c[t].update()
                }
            }
  
            function Aa(t, e, n, i) {
                ki.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
  
            function La(t) {
                Aa.call(this), this.cameras = t || []
            }
  
            function Pa(t) {
                var e = this,
                    n = null,
                    i = null,
                    r = null;
                "undefined" != typeof window && "VRFrameData" in window && (i = new window.VRFrameData);
                var a = new Ce,
                    o = new Aa;
                o.bounds = new Fe(0, 0, .5, 1), o.layers.enable(1);
                var s = new Aa;
                s.bounds = new Fe(.5, 0, .5, 1), s.layers.enable(2);
                var c, l, u = new La([o, s]);
  
                function h() {
                    if (null !== n && n.isPresenting) {
                        var i = n.getEyeParameters("left"),
                            r = i.renderWidth,
                            a = i.renderHeight;
                        l = t.getPixelRatio(), c = t.getSize(), t.setDrawingBufferSize(2 * r, a, 1)
                    } else e.enabled && t.setDrawingBufferSize(c.width, c.height, l)
                }
                u.layers.enable(1), u.layers.enable(2), "undefined" != typeof window && window.addEventListener("vrdisplaypresentchange", h, !1), this.enabled = !1, this.getDevice = function() {
                    return n
                }, this.setDevice = function(t) {
                    void 0 !== t && (n = t)
                }, this.setPoseTarget = function(t) {
                    void 0 !== t && (r = t)
                }, this.getCamera = function(t) {
                    if (null === n) return t;
                    n.depthNear = t.near, n.depthFar = t.far, n.getFrameData(i);
                    var e = i.pose,
                        c = null !== r ? r : t;
                    if (null !== e.position ? c.position.fromArray(e.position) : c.position.set(0, 0, 0), null !== e.orientation && c.quaternion.fromArray(e.orientation), c.updateMatrixWorld(), !1 === n.isPresenting) return t;
                    o.near = t.near, s.near = t.near, o.far = t.far, s.far = t.far, u.matrixWorld.copy(t.matrixWorld), u.matrixWorldInverse.copy(t.matrixWorldInverse), o.matrixWorldInverse.fromArray(i.leftViewMatrix), s.matrixWorldInverse.fromArray(i.rightViewMatrix);
                    var l = c.parent;
                    null !== l && (a.getInverse(l.matrixWorld), o.matrixWorldInverse.multiply(a), s.matrixWorldInverse.multiply(a)), o.matrixWorld.getInverse(o.matrixWorldInverse), s.matrixWorld.getInverse(s.matrixWorldInverse), o.projectionMatrix.fromArray(i.leftProjectionMatrix), s.projectionMatrix.fromArray(i.rightProjectionMatrix), u.projectionMatrix.copy(o.projectionMatrix);
                    var h = n.getLayers();
                    if (h.length) {
                        var d = h[0];
                        null !== d.leftBounds && 4 === d.leftBounds.length && o.bounds.fromArray(d.leftBounds), null !== d.rightBounds && 4 === d.rightBounds.length && s.bounds.fromArray(d.rightBounds)
                    }
                    return u
                }, this.submitFrame = function() {
                    n && n.isPresenting && n.submitFrame()
                }, this.dispose = function() {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", h)
                }
            }
  
            function Ca(t, e) {
                return {
                    convert: function(n) {
                        var i;
                        if (n === St) return t.REPEAT;
                        if (n === At) return t.CLAMP_TO_EDGE;
                        if (n === Lt) return t.MIRRORED_REPEAT;
                        if (n === Pt) return t.NEAREST;
                        if (n === Ct) return t.NEAREST_MIPMAP_NEAREST;
                        if (n === Rt) return t.NEAREST_MIPMAP_LINEAR;
                        if (n === Ot) return t.LINEAR;
                        if (n === It) return t.LINEAR_MIPMAP_NEAREST;
                        if (n === Nt) return t.LINEAR_MIPMAP_LINEAR;
                        if (n === Dt) return t.UNSIGNED_BYTE;
                        if (n === Ht) return t.UNSIGNED_SHORT_4_4_4_4;
                        if (n === Vt) return t.UNSIGNED_SHORT_5_5_5_1;
                        if (n === Wt) return t.UNSIGNED_SHORT_5_6_5;
                        if (n === Ut) return t.BYTE;
                        if (n === kt) return t.SHORT;
                        if (n === Ft) return t.UNSIGNED_SHORT;
                        if (n === zt) return t.INT;
                        if (n === Bt) return t.UNSIGNED_INT;
                        if (n === jt) return t.FLOAT;
                        if (n === Gt && null !== (i = e.get("OES_texture_half_float"))) return i.HALF_FLOAT_OES;
                        if (n === qt) return t.ALPHA;
                        if (n === Yt) return t.RGB;
                        if (n === $t) return t.RGBA;
                        if (n === Zt) return t.LUMINANCE;
                        if (n === Jt) return t.LUMINANCE_ALPHA;
                        if (n === Qt) return t.DEPTH_COMPONENT;
                        if (n === te) return t.DEPTH_STENCIL;
                        if (n === j) return t.FUNC_ADD;
                        if (n === G) return t.FUNC_SUBTRACT;
                        if (n === H) return t.FUNC_REVERSE_SUBTRACT;
                        if (n === X) return t.ZERO;
                        if (n === q) return t.ONE;
                        if (n === Y) return t.SRC_COLOR;
                        if (n === $) return t.ONE_MINUS_SRC_COLOR;
                        if (n === Z) return t.SRC_ALPHA;
                        if (n === J) return t.ONE_MINUS_SRC_ALPHA;
                        if (n === K) return t.DST_ALPHA;
                        if (n === Q) return t.ONE_MINUS_DST_ALPHA;
                        if (n === tt) return t.DST_COLOR;
                        if (n === et) return t.ONE_MINUS_DST_COLOR;
                        if (n === nt) return t.SRC_ALPHA_SATURATE;
                        if ((n === ee || n === ne || n === ie || n === re) && null !== (i = e.get("WEBGL_compressed_texture_s3tc"))) {
                            if (n === ee) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === ne) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === ie) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === re) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if ((n === ae || n === oe || n === se || n === ce) && null !== (i = e.get("WEBGL_compressed_texture_pvrtc"))) {
                            if (n === ae) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (n === oe) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (n === se) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (n === ce) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (n === le && null !== (i = e.get("WEBGL_compressed_texture_etc1"))) return i.COMPRESSED_RGB_ETC1_WEBGL;
                        if ((n === V || n === W) && null !== (i = e.get("EXT_blend_minmax"))) {
                            if (n === V) return i.MIN_EXT;
                            if (n === W) return i.MAX_EXT
                        }
                        return n === Xt && null !== (i = e.get("WEBGL_depth_texture")) ? i.UNSIGNED_INT_24_8_WEBGL : 0
                    }
                }
            }
  
            function Ra(t) {
                console.log("THREE.WebGLRenderer", _);
                var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    n = void 0 !== t.context ? t.context : null,
                    i = void 0 !== t.alpha && t.alpha,
                    r = void 0 === t.depth || t.depth,
                    a = void 0 === t.stencil || t.stencil,
                    o = void 0 !== t.antialias && t.antialias,
                    s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    l = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    u = [],
                    h = [],
                    d = null,
                    p = [],
                    f = [];
                this.domElement = e, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = mt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var m, v, g, y, x, b, w, A, L, P, I, N, j, G, H, V, W, X, q, Y = this,
                    $ = !1,
                    Z = null,
                    J = null,
                    K = -1,
                    Q = "",
                    tt = null,
                    et = null,
                    nt = new Fe,
                    ht = new Fe,
                    dt = null,
                    pt = 0,
                    ft = e.width,
                    vt = e.height,
                    gt = 1,
                    yt = new Fe(0, 0, ft, vt),
                    xt = new Fe(0, 0, ft, vt),
                    bt = !1,
                    wt = new hi,
                    _t = new function() {
                        var t = this,
                            e = null,
                            n = 0,
                            i = !1,
                            r = !1,
                            a = new ui,
                            o = new Ie,
                            s = {
                                value: null,
                                needsUpdate: !1
                            };
  
                        function c() {
                            s.value !== e && (s.value = e, s.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
                        }
  
                        function l(e, n, i, r) {
                            var c = null !== e ? e.length : 0,
                                l = null;
                            if (0 !== c) {
                                if (l = s.value, !0 !== r || null === l) {
                                    var u = i + 4 * c,
                                        h = n.matrixWorldInverse;
                                    o.getNormalMatrix(h), (null === l || l.length < u) && (l = new Float32Array(u));
                                    for (var d = 0, p = i; d !== c; ++d, p += 4) a.copy(e[d]).applyMatrix4(h, o), a.normal.toArray(l, p), l[p + 3] = a.constant
                                }
                                s.value = l, s.needsUpdate = !0
                            }
                            return t.numPlanes = c, l
                        }
                        this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, a) {
                            var o = 0 !== t.length || r || 0 !== n || i;
                            return i = r, e = l(t, a, 0), n = t.length, o
                        }, this.beginShadows = function() {
                            r = !0, l(null)
                        }, this.endShadows = function() {
                            r = !1, c()
                        }, this.setState = function(t, a, o, u, h, d) {
                            if (!i || null === t || 0 === t.length || r && !o) r ? l(null) : c();
                            else {
                                var p = r ? 0 : n,
                                    f = 4 * p,
                                    m = h.clippingState || null;
                                s.value = m, m = l(t, u, f, d);
                                for (var v = 0; v !== f; ++v) m[v] = e[v];
                                h.clippingState = m, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += p
                            }
                        }
                    },
                    Mt = !1,
                    Et = !1,
                    Tt = new Ce,
                    St = new Oe,
                    At = {
                        geometries: 0,
                        textures: 0
                    },
                    Lt = {
                        frame: 0,
                        calls: 0,
                        vertices: 0,
                        faces: 0,
                        points: 0
                    };
  
                function Pt() {
                    return null === Z ? gt : 1
                }
                this.info = {
                    render: Lt,
                    memory: At,
                    programs: null
                };
                try {
                    var Ct = {
                        alpha: i,
                        depth: r,
                        stencil: a,
                        antialias: o,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: c,
                        powerPreference: l
                    };
                    if (e.addEventListener("webglcontextlost", Nt, !1), e.addEventListener("webglcontextrestored", Ut, !1), null === (m = n || e.getContext("webgl", Ct) || e.getContext("experimental-webgl", Ct))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === m.getShaderPrecisionFormat && (m.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    console.error("THREE.WebGLRenderer: " + t.message)
                }
  
                function Rt() {
                    (v = new function(t) {
                        var e = {};
                        return {
                            get: function(n) {
                                if (void 0 !== e[n]) return e[n];
                                var i;
                                switch (n) {
                                    case "WEBGL_depth_texture":
                                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                        break;
                                    case "EXT_texture_filter_anisotropic":
                                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                        break;
                                    case "WEBGL_compressed_texture_s3tc":
                                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                        break;
                                    case "WEBGL_compressed_texture_pvrtc":
                                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                        break;
                                    case "WEBGL_compressed_texture_etc1":
                                        i = t.getExtension("WEBGL_compressed_texture_etc1");
                                        break;
                                    default:
                                        i = t.getExtension(n)
                                }
                                return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
                            }
                        }
                    }(m)).get("WEBGL_depth_texture"), v.get("OES_texture_float"), v.get("OES_texture_float_linear"), v.get("OES_texture_half_float"), v.get("OES_texture_half_float_linear"), v.get("OES_standard_derivatives"), v.get("OES_element_index_uint"), v.get("ANGLE_instanced_arrays"), q = new Ca(m, v), g = new function(t, e, n) {
                        var i;
  
                        function r(e) {
                            if ("highp" === e) {
                                if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                                e = "mediump"
                            }
                            return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                        }
                        var a = void 0 !== n.precision ? n.precision : "highp",
                            o = r(a);
                        o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
                        var s = !0 === n.logarithmicDepthBuffer,
                            c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                            l = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                            u = t.getParameter(t.MAX_TEXTURE_SIZE),
                            h = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                            d = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                            p = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                            f = t.getParameter(t.MAX_VARYING_VECTORS),
                            m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                            v = l > 0,
                            g = !!e.get("OES_texture_float");
                        return {
                            getMaxAnisotropy: function() {
                                if (void 0 !== i) return i;
                                var n = e.get("EXT_texture_filter_anisotropic");
                                return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                            },
                            getMaxPrecision: r,
                            precision: a,
                            logarithmicDepthBuffer: s,
                            maxTextures: c,
                            maxVertexTextures: l,
                            maxTextureSize: u,
                            maxCubemapSize: h,
                            maxAttributes: d,
                            maxVertexUniforms: p,
                            maxVaryings: f,
                            maxFragmentUniforms: m,
                            vertexTextures: v,
                            floatFragmentTextures: g,
                            floatVertexTextures: v && g
                        }
                    }(m, v, t), (y = new function(t, e, n) {
                        var i = new function() {
                                var e = !1,
                                    n = new Fe,
                                    i = null,
                                    r = new Fe(0, 0, 0, 0);
                                return {
                                    setMask: function(n) {
                                        i === n || e || (t.colorMask(n, n, n, n), i = n)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e, i, a, o, s) {
                                        !0 === s && (e *= o, i *= o, a *= o), n.set(e, i, a, o), !1 === r.equals(n) && (t.clearColor(e, i, a, o), r.copy(n))
                                    },
                                    reset: function() {
                                        e = !1, i = null, r.set(-1, 0, 0, 0)
                                    }
                                }
                            },
                            r = new function() {
                                var e = !1,
                                    n = null,
                                    i = null,
                                    r = null;
                                return {
                                    setTest: function(e) {
                                        e ? X(t.DEPTH_TEST) : q(t.DEPTH_TEST)
                                    },
                                    setMask: function(i) {
                                        n === i || e || (t.depthMask(i), n = i)
                                    },
                                    setFunc: function(e) {
                                        if (i !== e) {
                                            if (e) switch (e) {
                                                case it:
                                                    t.depthFunc(t.NEVER);
                                                    break;
                                                case rt:
                                                    t.depthFunc(t.ALWAYS);
                                                    break;
                                                case at:
                                                    t.depthFunc(t.LESS);
                                                    break;
                                                case ot:
                                                    t.depthFunc(t.LEQUAL);
                                                    break;
                                                case st:
                                                    t.depthFunc(t.EQUAL);
                                                    break;
                                                case ct:
                                                    t.depthFunc(t.GEQUAL);
                                                    break;
                                                case lt:
                                                    t.depthFunc(t.GREATER);
                                                    break;
                                                case ut:
                                                    t.depthFunc(t.NOTEQUAL);
                                                    break;
                                                default:
                                                    t.depthFunc(t.LEQUAL)
                                            } else t.depthFunc(t.LEQUAL);
                                            i = e
                                        }
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        r !== e && (t.clearDepth(e), r = e)
                                    },
                                    reset: function() {
                                        e = !1, n = null, i = null, r = null
                                    }
                                }
                            },
                            a = new function() {
                                var e = !1,
                                    n = null,
                                    i = null,
                                    r = null,
                                    a = null,
                                    o = null,
                                    s = null,
                                    c = null,
                                    l = null;
                                return {
                                    setTest: function(e) {
                                        e ? X(t.STENCIL_TEST) : q(t.STENCIL_TEST)
                                    },
                                    setMask: function(i) {
                                        n === i || e || (t.stencilMask(i), n = i)
                                    },
                                    setFunc: function(e, n, o) {
                                        i === e && r === n && a === o || (t.stencilFunc(e, n, o), i = e, r = n, a = o)
                                    },
                                    setOp: function(e, n, i) {
                                        o === e && s === n && c === i || (t.stencilOp(e, n, i), o = e, s = n, c = i)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        l !== e && (t.clearStencil(e), l = e)
                                    },
                                    reset: function() {
                                        e = !1, n = null, i = null, r = null, a = null, o = null, s = null, c = null, l = null
                                    }
                                }
                            },
                            o = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                            s = new Uint8Array(o),
                            c = new Uint8Array(o),
                            l = new Uint8Array(o),
                            u = {},
                            h = null,
                            d = null,
                            p = null,
                            f = null,
                            m = null,
                            v = null,
                            g = null,
                            y = null,
                            x = null,
                            b = !1,
                            w = null,
                            _ = null,
                            S = null,
                            A = null,
                            L = null,
                            P = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                            O = parseFloat(/^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]),
                            I = parseFloat(O) >= 1,
                            N = null,
                            j = {},
                            G = new Fe,
                            H = new Fe;
  
                        function V(e, n, i) {
                            var r = new Uint8Array(4),
                                a = t.createTexture();
                            t.bindTexture(e, a), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                            for (var o = 0; o < i; o++) t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                            return a
                        }
                        var W = {};
  
                        function X(e) {
                            !0 !== u[e] && (t.enable(e), u[e] = !0)
                        }
  
                        function q(e) {
                            !1 !== u[e] && (t.disable(e), u[e] = !1)
                        }
  
                        function Y(e, i, r, a, o, s, c, l) {
                            if (e !== D ? X(t.BLEND) : q(t.BLEND), e !== B) {
                                if (e !== p || l !== b) switch (e) {
                                    case k:
                                        l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE));
                                        break;
                                    case F:
                                        l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                                        break;
                                    case z:
                                        l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR));
                                        break;
                                    default:
                                        l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA))
                                }
                                f = null, m = null, v = null, g = null, y = null, x = null
                            } else o = o || i, s = s || r, c = c || a, i === f && o === g || (t.blendEquationSeparate(n.convert(i), n.convert(o)), f = i, g = o), r === m && a === v && s === y && c === x || (t.blendFuncSeparate(n.convert(r), n.convert(a), n.convert(s), n.convert(c)), m = r, v = a, y = s, x = c);
                            p = e, b = l
                        }
  
                        function $(e) {
                            w !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), w = e)
                        }
  
                        function Z(e) {
                            e !== M ? (X(t.CULL_FACE), e !== _ && (e === E ? t.cullFace(t.BACK) : e === T ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : q(t.CULL_FACE), _ = e
                        }
  
                        function J(e, n, i) {
                            e ? (X(t.POLYGON_OFFSET_FILL), A === n && L === i || (t.polygonOffset(n, i), A = n, L = i)) : q(t.POLYGON_OFFSET_FILL)
                        }
  
                        function K(e) {
                            void 0 === e && (e = t.TEXTURE0 + P - 1), N !== e && (t.activeTexture(e), N = e)
                        }
                        return W[t.TEXTURE_2D] = V(t.TEXTURE_2D, t.TEXTURE_2D, 1), W[t.TEXTURE_CUBE_MAP] = V(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i.setClear(0, 0, 0, 1), r.setClear(1), a.setClear(0), X(t.DEPTH_TEST), r.setFunc(ot), $(!1), Z(E), X(t.CULL_FACE), X(t.BLEND), Y(U), {
                            buffers: {
                                color: i,
                                depth: r,
                                stencil: a
                            },
                            initAttributes: function() {
                                for (var t = 0, e = s.length; t < e; t++) s[t] = 0
                            },
                            enableAttribute: function(n) {
                                s[n] = 1, 0 === c[n] && (t.enableVertexAttribArray(n), c[n] = 1), 0 !== l[n] && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, 0), l[n] = 0)
                            },
                            enableAttributeAndDivisor: function(n, i) {
                                s[n] = 1, 0 === c[n] && (t.enableVertexAttribArray(n), c[n] = 1), l[n] !== i && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, i), l[n] = i)
                            },
                            disableUnusedAttributes: function() {
                                for (var e = 0, n = c.length; e !== n; ++e) c[e] !== s[e] && (t.disableVertexAttribArray(e), c[e] = 0)
                            },
                            enable: X,
                            disable: q,
                            getCompressedTextureFormats: function() {
                                if (null === h && (h = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))
                                    for (var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0; i < n.length; i++) h.push(n[i]);
                                return h
                            },
                            useProgram: function(e) {
                                return d !== e && (t.useProgram(e), d = e, !0)
                            },
                            setBlending: Y,
                            setMaterial: function(e, n) {
                                e.side === R ? q(t.CULL_FACE) : X(t.CULL_FACE);
                                var a = e.side === C;
                                n && (a = !a), $(a), !0 === e.transparent ? Y(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : Y(D), r.setFunc(e.depthFunc), r.setTest(e.depthTest), r.setMask(e.depthWrite), i.setMask(e.colorWrite), J(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                            },
                            setFlipSided: $,
                            setCullFace: Z,
                            setLineWidth: function(e) {
                                e !== S && (I && t.lineWidth(e), S = e)
                            },
                            setPolygonOffset: J,
                            setScissorTest: function(e) {
                                e ? X(t.SCISSOR_TEST) : q(t.SCISSOR_TEST)
                            },
                            activeTexture: K,
                            bindTexture: function(e, n) {
                                null === N && K();
                                var i = j[N];
                                void 0 === i && (i = {
                                    type: void 0,
                                    texture: void 0
                                }, j[N] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || W[e]), i.type = e, i.texture = n)
                            },
                            compressedTexImage2D: function() {
                                try {
                                    t.compressedTexImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage2D: function() {
                                try {
                                    t.texImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            scissor: function(e) {
                                !1 === G.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), G.copy(e))
                            },
                            viewport: function(e) {
                                !1 === H.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), H.copy(e))
                            },
                            reset: function() {
                                for (var e = 0; e < c.length; e++) 1 === c[e] && (t.disableVertexAttribArray(e), c[e] = 0);
                                u = {}, h = null, N = null, j = {}, d = null, p = null, w = null, _ = null, i.reset(), r.reset(), a.reset()
                            }
                        }
                    }(m, v, q)).scissor(ht.copy(xt).multiplyScalar(gt)), y.viewport(nt.copy(yt).multiplyScalar(gt)), x = new function() {
                        var t = {};
                        return {
                            get: function(e) {
                                var n = e.uuid,
                                    i = t[n];
                                return void 0 === i && (i = {}, t[n] = i), i
                            },
                            remove: function(e) {
                                delete t[e.uuid]
                            },
                            clear: function() {
                                t = {}
                            }
                        }
                    }, b = new Sa(m, v, y, x, g, q, At), w = new pi(m), A = new function(t, e, n) {
                        var i = {},
                            r = {};
  
                        function a(t) {
                            var o = t.target,
                                s = i[o.id];
                            for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]);
                            o.removeEventListener("dispose", a), delete i[o.id];
                            var l = r[o.id];
                            l && (e.remove(l), delete r[o.id]), (l = r[s.id]) && (e.remove(l), delete r[s.id]), n.geometries--
                        }
                        return {
                            get: function(t, e) {
                                var r = i[e.id];
                                return r || (e.addEventListener("dispose", a), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Br).setFromObject(t)), r = e._bufferGeometry), i[e.id] = r, n.geometries++, r)
                            },
                            update: function(n) {
                                var i = n.index,
                                    r = n.attributes;
                                for (var a in null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER), r) e.update(r[a], t.ARRAY_BUFFER);
                                var o = n.morphAttributes;
                                for (var a in o)
                                    for (var s = o[a], c = 0, l = s.length; c < l; c++) e.update(s[c], t.ARRAY_BUFFER)
                            },
                            getWireframeAttribute: function(n) {
                                var i = r[n.id];
                                if (i) return i;
                                var a, o = [],
                                    s = n.index,
                                    c = n.attributes;
                                if (null !== s)
                                    for (var l = 0, u = (a = s.array).length; l < u; l += 3) {
                                        var h = a[l + 0],
                                            d = a[l + 1],
                                            p = a[l + 2];
                                        o.push(h, d, d, p, p, h)
                                    } else
                                        for (l = 0, u = (a = c.position.array).length / 3 - 1; l < u; l += 3) h = l + 0, d = l + 1, p = l + 2, o.push(h, d, d, p, p, h);
                                return i = new(ar(o) > 65535 ? er : Qi)(o, 1), e.update(i, t.ELEMENT_ARRAY_BUFFER), r[n.id] = i, i
                            }
                        }
                    }(m, w, At), L = new function(t, e) {
                        var n = {};
                        return {
                            update: function(i) {
                                var r = e.frame,
                                    a = i.geometry,
                                    o = t.get(i, a);
                                return n[o.id] !== r && (a.isGeometry && o.updateFromObject(i), t.update(o), n[o.id] = r), o
                            },
                            clear: function() {
                                n = {}
                            }
                        }
                    }(A, Lt), G = new function(t) {
                        var e = {},
                            n = new Float32Array(8);
                        return {
                            update: function(i, r, a, o) {
                                var s = i.morphTargetInfluences,
                                    c = s.length,
                                    l = e[r.id];
                                if (void 0 === l) {
                                    l = [];
                                    for (var u = 0; u < c; u++) l[u] = [u, 0];
                                    e[r.id] = l
                                }
                                var h = a.morphTargets && r.morphAttributes.position,
                                    d = a.morphNormals && r.morphAttributes.normal;
                                for (u = 0; u < c; u++) 0 !== (p = l[u])[1] && (h && r.removeAttribute("morphTarget" + u), d && r.removeAttribute("morphNormal" + u));
                                for (u = 0; u < c; u++)(p = l[u])[0] = u, p[1] = s[u];
                                for (l.sort(ta), u = 0; u < 8; u++) {
                                    var p;
                                    if (p = l[u]) {
                                        var f = p[0],
                                            m = p[1];
                                        if (m) {
                                            h && r.addAttribute("morphTarget" + u, h[f]), d && r.addAttribute("morphNormal" + u, d[f]), n[u] = m;
                                            continue
                                        }
                                    }
                                    n[u] = 0
                                }
                                o.getUniforms().setValue(t, "morphTargetInfluences", n)
                            }
                        }
                    }(m), I = new Ta(Y, v, g), P = new ea, N = new Qr, j = new function(t, e, n, i) {
                        var r, a, o, s = new Cn(0),
                            c = 0;
  
                        function l(t, n) {
                            e.buffers.color.setClear(t.r, t.g, t.b, n, i)
                        }
                        return {
                            getClearColor: function() {
                                return s
                            },
                            setClearColor: function(t, e) {
                                s.set(t), l(s, c = void 0 !== e ? e : 1)
                            },
                            getClearAlpha: function() {
                                return c
                            },
                            setClearAlpha: function(t) {
                                l(s, c = t)
                            },
                            render: function(e, i, u, h) {
                                var d = i.background;
                                null === d ? l(s, c) : d && d.isColor && (l(d, 1), h = !0), (t.autoClear || h) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && d.isCubeTexture ? (void 0 === o && ((o = new Zr(new Gr(1, 1, 1), new Xr({
                                    uniforms: Un.cube.uniforms,
                                    vertexShader: Un.cube.vertexShader,
                                    fragmentShader: Un.cube.fragmentShader,
                                    side: C,
                                    depthTest: !0,
                                    depthWrite: !1,
                                    fog: !1
                                }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(t, e, n) {
                                    this.matrixWorld.copyPosition(n.matrixWorld)
                                }, n.update(o.geometry)), o.material.uniforms.tCube.value = d, e.push(o, o.geometry, o.material, 0, null)) : d && d.isTexture && (void 0 === r && (r = new Fi(-1, 1, 1, -1, 0, 1), a = new Zr(new Vr(2, 2), new Wr({
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                })), n.update(a.geometry)), a.material.map = d, t.renderBufferDirect(r, null, a.geometry, a.material, a, null))
                            }
                        }
                    }(Y, y, A, s), H = new function(t, e, n) {
                        var i;
                        this.setMode = function(t) {
                            i = t
                        }, this.render = function(e, r) {
                            t.drawArrays(i, e, r), n.calls++, n.vertices += r, i === t.TRIANGLES ? n.faces += r / 3 : i === t.POINTS && (n.points += r)
                        }, this.renderInstances = function(r, a, o) {
                            var s = e.get("ANGLE_instanced_arrays");
                            if (null !== s) {
                                var c = r.attributes.position;
                                c.isInterleavedBufferAttribute ? (o = c.data.count, s.drawArraysInstancedANGLE(i, 0, o, r.maxInstancedCount)) : s.drawArraysInstancedANGLE(i, a, o, r.maxInstancedCount), n.calls++, n.vertices += o * r.maxInstancedCount, i === t.TRIANGLES ? n.faces += r.maxInstancedCount * o / 3 : i === t.POINTS && (n.points += r.maxInstancedCount * o)
                            } else console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                        }
                    }(m, v, Lt), V = new function(t, e, n) {
                        var i, r, a;
                        this.setMode = function(t) {
                            i = t
                        }, this.setIndex = function(t) {
                            r = t.type, a = t.bytesPerElement
                        }, this.render = function(e, o) {
                            t.drawElements(i, o, r, e * a), n.calls++, n.vertices += o, i === t.TRIANGLES ? n.faces += o / 3 : i === t.POINTS && (n.points += o)
                        }, this.renderInstances = function(o, s, c) {
                            var l = e.get("ANGLE_instanced_arrays");
                            null !== l ? (l.drawElementsInstancedANGLE(i, c, r, s * a, o.maxInstancedCount), n.calls++, n.vertices += c * o.maxInstancedCount, i === t.TRIANGLES ? n.faces += o.maxInstancedCount * c / 3 : i === t.POINTS && (n.points += o.maxInstancedCount * c)) : console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                        }
                    }(m, v, Lt), W = new Fn(Y, m, y, b, g), X = new Bn(Y, m, y, b, g), Y.info.programs = I.programs, Y.context = m, Y.capabilities = g, Y.extensions = v, Y.properties = x, Y.renderLists = N, Y.state = y
                }
                Rt();
                var Ot = new Pa(Y);
                this.vr = Ot;
                var It = new di(Y, L, g.maxTextureSize);
  
                function Nt(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), $ = !0
                }
  
                function Ut() {
                    console.log("THREE.WebGLRenderer: Context Restored."), $ = !1, Rt()
                }
  
                function kt(t) {
                    var e, n = t.target;
                    n.removeEventListener("dispose", kt), Ft(e = n), x.remove(e)
                }
  
                function Ft(t) {
                    var e = x.get(t).program;
                    t.program = void 0, void 0 !== e && I.releaseProgram(e)
                }
                this.shadowMap = It, this.getContext = function() {
                    return m
                }, this.getContextAttributes = function() {
                    return m.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var t = v.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    var t = v.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return gt
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (gt = t, this.setSize(ft, vt, !1))
                }, this.getSize = function() {
                    return {
                        width: ft,
                        height: vt
                    }
                }, this.setSize = function(t, n, i) {
                    var r = Ot.getDevice();
                    r && r.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (ft = t, vt = n, e.width = t * gt, e.height = n * gt, !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function() {
                    return {
                        width: ft * gt,
                        height: vt * gt
                    }
                }, this.setDrawingBufferSize = function(t, n, i) {
                    ft = t, vt = n, gt = i, e.width = t * i, e.height = n * i, this.setViewport(0, 0, t, n)
                }, this.setViewport = function(t, e, n, i) {
                    yt.set(t, vt - e - i, n, i), y.viewport(nt.copy(yt).multiplyScalar(gt))
                }, this.setScissor = function(t, e, n, i) {
                    xt.set(t, vt - e - i, n, i), y.scissor(ht.copy(xt).multiplyScalar(gt))
                }, this.setScissorTest = function(t) {
                    y.setScissorTest(bt = t)
                }, this.getClearColor = function() {
                    return j.getClearColor()
                }, this.setClearColor = function() {
                    j.setClearColor.apply(j, arguments)
                }, this.getClearAlpha = function() {
                    return j.getClearAlpha()
                }, this.setClearAlpha = function() {
                    j.setClearAlpha.apply(j, arguments)
                }, this.clear = function(t, e, n) {
                    var i = 0;
                    (void 0 === t || t) && (i |= m.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= m.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= m.STENCIL_BUFFER_BIT), m.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.clearTarget = function(t, e, n, i) {
                    this.setRenderTarget(t), this.clear(e, n, i)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", Nt, !1), e.removeEventListener("webglcontextrestored", Ut, !1), N.dispose(), Ot.dispose()
                }, this.renderBufferImmediate = function(t, e, n) {
                    y.initAttributes();
                    var i = x.get(t);
                    t.hasPositions && !i.position && (i.position = m.createBuffer()), t.hasNormals && !i.normal && (i.normal = m.createBuffer()), t.hasUvs && !i.uv && (i.uv = m.createBuffer()), t.hasColors && !i.color && (i.color = m.createBuffer());
                    var r = e.getAttributes();
                    if (t.hasPositions && (m.bindBuffer(m.ARRAY_BUFFER, i.position), m.bufferData(m.ARRAY_BUFFER, t.positionArray, m.DYNAMIC_DRAW), y.enableAttribute(r.position), m.vertexAttribPointer(r.position, 3, m.FLOAT, !1, 0, 0)), t.hasNormals) {
                        if (m.bindBuffer(m.ARRAY_BUFFER, i.normal), !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && !0 === n.flatShading)
                            for (var a = 0, o = 3 * t.count; a < o; a += 9) {
                                var s = t.normalArray,
                                    c = (s[a + 0] + s[a + 3] + s[a + 6]) / 3,
                                    l = (s[a + 1] + s[a + 4] + s[a + 7]) / 3,
                                    u = (s[a + 2] + s[a + 5] + s[a + 8]) / 3;
                                s[a + 0] = c, s[a + 1] = l, s[a + 2] = u, s[a + 3] = c, s[a + 4] = l, s[a + 5] = u, s[a + 6] = c, s[a + 7] = l, s[a + 8] = u
                            }
                        m.bufferData(m.ARRAY_BUFFER, t.normalArray, m.DYNAMIC_DRAW), y.enableAttribute(r.normal), m.vertexAttribPointer(r.normal, 3, m.FLOAT, !1, 0, 0)
                    }
                    t.hasUvs && n.map && (m.bindBuffer(m.ARRAY_BUFFER, i.uv), m.bufferData(m.ARRAY_BUFFER, t.uvArray, m.DYNAMIC_DRAW), y.enableAttribute(r.uv), m.vertexAttribPointer(r.uv, 2, m.FLOAT, !1, 0, 0)), t.hasColors && n.vertexColors !== O && (m.bindBuffer(m.ARRAY_BUFFER, i.color), m.bufferData(m.ARRAY_BUFFER, t.colorArray, m.DYNAMIC_DRAW), y.enableAttribute(r.color), m.vertexAttribPointer(r.color, 3, m.FLOAT, !1, 0, 0)), y.disableUnusedAttributes(), m.drawArrays(m.TRIANGLES, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, n, i, r, a) {
                    var o = r.isMesh && r.matrixWorld.determinant() < 0;
                    y.setMaterial(i, o);
                    var s = Jt(t, e, i, r),
                        c = n.id + "_" + s.id + "_" + (!0 === i.wireframe),
                        l = !1;
                    c !== Q && (Q = c, l = !0), r.morphTargetInfluences && (G.update(r, n, i, s), l = !0);
                    var u, h = n.index,
                        d = n.attributes.position,
                        p = 1;
                    !0 === i.wireframe && (h = A.getWireframeAttribute(n), p = 2);
                    var f = H;
                    null !== h && (u = w.get(h), (f = V).setIndex(u)), l && (! function(t, e, n, i) {
                        if (n && n.isInstancedBufferGeometry && null === v.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        void 0 === i && (i = 0);
                        y.initAttributes();
                        var r = n.attributes,
                            a = e.getAttributes(),
                            o = t.defaultAttributeValues;
                        for (var s in a) {
                            var c = a[s];
                            if (c >= 0) {
                                var l = r[s];
                                if (void 0 !== l) {
                                    var u = l.normalized,
                                        h = l.itemSize,
                                        d = w.get(l);
                                    if (void 0 === d) continue;
                                    var p = d.buffer,
                                        f = d.type,
                                        g = d.bytesPerElement;
                                    if (l.isInterleavedBufferAttribute) {
                                        var x = l.data,
                                            b = x.stride,
                                            _ = l.offset;
                                        x && x.isInstancedInterleavedBuffer ? (y.enableAttributeAndDivisor(c, x.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = x.meshPerAttribute * x.count)) : y.enableAttribute(c), m.bindBuffer(m.ARRAY_BUFFER, p), m.vertexAttribPointer(c, h, f, u, b * g, (i * b + _) * g)
                                    } else l.isInstancedBufferAttribute ? (y.enableAttributeAndDivisor(c, l.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = l.meshPerAttribute * l.count)) : y.enableAttribute(c), m.bindBuffer(m.ARRAY_BUFFER, p), m.vertexAttribPointer(c, h, f, u, 0, i * h * g)
                                } else if (void 0 !== o) {
                                    var M = o[s];
                                    if (void 0 !== M) switch (M.length) {
                                        case 2:
                                            m.vertexAttrib2fv(c, M);
                                            break;
                                        case 3:
                                            m.vertexAttrib3fv(c, M);
                                            break;
                                        case 4:
                                            m.vertexAttrib4fv(c, M);
                                            break;
                                        default:
                                            m.vertexAttrib1fv(c, M)
                                    }
                                }
                            }
                        }
                        y.disableUnusedAttributes()
                    }(i, s, n), null !== h && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, u.buffer));
                    var g = 0;
                    null !== h ? g = h.count : void 0 !== d && (g = d.count);
                    var x = n.drawRange.start * p,
                        b = n.drawRange.count * p,
                        _ = null !== a ? a.start * p : 0,
                        M = null !== a ? a.count * p : 1 / 0,
                        E = Math.max(x, _),
                        T = Math.min(g, x + b, _ + M) - 1,
                        S = Math.max(0, T - E + 1);
                    if (0 !== S) {
                        if (r.isMesh)
                            if (!0 === i.wireframe) y.setLineWidth(i.wireframeLinewidth * Pt()), f.setMode(m.LINES);
                            else switch (r.drawMode) {
                                case ve:
                                    f.setMode(m.TRIANGLES);
                                    break;
                                case ge:
                                    f.setMode(m.TRIANGLE_STRIP);
                                    break;
                                case ye:
                                    f.setMode(m.TRIANGLE_FAN)
                            } else if (r.isLine) {
                                var L = i.linewidth;
                                void 0 === L && (L = 1), y.setLineWidth(L * Pt()), r.isLineSegments ? f.setMode(m.LINES) : r.isLineLoop ? f.setMode(m.LINE_LOOP) : f.setMode(m.LINE_STRIP)
                            } else r.isPoints && f.setMode(m.POINTS);
                        n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && f.renderInstances(n, E, S) : f.render(E, S)
                    }
                }, this.compile = function(t, e) {
                    u.length = 0, h.length = 0, t.traverse(function(t) {
                        t.isLight && (u.push(t), t.castShadow && h.push(t))
                    }), P.setup(u, h, e), t.traverse(function(e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var n = 0; n < e.material.length; n++) Zt(e.material[n], t.fog, e);
                            else Zt(e.material, t.fog, e)
                    })
                };
                var zt, Bt, Ht, Vt = !1,
                    Wt = null;
  
                function Xt(t) {
                    null !== Wt && Wt(t);
                    var e = Ot.getDevice();
                    e && e.isPresenting ? e.requestAnimationFrame(Xt) : window.requestAnimationFrame(Xt)
                }
  
                function qt(t, e, n, i) {
                    for (var r = 0, a = t.length; r < a; r++) {
                        var o = t[r],
                            s = o.object,
                            c = o.geometry,
                            l = void 0 === i ? o.material : i,
                            u = o.group;
                        if (n.isArrayCamera) {
                            et = n;
                            for (var h = n.cameras, d = 0, p = h.length; d < p; d++) {
                                var f = h[d];
                                if (s.layers.test(f.layers)) {
                                    var m = f.bounds,
                                        v = m.x * ft,
                                        g = m.y * vt,
                                        x = m.z * ft,
                                        b = m.w * vt;
                                    y.viewport(nt.set(v, g, x, b).multiplyScalar(gt)), Yt(s, e, f, c, l, u)
                                }
                            }
                        } else et = null, Yt(s, e, n, c, l, u)
                    }
                }
  
                function Yt(t, e, n, i, r, a) {
                    if (t.onBeforeRender(Y, e, n, i, r, a), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        var o = t.isMesh && t.matrixWorld.determinant() < 0;
                        y.setMaterial(r, o);
                        var s = Jt(n, e.fog, r, t);
                        Q = "", c = s, l = r, t.render(function(t) {
                            Y.renderBufferImmediate(t, c, l)
                        })
                    } else Y.renderBufferDirect(n, e.fog, i, r, t, a);
                    var c, l;
                    t.onAfterRender(Y, e, n, i, r, a)
                }
  
                function Zt(t, e, n) {
                    var i = x.get(t),
                        r = I.getParameters(t, P.state, h, e, _t.numPlanes, _t.numIntersection, n),
                        a = I.getProgramCode(t, r),
                        o = i.program,
                        s = !0;
                    if (void 0 === o) t.addEventListener("dispose", kt);
                    else if (o.code !== a) Ft(t);
                    else {
                        if (void 0 !== r.shaderID) return;
                        s = !1
                    }
                    if (s) {
                        if (r.shaderID) {
                            var c = Un[r.shaderID];
                            i.shader = {
                                name: t.type,
                                uniforms: Nn.clone(c.uniforms),
                                vertexShader: c.vertexShader,
                                fragmentShader: c.fragmentShader
                            }
                        } else i.shader = {
                            name: t.type,
                            uniforms: t.uniforms,
                            vertexShader: t.vertexShader,
                            fragmentShader: t.fragmentShader
                        };
                        t.onBeforeCompile(i.shader), o = I.acquireProgram(t, i.shader, r, a), i.program = o, t.program = o
                    }
                    var l = o.getAttributes();
                    if (t.morphTargets) {
                        t.numSupportedMorphTargets = 0;
                        for (var u = 0; u < Y.maxMorphTargets; u++) l["morphTarget" + u] >= 0 && t.numSupportedMorphTargets++
                    }
                    if (t.morphNormals) {
                        t.numSupportedMorphNormals = 0;
                        for (u = 0; u < Y.maxMorphNormals; u++) l["morphNormal" + u] >= 0 && t.numSupportedMorphNormals++
                    }
                    var d = i.shader.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = _t.numPlanes, i.numIntersection = _t.numIntersection, d.clippingPlanes = _t.uniform), i.fog = e, i.lightsHash = P.state.hash, t.lights && (d.ambientLightColor.value = P.state.ambient, d.directionalLights.value = P.state.directional, d.spotLights.value = P.state.spot, d.rectAreaLights.value = P.state.rectArea, d.pointLights.value = P.state.point, d.hemisphereLights.value = P.state.hemi, d.directionalShadowMap.value = P.state.directionalShadowMap, d.directionalShadowMatrix.value = P.state.directionalShadowMatrix, d.spotShadowMap.value = P.state.spotShadowMap, d.spotShadowMatrix.value = P.state.spotShadowMatrix, d.pointShadowMap.value = P.state.pointShadowMap, d.pointShadowMatrix.value = P.state.pointShadowMatrix);
                    var p = i.program.getUniforms(),
                        f = Ln.seqWithValue(p.seq, d);
                    i.uniformsList = f
                }
  
                function Jt(t, e, n, i) {
                    pt = 0;
                    var r = x.get(n);
                    if (Mt && (Et || t !== tt)) {
                        var a = t === tt && n.id === K;
                        _t.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, a)
                    }!1 === n.needsUpdate && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== e ? n.needsUpdate = !0 : n.lights && r.lightsHash !== P.state.hash ? n.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === _t.numPlanes && r.numIntersection === _t.numIntersection || (n.needsUpdate = !0)), n.needsUpdate && (Zt(n, e, i), n.needsUpdate = !1);
                    var o, s, c, l, u, h, d, p, f, v, b, w, _, M, E, T, S = !1,
                        A = !1,
                        L = !1,
                        C = r.program,
                        R = C.getUniforms(),
                        O = r.shader.uniforms;
                    if (y.useProgram(C.program) && (S = !0, A = !0, L = !0), n.id !== K && (K = n.id, A = !0), S || t !== tt) {
                        if (R.setValue(m, "projectionMatrix", t.projectionMatrix), g.logarithmicDepthBuffer && R.setValue(m, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), tt !== (et || t) && (tt = et || t, A = !0, L = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var I = R.map.cameraPosition;
                            void 0 !== I && I.setValue(m, St.setFromMatrixPosition(t.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && R.setValue(m, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        R.setOptional(m, i, "bindMatrix"), R.setOptional(m, i, "bindMatrixInverse");
                        var N = i.skeleton;
                        if (N) {
                            var D = N.bones;
                            if (g.floatVertexTextures) {
                                if (void 0 === N.boneTexture) {
                                    var U = Math.sqrt(4 * D.length);
                                    U = Le.ceilPowerOfTwo(U), U = Math.max(U, 4);
                                    var k = new Float32Array(U * U * 4);
                                    k.set(N.boneMatrices);
                                    var F = new je(k, U, U, $t, jt);
                                    N.boneMatrices = k, N.boneTexture = F, N.boneTextureSize = U
                                }
                                R.setValue(m, "boneTexture", N.boneTexture), R.setValue(m, "boneTextureSize", N.boneTextureSize)
                            } else R.setOptional(m, N, "boneMatrices")
                        }
                    }
                    return A && (R.setValue(m, "toneMappingExposure", Y.toneMappingExposure), R.setValue(m, "toneMappingWhitePoint", Y.toneMappingWhitePoint), n.lights && (T = L, (E = O).ambientLightColor.needsUpdate = T, E.directionalLights.needsUpdate = T, E.pointLights.needsUpdate = T, E.spotLights.needsUpdate = T, E.rectAreaLights.needsUpdate = T, E.hemisphereLights.needsUpdate = T), e && n.fog && (M = e, (_ = O).fogColor.value = M.color, M.isFog ? (_.fogNear.value = M.near, _.fogFar.value = M.far) : M.isFogExp2 && (_.fogDensity.value = M.density)), n.isMeshBasicMaterial ? Kt(O, n) : n.isMeshLambertMaterial ? (Kt(O, n), b = O, (w = n).emissiveMap && (b.emissiveMap.value = w.emissiveMap)) : n.isMeshPhongMaterial ? (Kt(O, n), n.isMeshToonMaterial ? (Qt(f = O, v = n), v.gradientMap && (f.gradientMap.value = v.gradientMap)) : Qt(O, n)) : n.isMeshStandardMaterial ? (Kt(O, n), n.isMeshPhysicalMaterial ? (p = n, (d = O).clearCoat.value = p.clearCoat, d.clearCoatRoughness.value = p.clearCoatRoughness, te(d, p)) : te(O, n)) : n.isMeshDepthMaterial ? (Kt(O, n), u = O, (h = n).displacementMap && (u.displacementMap.value = h.displacementMap, u.displacementScale.value = h.displacementScale, u.displacementBias.value = h.displacementBias)) : n.isMeshDistanceMaterial ? (Kt(O, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(O, n)) : n.isMeshNormalMaterial ? (Kt(O, n), function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale);
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale));
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(O, n)) : n.isLineBasicMaterial ? (l = n, (c = O).diffuse.value = l.color, c.opacity.value = l.opacity, n.isLineDashedMaterial && (s = n, (o = O).dashSize.value = s.dashSize, o.totalSize.value = s.dashSize + s.gapSize, o.scale.value = s.scale)) : n.isPointsMaterial ? function(t, e) {
                        if (t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * gt, t.scale.value = .5 * vt, t.map.value = e.map, null !== e.map) {
                            if (!0 === e.map.matrixAutoUpdate) {
                                var n = e.map.offset,
                                    i = e.map.repeat,
                                    r = e.map.rotation,
                                    a = e.map.center;
                                e.map.matrix.setUvTransform(n.x, n.y, i.x, i.y, r, a.x, a.y)
                            }
                            t.uvTransform.value.copy(e.map.matrix)
                        }
                    }(O, n) : n.isShadowMaterial && (O.color.value = n.color, O.opacity.value = n.opacity), void 0 !== O.ltcMat && (O.ltcMat.value = In.LTC_MAT_TEXTURE), void 0 !== O.ltcMag && (O.ltcMag.value = In.LTC_MAG_TEXTURE), Ln.upload(m, r.uniformsList, O, Y)), R.setValue(m, "modelViewMatrix", i.modelViewMatrix), R.setValue(m, "normalMatrix", i.normalMatrix), R.setValue(m, "modelMatrix", i.matrixWorld), C
                }
  
                function Kt(t, e) {
                    var n;
                    if (t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap), void 0 !== n) {
                        if (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate) {
                            var i = n.offset,
                                r = n.repeat,
                                a = n.rotation,
                                o = n.center;
                            n.matrix.setUvTransform(i.x, i.y, r.x, r.y, a, o.x, o.y)
                        }
                        t.uvTransform.value.copy(n.matrix)
                    }
                }
  
                function Qt(t, e) {
                    t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }
  
                function te(t, e) {
                    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }
                this.animate = function(t) {
                    Wt = t,
                        function() {
                            if (!Vt) {
                                var t = Ot.getDevice();
                                t && t.isPresenting ? t.requestAnimationFrame(Xt) : window.requestAnimationFrame(Xt), Vt = !0
                            }
                        }()
                }, this.render = function(t, e, n, i) {
                    if (e && e.isCamera) {
                        if (!$) {
                            Q = "", K = -1, tt = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Ot.enabled && (e = Ot.getCamera(e)), Tt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), wt.setFromMatrix(Tt), u.length = 0, h.length = 0, p.length = 0, f.length = 0, Et = this.localClippingEnabled, Mt = _t.init(this.clippingPlanes, Et, e), (d = N.get(t, e)).init(),
                                function t(e, n, i) {
                                    if (!1 === e.visible) return;
                                    var r = e.layers.test(n.layers);
                                    if (r)
                                        if (e.isLight) u.push(e), e.castShadow && h.push(e);
                                        else if (e.isSprite) e.frustumCulled && !wt.intersectsSprite(e) || p.push(e);
                                    else if (e.isLensFlare) f.push(e);
                                    else if (e.isImmediateRenderObject) i && St.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Tt), d.push(e, null, e.material, St.z, null);
                                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || wt.intersectsObject(e))) {
                                        i && St.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Tt);
                                        var a = L.update(e),
                                            o = e.material;
                                        if (Array.isArray(o))
                                            for (var s = a.groups, c = 0, l = s.length; c < l; c++) {
                                                var m = s[c],
                                                    v = o[m.materialIndex];
                                                v && v.visible && d.push(e, a, v, St.z, m)
                                            } else o.visible && d.push(e, a, o, St.z, null)
                                    }
                                    var g = e.children;
                                    for (var c = 0, l = g.length; c < l; c++) t(g[c], n, i)
                                }(t, e, Y.sortObjects), !0 === Y.sortObjects && d.sort(), b.updateVideoTextures(), Mt && _t.beginShadows(), It.render(h, t, e), P.setup(u, h, e), Mt && _t.endShadows(), Lt.frame++, Lt.calls = 0, Lt.vertices = 0, Lt.faces = 0, Lt.points = 0, void 0 === n && (n = null), this.setRenderTarget(n), j.render(d, t, e, i);
                            var r = d.opaque,
                                a = d.transparent;
                            if (t.overrideMaterial) {
                                var o = t.overrideMaterial;
                                r.length && qt(r, t, e, o), a.length && qt(a, t, e, o)
                            } else r.length && qt(r, t, e), a.length && qt(a, t, e);
                            X.render(p, t, e), W.render(f, t, e, nt), n && b.updateRenderTargetMipmap(n), y.buffers.depth.setTest(!0), y.buffers.depth.setMask(!0), y.buffers.color.setMask(!0), y.setPolygonOffset(!1), Ot.enabled && Ot.submitFrame()
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.setFaceCulling = function(t, e) {
                    y.setCullFace(t), y.setFlipSided(e === S)
                }, this.allocTextureUnit = function() {
                    var t = pt;
                    return t >= g.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + g.maxTextures), pt += 1, t
                }, this.setTexture2D = (zt = !1, function(t, e) {
                    t && t.isWebGLRenderTarget && (zt || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), zt = !0), t = t.texture), b.setTexture2D(t, e)
                }), this.setTexture = (Bt = !1, function(t, e) {
                    Bt || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), Bt = !0), b.setTexture2D(t, e)
                }), this.setTextureCube = (Ht = !1, function(t, e) {
                    t && t.isWebGLRenderTargetCube && (Ht || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), Ht = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? b.setTextureCube(t, e) : b.setTextureCubeDynamic(t, e)
                }), this.getRenderTarget = function() {
                    return Z
                }, this.setRenderTarget = function(t) {
                    Z = t, t && void 0 === x.get(t).__webglFramebuffer && b.setupRenderTarget(t);
                    var e = null,
                        n = !1;
                    if (t) {
                        var i = x.get(t).__webglFramebuffer;
                        t.isWebGLRenderTargetCube ? (e = i[t.activeCubeFace], n = !0) : e = i, nt.copy(t.viewport), ht.copy(t.scissor), dt = t.scissorTest
                    } else nt.copy(yt).multiplyScalar(gt), ht.copy(xt).multiplyScalar(gt), dt = bt;
                    if (J !== e && (m.bindFramebuffer(m.FRAMEBUFFER, e), J = e), y.viewport(nt), y.scissor(ht), y.setScissorTest(dt), n) {
                        var r = x.get(t.texture);
                        m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, m.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function(t, e, n, i, r, a) {
                    if (t && t.isWebGLRenderTarget) {
                        var o = x.get(t).__webglFramebuffer;
                        if (o) {
                            var s = !1;
                            o !== J && (m.bindFramebuffer(m.FRAMEBUFFER, o), s = !0);
                            try {
                                var c = t.texture,
                                    l = c.format,
                                    u = c.type;
                                if (l !== $t && q.convert(l) !== m.getParameter(m.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(u === Dt || q.convert(u) === m.getParameter(m.IMPLEMENTATION_COLOR_READ_TYPE) || u === jt && (v.get("OES_texture_float") || v.get("WEBGL_color_buffer_float")) || u === Gt && v.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                m.checkFramebufferStatus(m.FRAMEBUFFER) === m.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && m.readPixels(e, n, i, r, q.convert(l), q.convert(u), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                s && m.bindFramebuffer(m.FRAMEBUFFER, J)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }
            }
  
            function Oa(t, e) {
                this.name = "", this.color = new Cn(t), this.density = void 0 !== e ? e : 25e-5
            }
  
            function Ia(t, e, n) {
                this.name = "", this.color = new Cn(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
            }
  
            function Na() {
                Ui.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }
  
            function Da(t, e, n, i, r) {
                Ui.call(this), this.lensFlares = [], this.positionScreen = new Oe, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, n, i, r)
            }
  
            function Ua(t) {
                ai.call(this), this.type = "SpriteMaterial", this.color = new Cn(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(t)
            }
  
            function ka(t) {
                Ui.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new Ua
            }
  
            function Fa() {
                Ui.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }
  
            function za(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Ce)
                }
            }
  
            function Ba() {
                Ui.call(this), this.type = "Bone"
            }
  
            function ja(t, e) {
                Zr.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ce, this.bindMatrixInverse = new Ce;
                var n = new za(this.initBones());
                this.bind(n, this.matrixWorld), this.normalizeSkinWeights()
            }
  
            function Ga(t) {
                ai.call(this), this.type = "LineBasicMaterial", this.color = new Cn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
            }
  
            function Ha(t, e, n) {
                if (1 === n) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new Va(t, e);
                Ui.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Br, this.material = void 0 !== e ? e : new Ga({
                    color: 16777215 * Math.random()
                })
            }
  
            function Va(t, e) {
                Ha.call(this, t, e), this.type = "LineSegments"
            }
  
            function Wa(t, e) {
                Ha.call(this, t, e), this.type = "LineLoop"
            }
  
            function Xa(t) {
                ai.call(this), this.type = "PointsMaterial", this.color = new Cn(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t)
            }
  
            function qa(t, e) {
                Ui.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Br, this.material = void 0 !== e ? e : new Xa({
                    color: 16777215 * Math.random()
                })
            }
  
            function Ya() {
                Ui.call(this), this.type = "Group"
            }
  
            function $a(t, e, n, i, r, a, o, s, c) {
                ke.call(this, t, e, n, i, r, a, o, s, c), this.generateMipmaps = !1;
                var l = this;
                t.addEventListener("loadeddata", function e() {
                    t.removeEventListener("loadeddata", e, !1), l.needsUpdate = !0
                }, !1)
            }
  
            function Za(t, e, n, i, r, a, o, s, c, l, u, h) {
                ke.call(this, null, a, o, s, c, l, i, r, u, h), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }
  
            function Ja(t, e, n, i, r, a, o, s, c, l) {
                if ((l = void 0 !== l ? l : Qt) !== Qt && l !== te) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && l === Qt && (n = Ft), void 0 === n && l === te && (n = Xt), ke.call(this, null, i, r, a, o, s, l, n, c), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== o ? o : Pt, this.minFilter = void 0 !== s ? s : Pt, this.flipY = !1, this.generateMipmaps = !1
            }
  
            function Ka(t) {
                Br.call(this), this.type = "WireframeGeometry";
                var e, n, i, r, a, o, s, c, l, u, h = [],
                    d = [0, 0],
                    p = {},
                    f = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    var m = t.faces;
                    for (e = 0, i = m.length; e < i; e++) {
                        var v = m[e];
                        for (n = 0; n < 3; n++) s = v[f[n]], c = v[f[(n + 1) % 3]], d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[l = d[0] + "," + d[1]] && (p[l] = {
                            index1: d[0],
                            index2: d[1]
                        })
                    }
                    for (l in p) o = p[l], u = t.vertices[o.index1], h.push(u.x, u.y, u.z), u = t.vertices[o.index2], h.push(u.x, u.y, u.z)
                } else if (t && t.isBufferGeometry) {
                    var g, y, x, b, w, _, M;
                    if (u = new Oe, null !== t.index) {
                        for (g = t.attributes.position, y = t.index, 0 === (x = t.groups).length && (x = [{
                                start: 0,
                                count: y.count,
                                materialIndex: 0
                            }]), r = 0, a = x.length; r < a; ++r)
                            for (e = w = (b = x[r]).start, i = w + b.count; e < i; e += 3)
                                for (n = 0; n < 3; n++) s = y.getX(e + n), c = y.getX(e + (n + 1) % 3), d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[l = d[0] + "," + d[1]] && (p[l] = {
                                    index1: d[0],
                                    index2: d[1]
                                });
                        for (l in p) o = p[l], u.fromBufferAttribute(g, o.index1), h.push(u.x, u.y, u.z), u.fromBufferAttribute(g, o.index2), h.push(u.x, u.y, u.z)
                    } else
                        for (e = 0, i = (g = t.attributes.position).count / 3; e < i; e++)
                            for (n = 0; n < 3; n++) _ = 3 * e + n, u.fromBufferAttribute(g, _), h.push(u.x, u.y, u.z), M = 3 * e + (n + 1) % 3, u.fromBufferAttribute(g, M), h.push(u.x, u.y, u.z)
                }
                this.addAttribute("position", new nr(h, 3))
            }
  
            function Qa(t, e, n) {
                qi.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                }, this.fromBufferGeometry(new to(t, e, n)), this.mergeVertices()
            }
  
            function to(t, e, n) {
                Br.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
                var i, r, a = [],
                    o = [],
                    s = [],
                    c = [],
                    l = new Oe,
                    u = new Oe,
                    h = new Oe,
                    d = new Oe,
                    p = new Oe,
                    f = e + 1;
                for (i = 0; i <= n; i++) {
                    var m = i / n;
                    for (r = 0; r <= e; r++) {
                        var v = r / e;
                        u = t(v, m, u), o.push(u.x, u.y, u.z), v - 1e-5 >= 0 ? (h = t(v - 1e-5, m, h), d.subVectors(u, h)) : (h = t(v + 1e-5, m, h), d.subVectors(h, u)), m - 1e-5 >= 0 ? (h = t(v, m - 1e-5, h), p.subVectors(u, h)) : (h = t(v, m + 1e-5, h), p.subVectors(h, u)), l.crossVectors(d, p).normalize(), s.push(l.x, l.y, l.z), c.push(v, m)
                    }
                }
                for (i = 0; i < n; i++)
                    for (r = 0; r < e; r++) {
                        var g = i * f + r,
                            y = i * f + r + 1,
                            x = (i + 1) * f + r + 1,
                            b = (i + 1) * f + r;
                        a.push(g, y, b), a.push(y, x, b)
                    }
                this.setIndex(a), this.addAttribute("position", new nr(o, 3)), this.addAttribute("normal", new nr(s, 3)), this.addAttribute("uv", new nr(c, 2))
            }
  
            function eo(t, e, n, i) {
                qi.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: i
                }, this.fromBufferGeometry(new no(t, e, n, i)), this.mergeVertices()
            }
  
            function no(t, e, n, i) {
                Br.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: i
                }, n = n || 1;
                var r = [],
                    a = [];
  
                function o(t, e, n, i) {
                    var r, a, o = Math.pow(2, i),
                        c = [];
                    for (r = 0; r <= o; r++) {
                        c[r] = [];
                        var l = t.clone().lerp(n, r / o),
                            u = e.clone().lerp(n, r / o),
                            h = o - r;
                        for (a = 0; a <= h; a++) c[r][a] = 0 === a && r === o ? l : l.clone().lerp(u, a / h)
                    }
                    for (r = 0; r < o; r++)
                        for (a = 0; a < 2 * (o - r) - 1; a++) {
                            var d = Math.floor(a / 2);
                            a % 2 == 0 ? (s(c[r][d + 1]), s(c[r + 1][d]), s(c[r][d])) : (s(c[r][d + 1]), s(c[r + 1][d + 1]), s(c[r + 1][d]))
                        }
                }
  
                function s(t) {
                    r.push(t.x, t.y, t.z)
                }
  
                function c(e, n) {
                    var i = 3 * e;
                    n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
                }
  
                function l(t, e, n, i) {
                    i < 0 && 1 === t.x && (a[e] = t.x - 1), 0 === n.x && 0 === n.z && (a[e] = i / 2 / Math.PI + .5)
                }
  
                function u(t) {
                    return Math.atan2(t.z, -t.x)
                }! function(t) {
                    for (var n = new Oe, i = new Oe, r = new Oe, a = 0; a < e.length; a += 3) c(e[a + 0], n), c(e[a + 1], i), c(e[a + 2], r), o(n, i, r, t)
                }(i = i || 0),
                function(t) {
                    for (var e = new Oe, n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
                }(n),
                function() {
                    for (var t = new Oe, e = 0; e < r.length; e += 3) {
                        t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                        var n = u(t) / 2 / Math.PI + .5,
                            i = (o = t, Math.atan2(-o.y, Math.sqrt(o.x * o.x + o.z * o.z)) / Math.PI + .5);
                        a.push(n, 1 - i)
                    }
                    var o;
                    (function() {
                        for (var t = new Oe, e = new Oe, n = new Oe, i = new Oe, o = new Pe, s = new Pe, c = new Pe, h = 0, d = 0; h < r.length; h += 9, d += 6) {
                            t.set(r[h + 0], r[h + 1], r[h + 2]), e.set(r[h + 3], r[h + 4], r[h + 5]), n.set(r[h + 6], r[h + 7], r[h + 8]), o.set(a[d + 0], a[d + 1]), s.set(a[d + 2], a[d + 3]), c.set(a[d + 4], a[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                            var p = u(i);
                            l(o, d + 0, t, p), l(s, d + 2, e, p), l(c, d + 4, n, p)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < a.length; t += 6) {
                            var e = a[t + 0],
                                n = a[t + 2],
                                i = a[t + 4],
                                r = Math.max(e, n, i),
                                o = Math.min(e, n, i);
                            r > .9 && o < .1 && (e < .2 && (a[t + 0] += 1), n < .2 && (a[t + 2] += 1), i < .2 && (a[t + 4] += 1))
                        }
                    }()
                }(), this.addAttribute("position", new nr(r, 3)), this.addAttribute("normal", new nr(r.slice(), 3)), this.addAttribute("uv", new nr(a, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
            }
  
            function io(t, e) {
                qi.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new ro(t, e)), this.mergeVertices()
            }
  
            function ro(t, e) {
                no.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }
  
            function ao(t, e) {
                qi.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new oo(t, e)), this.mergeVertices()
            }
  
            function oo(t, e) {
                no.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }
  
            function so(t, e) {
                qi.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new co(t, e)), this.mergeVertices()
            }
  
            function co(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                no.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }
  
            function lo(t, e) {
                qi.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new uo(t, e)), this.mergeVertices()
            }
  
            function uo(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = 1 / n,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
                no.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }
  
            function ho(t, e, n, i, r, a) {
                qi.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
                var o = new po(t, e, n, i, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
            }
  
            function po(t, e, n, i, r) {
                Br.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, e = e || 64, n = n || 1, i = i || 8, r = r || !1;
                var a = t.computeFrenetFrames(e, r);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
                var o, s, c = new Oe,
                    l = new Oe,
                    u = new Pe,
                    h = new Oe,
                    d = [],
                    p = [],
                    f = [],
                    m = [];
  
                function v(r) {
                    h = t.getPointAt(r / e, h);
                    var o = a.normals[r],
                        u = a.binormals[r];
                    for (s = 0; s <= i; s++) {
                        var f = s / i * Math.PI * 2,
                            m = Math.sin(f),
                            v = -Math.cos(f);
                        l.x = v * o.x + m * u.x, l.y = v * o.y + m * u.y, l.z = v * o.z + m * u.z, l.normalize(), p.push(l.x, l.y, l.z), c.x = h.x + n * l.x, c.y = h.y + n * l.y, c.z = h.z + n * l.z, d.push(c.x, c.y, c.z)
                    }
                }! function() {
                    for (o = 0; o < e; o++) v(o);
                    v(!1 === r ? e : 0),
                        function() {
                            for (o = 0; o <= e; o++)
                                for (s = 0; s <= i; s++) u.x = o / e, u.y = s / i, f.push(u.x, u.y)
                        }(),
                        function() {
                            for (s = 1; s <= e; s++)
                                for (o = 1; o <= i; o++) {
                                    var t = (i + 1) * (s - 1) + (o - 1),
                                        n = (i + 1) * s + (o - 1),
                                        r = (i + 1) * s + o,
                                        a = (i + 1) * (s - 1) + o;
                                    m.push(t, n, a), m.push(n, r, a)
                                }
                        }()
                }(), this.setIndex(m), this.addAttribute("position", new nr(d, 3)), this.addAttribute("normal", new nr(p, 3)), this.addAttribute("uv", new nr(f, 2))
            }
  
            function fo(t, e, n, i, r, a, o) {
                qi.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: a
                }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new mo(t, e, n, i, r, a)), this.mergeVertices()
            }
  
            function mo(t, e, n, i, r, a) {
                Br.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: a
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, a = a || 3;
                var o, s, c = [],
                    l = [],
                    u = [],
                    h = [],
                    d = new Oe,
                    p = new Oe,
                    f = new Oe,
                    m = new Oe,
                    v = new Oe,
                    g = new Oe,
                    y = new Oe;
                for (o = 0; o <= n; ++o) {
                    var x = o / n * r * Math.PI * 2;
                    for (A(x, r, a, t, f), A(x + .01, r, a, t, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= i; ++s) {
                        var b = s / i * Math.PI * 2,
                            w = -e * Math.cos(b),
                            _ = e * Math.sin(b);
                        d.x = f.x + (w * y.x + _ * v.x), d.y = f.y + (w * y.y + _ * v.y), d.z = f.z + (w * y.z + _ * v.z), l.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), u.push(p.x, p.y, p.z), h.push(o / n), h.push(s / i)
                    }
                }
                for (s = 1; s <= n; s++)
                    for (o = 1; o <= i; o++) {
                        var M = (i + 1) * (s - 1) + (o - 1),
                            E = (i + 1) * s + (o - 1),
                            T = (i + 1) * s + o,
                            S = (i + 1) * (s - 1) + o;
                        c.push(M, E, S), c.push(E, T, S)
                    }
  
                function A(t, e, n, i, r) {
                    var a = Math.cos(t),
                        o = Math.sin(t),
                        s = n / e * t,
                        c = Math.cos(s);
                    r.x = i * (2 + c) * .5 * a, r.y = i * (2 + c) * o * .5, r.z = i * Math.sin(s) * .5
                }
                this.setIndex(c), this.addAttribute("position", new nr(l, 3)), this.addAttribute("normal", new nr(u, 3)), this.addAttribute("uv", new nr(h, 2))
            }
  
            function vo(t, e, n, i, r) {
                qi.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, this.fromBufferGeometry(new go(t, e, n, i, r)), this.mergeVertices()
            }
  
            function go(t, e, n, i, r) {
                Br.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
                var a, o, s = [],
                    c = [],
                    l = [],
                    u = [],
                    h = new Oe,
                    d = new Oe,
                    p = new Oe;
                for (a = 0; a <= n; a++)
                    for (o = 0; o <= i; o++) {
                        var f = o / i * r,
                            m = a / n * Math.PI * 2;
                        d.x = (t + e * Math.cos(m)) * Math.cos(f), d.y = (t + e * Math.cos(m)) * Math.sin(f), d.z = e * Math.sin(m), c.push(d.x, d.y, d.z), h.x = t * Math.cos(f), h.y = t * Math.sin(f), p.subVectors(d, h).normalize(), l.push(p.x, p.y, p.z), u.push(o / i), u.push(a / n)
                    }
                for (a = 1; a <= n; a++)
                    for (o = 1; o <= i; o++) {
                        var v = (i + 1) * a + o - 1,
                            g = (i + 1) * (a - 1) + o - 1,
                            y = (i + 1) * (a - 1) + o,
                            x = (i + 1) * a + o;
                        s.push(v, g, x), s.push(g, y, x)
                    }
                this.setIndex(s), this.addAttribute("position", new nr(c, 3)), this.addAttribute("normal", new nr(l, 3)), this.addAttribute("uv", new nr(u, 2))
            }
            Aa.prototype = Object.assign(Object.create(ki.prototype), {
                constructor: Aa,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return ki.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    var e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * Le.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var t = Math.tan(.5 * Le.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * Le.RAD2DEG * Math.atan(Math.tan(.5 * Le.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, i, r, a) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = this.near,
                        e = t * Math.tan(.5 * Le.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * e,
                        i = this.aspect * n,
                        r = -.5 * i,
                        a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var o = a.fullWidth,
                            s = a.fullHeight;
                        r += a.offsetX * i / o, e -= a.offsetY * n / s, i *= a.width / o, n *= a.height / s
                    }
                    var c = this.filmOffset;
                    0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far)
                },
                toJSON: function(t) {
                    var e = Ui.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            }), La.prototype = Object.assign(Object.create(Aa.prototype), {
                constructor: La,
                isArrayCamera: !0
            }), Oa.prototype.isFogExp2 = !0, Oa.prototype.clone = function() {
                return new Oa(this.color.getHex(), this.density)
            }, Oa.prototype.toJSON = function() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }, Ia.prototype.isFog = !0, Ia.prototype.clone = function() {
                return new Ia(this.color.getHex(), this.near, this.far)
            }, Ia.prototype.toJSON = function() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }, Na.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Na,
                copy: function(t, e) {
                    return Ui.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                },
                toJSON: function(t) {
                    var e = Ui.prototype.toJSON.call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }), Da.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Da,
                isLensFlare: !0,
                copy: function(t) {
                    Ui.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback;
                    for (var e = 0, n = t.lensFlares.length; e < n; e++) this.lensFlares.push(t.lensFlares[e]);
                    return this
                },
                add: function(t, e, n, i, r, a) {
                    void 0 === e && (e = -1), void 0 === n && (n = 0), void 0 === a && (a = 1), void 0 === r && (r = new Cn(16777215)), void 0 === i && (i = U), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
                        texture: t,
                        size: e,
                        distance: n,
                        x: 0,
                        y: 0,
                        z: 0,
                        scale: 1,
                        rotation: 0,
                        opacity: a,
                        color: r,
                        blending: i
                    })
                },
                updateLensFlares: function() {
                    var t, e, n = this.lensFlares.length,
                        i = 2 * -this.positionScreen.x,
                        r = 2 * -this.positionScreen.y;
                    for (t = 0; t < n; t++)(e = this.lensFlares[t]).x = this.positionScreen.x + i * e.distance, e.y = this.positionScreen.y + r * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation)
                }
            }), Ua.prototype = Object.create(ai.prototype), Ua.prototype.constructor = Ua, Ua.prototype.isSpriteMaterial = !0, Ua.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this
            }, ka.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: ka,
                isSprite: !0,
                raycast: (ia = new Oe, ra = new Oe, aa = new Oe, function(t, e) {
                    ra.setFromMatrixPosition(this.matrixWorld), t.ray.closestPointToPoint(ra, ia), aa.setFromMatrixScale(this.matrixWorld);
                    var n = aa.x * aa.y / 4;
                    if (!(ra.distanceToSquared(ia) > n)) {
                        var i = t.ray.origin.distanceTo(ia);
                        i < t.near || i > t.far || e.push({
                            distance: i,
                            point: ia.clone(),
                            face: null,
                            object: this
                        })
                    }
                }),
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                }
            }), Fa.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Fa,
                copy: function(t) {
                    Ui.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++);
                    n.splice(i, 0, {
                        distance: e,
                        object: t
                    }), this.add(t)
                },
                getObjectForDistance: function(t) {
                    for (var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                    return e[n - 1].object
                },
                raycast: (ca = new Oe, function(t, e) {
                    ca.setFromMatrixPosition(this.matrixWorld);
                    var n = t.ray.origin.distanceTo(ca);
                    this.getObjectForDistance(n).raycast(t, e)
                }),
                update: (oa = new Oe, sa = new Oe, function(t) {
                    var e = this.levels;
                    if (e.length > 1) {
                        oa.setFromMatrixPosition(t.matrixWorld), sa.setFromMatrixPosition(this.matrixWorld);
                        var n = oa.distanceTo(sa);
                        e[0].object.visible = !0;
                        for (var i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                        for (; i < r; i++) e[i].object.visible = !1
                    }
                }),
                toJSON: function(t) {
                    var e = Ui.prototype.toJSON.call(this, t);
                    e.object.levels = [];
                    for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        e.object.levels.push({
                            object: a.object.uuid,
                            distance: a.distance
                        })
                    }
                    return e
                }
            }), Object.assign(za.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var n = new Ce;
                        this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function() {
                    var t, e, n;
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                },
                update: (la = new Ce, ua = new Ce, function() {
                    for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, a = t.length; r < a; r++) {
                        var o = t[r] ? t[r].matrixWorld : ua;
                        la.multiplyMatrices(o, e[r]), la.toArray(n, 16 * r)
                    }
                    void 0 !== i && (i.needsUpdate = !0)
                }),
                clone: function() {
                    return new za(this.bones, this.boneInverses)
                }
            }), Ba.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Ba,
                isBone: !0
            }), ja.prototype = Object.assign(Object.create(Zr.prototype), {
                constructor: ja,
                isSkinnedMesh: !0,
                initBones: function() {
                    var t, e, n, i, r = [];
                    if (this.geometry && void 0 !== this.geometry.bones) {
                        for (n = 0, i = this.geometry.bones.length; n < i; n++) e = this.geometry.bones[n], t = new Ba, r.push(t), t.name = e.name, t.position.fromArray(e.pos), t.quaternion.fromArray(e.rotq), void 0 !== e.scl && t.scale.fromArray(e.scl);
                        for (n = 0, i = this.geometry.bones.length; n < i; n++) - 1 !== (e = this.geometry.bones[n]).parent && null !== e.parent && void 0 !== r[e.parent] ? r[e.parent].add(r[n]) : this.add(r[n])
                    }
                    return this.updateMatrixWorld(!0), r
                },
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    var t, e;
                    if (this.geometry && this.geometry.isGeometry)
                        for (e = 0; e < this.geometry.skinWeights.length; e++) {
                            var n = this.geometry.skinWeights[e];
                            (t = 1 / n.manhattanLength()) !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0)
                        } else if (this.geometry && this.geometry.isBufferGeometry) {
                            var i = new Fe,
                                r = this.geometry.attributes.skinWeight;
                            for (e = 0; e < r.count; e++) i.x = r.getX(e), i.y = r.getY(e), i.z = r.getZ(e), i.w = r.getW(e), (t = 1 / i.manhattanLength()) !== 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0), r.setXYZW(e, i.x, i.y, i.z, i.w)
                        }
                },
                updateMatrixWorld: function(t) {
                    Zr.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Ga.prototype = Object.create(ai.prototype), Ga.prototype.constructor = Ga, Ga.prototype.isLineBasicMaterial = !0, Ga.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            }, Ha.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Ha,
                isLine: !0,
                raycast: (ha = new Ce, da = new qr, pa = new li, function(t, e) {
                    var n = t.linePrecision,
                        i = n * n,
                        r = this.geometry,
                        a = this.matrixWorld;
                    if (null === r.boundingSphere && r.computeBoundingSphere(), pa.copy(r.boundingSphere), pa.applyMatrix4(a), !1 !== t.ray.intersectsSphere(pa)) {
                        ha.getInverse(a), da.copy(t.ray).applyMatrix4(ha);
                        var o = new Oe,
                            s = new Oe,
                            c = new Oe,
                            l = new Oe,
                            u = this && this.isLineSegments ? 2 : 1;
                        if (r.isBufferGeometry) {
                            var h = r.index,
                                d = r.attributes.position.array;
                            if (null !== h)
                                for (var p = h.array, f = 0, m = p.length - 1; f < m; f += u) {
                                    var v = p[f],
                                        g = p[f + 1];
                                    o.fromArray(d, 3 * v), s.fromArray(d, 3 * g), da.distanceSqToSegment(o, s, l, c) > i || (l.applyMatrix4(this.matrixWorld), (b = t.ray.origin.distanceTo(l)) < t.near || b > t.far || e.push({
                                        distance: b,
                                        point: c.clone().applyMatrix4(this.matrixWorld),
                                        index: f,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                                } else
                                    for (f = 0, m = d.length / 3 - 1; f < m; f += u) o.fromArray(d, 3 * f), s.fromArray(d, 3 * f + 3), da.distanceSqToSegment(o, s, l, c) > i || (l.applyMatrix4(this.matrixWorld), (b = t.ray.origin.distanceTo(l)) < t.near || b > t.far || e.push({
                                        distance: b,
                                        point: c.clone().applyMatrix4(this.matrixWorld),
                                        index: f,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                        } else if (r.isGeometry) {
                            var y = r.vertices,
                                x = y.length;
                            for (f = 0; f < x - 1; f += u) {
                                var b;
                                da.distanceSqToSegment(y[f], y[f + 1], l, c) > i || (l.applyMatrix4(this.matrixWorld), (b = t.ray.origin.distanceTo(l)) < t.near || b > t.far || e.push({
                                    distance: b,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: f,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        }
                    }
                }),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Va.prototype = Object.assign(Object.create(Ha.prototype), {
                constructor: Va,
                isLineSegments: !0
            }), Wa.prototype = Object.assign(Object.create(Ha.prototype), {
                constructor: Wa,
                isLineLoop: !0
            }), Xa.prototype = Object.create(ai.prototype), Xa.prototype.constructor = Xa, Xa.prototype.isPointsMaterial = !0, Xa.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
            }, qa.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: qa,
                isPoints: !0,
                raycast: (fa = new Ce, ma = new qr, va = new li, function(t, e) {
                    var n = this,
                        i = this.geometry,
                        r = this.matrixWorld,
                        a = t.params.Points.threshold;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), va.copy(i.boundingSphere), va.applyMatrix4(r), va.radius += a, !1 !== t.ray.intersectsSphere(va)) {
                        fa.getInverse(r), ma.copy(t.ray).applyMatrix4(fa);
                        var o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            s = o * o,
                            c = new Oe;
                        if (i.isBufferGeometry) {
                            var l = i.index,
                                u = i.attributes.position.array;
                            if (null !== l)
                                for (var h = l.array, d = 0, p = h.length; d < p; d++) {
                                    var f = h[d];
                                    c.fromArray(u, 3 * f), g(c, f)
                                } else {
                                    d = 0;
                                    for (var m = u.length / 3; d < m; d++) c.fromArray(u, 3 * d), g(c, d)
                                }
                        } else {
                            var v = i.vertices;
                            for (d = 0, m = v.length; d < m; d++) g(v[d], d)
                        }
                    }
  
                    function g(i, a) {
                        var o = ma.distanceSqToPoint(i);
                        if (o < s) {
                            var c = ma.closestPointToPoint(i);
                            c.applyMatrix4(r);
                            var l = t.ray.origin.distanceTo(c);
                            if (l < t.near || l > t.far) return;
                            e.push({
                                distance: l,
                                distanceToRay: Math.sqrt(o),
                                point: c.clone(),
                                index: a,
                                face: null,
                                object: n
                            })
                        }
                    }
                }),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Ya.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Ya,
                isGroup: !0
            }), $a.prototype = Object.assign(Object.create(ke.prototype), {
                constructor: $a,
                isVideoTexture: !0,
                update: function() {
                    var t = this.image;
                    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), Za.prototype = Object.create(ke.prototype), Za.prototype.constructor = Za, Za.prototype.isCompressedTexture = !0, Ja.prototype = Object.create(ke.prototype), Ja.prototype.constructor = Ja, Ja.prototype.isDepthTexture = !0, Ka.prototype = Object.create(Br.prototype), Ka.prototype.constructor = Ka, Qa.prototype = Object.create(qi.prototype), Qa.prototype.constructor = Qa, to.prototype = Object.create(Br.prototype), to.prototype.constructor = to, eo.prototype = Object.create(qi.prototype), eo.prototype.constructor = eo, no.prototype = Object.create(Br.prototype), no.prototype.constructor = no, io.prototype = Object.create(qi.prototype), io.prototype.constructor = io, ro.prototype = Object.create(no.prototype), ro.prototype.constructor = ro, ao.prototype = Object.create(qi.prototype), ao.prototype.constructor = ao, oo.prototype = Object.create(no.prototype), oo.prototype.constructor = oo, so.prototype = Object.create(qi.prototype), so.prototype.constructor = so, co.prototype = Object.create(no.prototype), co.prototype.constructor = co, lo.prototype = Object.create(qi.prototype), lo.prototype.constructor = lo, uo.prototype = Object.create(no.prototype), uo.prototype.constructor = uo, ho.prototype = Object.create(qi.prototype), ho.prototype.constructor = ho, po.prototype = Object.create(Br.prototype), po.prototype.constructor = po, fo.prototype = Object.create(qi.prototype), fo.prototype.constructor = fo, mo.prototype = Object.create(Br.prototype), mo.prototype.constructor = mo, vo.prototype = Object.create(qi.prototype), vo.prototype.constructor = vo, go.prototype = Object.create(Br.prototype), go.prototype.constructor = go;
            var yo = function(t, e, n) {
                n = n || 2;
                var i, r, a, o, s, c, l, u = e && e.length,
                    h = u ? e[0] * n : t.length,
                    d = xo(t, 0, h, n, !0),
                    p = [];
                if (!d) return p;
                if (u && (d = function(t, e, n, i) {
                        var r, a, o, s, c, l = [];
                        for (r = 0, a = e.length; r < a; r++) o = e[r] * i, s = r < a - 1 ? e[r + 1] * i : t.length, (c = xo(t, o, s, i, !1)) === c.next && (c.steiner = !0), l.push(Po(c));
                        for (l.sort(So), r = 0; r < l.length; r++) Ao(l[r], n), n = bo(n, n.next);
                        return n
                    }(t, e, d, n)), t.length > 80 * n) {
                    i = a = t[0], r = o = t[1];
                    for (var f = n; f < h; f += n)(s = t[f]) < i && (i = s), (c = t[f + 1]) < r && (r = c), s > a && (a = s), c > o && (o = c);
                    l = 0 !== (l = Math.max(a - i, o - r)) ? 1 / l : 0
                }
                return wo(d, p, n, i, r, l), p
            };
  
            function xo(t, e, n, i, r) {
                var a, o;
                if (r === function(t, e, n, i) {
                        for (var r = 0, a = e, o = n - i; a < n; a += i) r += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;
                        return r
                    }(t, e, n, i) > 0)
                    for (a = e; a < n; a += i) o = Uo(a, t[a], t[a + 1], o);
                else
                    for (a = n - i; a >= e; a -= i) o = Uo(a, t[a], t[a + 1], o);
                return o && Oo(o, o.next) && (ko(o), o = o.next), o
            }
  
            function bo(t, e) {
                if (!t) return t;
                e || (e = t);
                var n, i = t;
                do {
                    if (n = !1, i.steiner || !Oo(i, i.next) && 0 !== Ro(i.prev, i, i.next)) i = i.next;
                    else {
                        if (ko(i), (i = e = i.prev) === i.next) break;
                        n = !0
                    }
                } while (n || i !== e);
                return e
            }
  
            function wo(t, e, n, i, r, a, o) {
                if (t) {
                    !o && a && function(t, e, n, i) {
                        var r = t;
                        do {
                            null === r.z && (r.z = Lo(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                var e, n, i, r, a, o, s, c, l = 1;
                                do {
                                    for (n = t, t = null, a = null, o = 0; n;) {
                                        for (o++, i = n, s = 0, e = 0; e < l && (s++, i = i.nextZ); e++);
                                        for (c = l; s > 0 || c > 0 && i;) 0 !== s && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, c--), a ? a.nextZ = r : t = r, r.prevZ = a, a = r;
                                        n = i
                                    }
                                    a.nextZ = null, l *= 2
                                } while (o > 1)
                            }(r)
                    }(t, i, r, a);
                    for (var s, c, l = t; t.prev !== t.next;)
                        if (s = t.prev, c = t.next, a ? Mo(t, i, r, a) : _o(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), ko(t), t = c.next, l = c.next;
                        else if ((t = c) === l) {
                        o ? 1 === o ? wo(t = Eo(t, e, n), e, n, i, r, a, 2) : 2 === o && To(t, e, n, i, r, a) : wo(bo(t), e, n, i, r, a, 1);
                        break
                    }
                }
            }
  
            function _o(t) {
                var e = t.prev,
                    n = t,
                    i = t.next;
                if (Ro(e, n, i) >= 0) return !1;
                for (var r = t.next.next; r !== t.prev;) {
                    if (Co(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Ro(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }
  
            function Mo(t, e, n, i) {
                var r = t.prev,
                    a = t,
                    o = t.next;
                if (Ro(r, a, o) >= 0) return !1;
                for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, c = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, l = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x, u = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, h = Lo(s, c, e, n, i), d = Lo(l, u, e, n, i), p = t.nextZ; p && p.z <= d;) {
                    if (p !== t.prev && p !== t.next && Co(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && Ro(p.prev, p, p.next) >= 0) return !1;
                    p = p.nextZ
                }
                for (p = t.prevZ; p && p.z >= h;) {
                    if (p !== t.prev && p !== t.next && Co(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && Ro(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                return !0
            }
  
            function Eo(t, e, n) {
                var i = t;
                do {
                    var r = i.prev,
                        a = i.next.next;
                    !Oo(r, a) && Io(r, i, i.next, a) && No(r, a) && No(a, r) && (e.push(r.i / n), e.push(i.i / n), e.push(a.i / n), ko(i), ko(i.next), i = t = a), i = i.next
                } while (i !== t);
                return i
            }
  
            function To(t, e, n, i, r, a) {
                var o, s, c = t;
                do {
                    for (var l = c.next.next; l !== c.prev;) {
                        if (c.i !== l.i && (s = l, (o = c).next.i !== s.i && o.prev.i !== s.i && ! function(t, e) {
                                var n = t;
                                do {
                                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Io(n, n.next, t, e)) return !0;
                                    n = n.next
                                } while (n !== t);
                                return !1
                            }(o, s) && No(o, s) && No(s, o) && function(t, e) {
                                var n = t,
                                    i = !1,
                                    r = (t.x + e.x) / 2,
                                    a = (t.y + e.y) / 2;
                                do {
                                    n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                                } while (n !== t);
                                return i
                            }(o, s))) {
                            var u = Do(c, l);
                            return c = bo(c, c.next), u = bo(u, u.next), wo(c, e, n, i, r, a), void wo(u, e, n, i, r, a)
                        }
                        l = l.next
                    }
                    c = c.next
                } while (c !== t)
            }
  
            function So(t, e) {
                return t.x - e.x
            }
  
            function Ao(t, e) {
                if (e = function(t, e) {
                        var n, i = e,
                            r = t.x,
                            a = t.y,
                            o = -1 / 0;
                        do {
                            if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                                var s = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                if (s <= r && s > o) {
                                    if (o = s, s === r) {
                                        if (a === i.y) return i;
                                        if (a === i.next.y) return i.next
                                    }
                                    n = i.x < i.next.x ? i : i.next
                                }
                            }
                            i = i.next
                        } while (i !== e);
                        if (!n) return null;
                        if (r === o) return n.prev;
                        var c, l = n,
                            u = n.x,
                            h = n.y,
                            d = 1 / 0;
                        i = n.next;
                        for (; i !== l;) r >= i.x && i.x >= u && r !== i.x && Co(a < h ? r : o, a, u, h, a < h ? o : r, a, i.x, i.y) && ((c = Math.abs(a - i.y) / (r - i.x)) < d || c === d && i.x > n.x) && No(i, t) && (n = i, d = c), i = i.next;
                        return n
                    }(t, e)) {
                    var n = Do(e, t);
                    bo(n, n.next)
                }
            }
  
            function Lo(t, e, n, i, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }
  
            function Po(t) {
                var e = t,
                    n = t;
                do {
                    e.x < n.x && (n = e), e = e.next
                } while (e !== t);
                return n
            }
  
            function Co(t, e, n, i, r, a, o, s) {
                return (r - o) * (e - s) - (t - o) * (a - s) >= 0 && (t - o) * (i - s) - (n - o) * (e - s) >= 0 && (n - o) * (a - s) - (r - o) * (i - s) >= 0
            }
  
            function Ro(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
            }
  
            function Oo(t, e) {
                return t.x === e.x && t.y === e.y
            }
  
            function Io(t, e, n, i) {
                return !!(Oo(t, e) && Oo(n, i) || Oo(t, i) && Oo(n, e)) || Ro(t, e, n) > 0 != Ro(t, e, i) > 0 && Ro(n, i, t) > 0 != Ro(n, i, e) > 0
            }
  
            function No(t, e) {
                return Ro(t.prev, t, t.next) < 0 ? Ro(t, e, t.next) >= 0 && Ro(t, t.prev, e) >= 0 : Ro(t, e, t.prev) < 0 || Ro(t, t.next, e) < 0
            }
  
            function Do(t, e) {
                var n = new Fo(t.i, t.x, t.y),
                    i = new Fo(e.i, e.x, e.y),
                    r = t.next,
                    a = e.prev;
                return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, a.next = i, i.prev = a, i
            }
  
            function Uo(t, e, n, i) {
                var r = new Fo(t, e, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }
  
            function ko(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }
  
            function Fo(t, e, n) {
                this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var zo = {
                area: function(t) {
                    for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                    return .5 * n
                },
                isClockWise: function(t) {
                    return zo.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    function n(t) {
                        var e = t.length;
                        e > 2 && t[e - 1].equals(t[0]) && t.pop()
                    }
  
                    function i(t, e) {
                        for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
                    }
                    var r = [],
                        a = [],
                        o = [];
                    n(t), i(r, t);
                    var s = t.length;
                    for (e.forEach(n), l = 0; l < e.length; l++) a.push(s), s += e[l].length, i(r, e[l]);
                    for (var c = yo(r, a), l = 0; l < c.length; l += 3) o.push(c.slice(l, l + 3));
                    return o
                }
            };
  
            function Bo(t, e) {
                qi.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new jo(t, e)), this.mergeVertices()
            }
  
            function jo(t, e) {
                void 0 !== t && (Br.call(this), this.type = "ExtrudeBufferGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeVertexNormals())
            }
  
            function Go(t, e) {
                qi.call(this), this.type = "TextGeometry", this.parameters = {
                    text: t,
                    parameters: e
                }, this.fromBufferGeometry(new Ho(t, e)), this.mergeVertices()
            }
  
            function Ho(t, e) {
                var n = (e = e || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new qi;
                var i = n.generateShapes(t, e.size, e.curveSegments);
                e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), jo.call(this, i, e), this.type = "TextBufferGeometry"
            }
  
            function Vo(t, e, n, i, r, a, o) {
                qi.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: o
                }, this.fromBufferGeometry(new Wo(t, e, n, i, r, a, o)), this.mergeVertices()
            }
  
            function Wo(t, e, n, i, r, a, o) {
                Br.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: o
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var s, c, l = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI),
                    u = 0,
                    h = [],
                    d = new Oe,
                    p = new Oe,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (c = 0; c <= n; c++) {
                    var y = [],
                        x = c / n;
                    for (s = 0; s <= e; s++) {
                        var b = s / e;
                        d.x = -t * Math.cos(i + b * r) * Math.sin(a + x * o), d.y = t * Math.cos(a + x * o), d.z = t * Math.sin(i + b * r) * Math.sin(a + x * o), m.push(d.x, d.y, d.z), p.set(d.x, d.y, d.z).normalize(), v.push(p.x, p.y, p.z), g.push(b, 1 - x), y.push(u++)
                    }
                    h.push(y)
                }
                for (c = 0; c < n; c++)
                    for (s = 0; s < e; s++) {
                        var w = h[c][s + 1],
                            _ = h[c][s],
                            M = h[c + 1][s],
                            E = h[c + 1][s + 1];
                        (0 !== c || a > 0) && f.push(w, _, E), (c !== n - 1 || l < Math.PI) && f.push(_, M, E)
                    }
                this.setIndex(f), this.addAttribute("position", new nr(m, 3)), this.addAttribute("normal", new nr(v, 3)), this.addAttribute("uv", new nr(g, 2))
            }
  
            function Xo(t, e, n, i, r, a) {
                qi.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: a
                }, this.fromBufferGeometry(new qo(t, e, n, i, r, a)), this.mergeVertices()
            }
  
            function qo(t, e, n, i, r, a) {
                Br.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: a
                }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
                var o, s, c, l = [],
                    u = [],
                    h = [],
                    d = [],
                    p = t,
                    f = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
                    m = new Oe,
                    v = new Pe;
                for (s = 0; s <= i; s++) {
                    for (c = 0; c <= n; c++) o = r + c / n * a, m.x = p * Math.cos(o), m.y = p * Math.sin(o), u.push(m.x, m.y, m.z), h.push(0, 0, 1), v.x = (m.x / e + 1) / 2, v.y = (m.y / e + 1) / 2, d.push(v.x, v.y);
                    p += f
                }
                for (s = 0; s < i; s++) {
                    var g = s * (n + 1);
                    for (c = 0; c < n; c++) {
                        var y = o = c + g,
                            x = o + n + 1,
                            b = o + n + 2,
                            w = o + 1;
                        l.push(y, x, w), l.push(x, b, w)
                    }
                }
                this.setIndex(l), this.addAttribute("position", new nr(u, 3)), this.addAttribute("normal", new nr(h, 3)), this.addAttribute("uv", new nr(d, 2))
            }
  
            function Yo(t, e, n, i) {
                qi.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: i
                }, this.fromBufferGeometry(new $o(t, e, n, i)), this.mergeVertices()
            }
  
            function $o(t, e, n, i) {
                Br.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: i
                }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = Le.clamp(i, 0, 2 * Math.PI);
                var r, a, o, s = [],
                    c = [],
                    l = [],
                    u = 1 / e,
                    h = new Oe,
                    d = new Pe;
                for (a = 0; a <= e; a++) {
                    var p = n + a * u * i,
                        f = Math.sin(p),
                        m = Math.cos(p);
                    for (o = 0; o <= t.length - 1; o++) h.x = t[o].x * f, h.y = t[o].y, h.z = t[o].x * m, c.push(h.x, h.y, h.z), d.x = a / e, d.y = o / (t.length - 1), l.push(d.x, d.y)
                }
                for (a = 0; a < e; a++)
                    for (o = 0; o < t.length - 1; o++) {
                        var v = r = o + a * t.length,
                            g = r + t.length,
                            y = r + t.length + 1,
                            x = r + 1;
                        s.push(v, g, x), s.push(g, y, x)
                    }
                if (this.setIndex(s), this.addAttribute("position", new nr(c, 3)), this.addAttribute("uv", new nr(l, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                    var b = this.attributes.normal.array,
                        w = new Oe,
                        _ = new Oe,
                        M = new Oe;
                    for (r = e * t.length * 3, a = 0, o = 0; a < t.length; a++, o += 3) w.x = b[o + 0], w.y = b[o + 1], w.z = b[o + 2], _.x = b[r + o + 0], _.y = b[r + o + 1], _.z = b[r + o + 2], M.addVectors(w, _).normalize(), b[o + 0] = b[r + o + 0] = M.x, b[o + 1] = b[r + o + 1] = M.y, b[o + 2] = b[r + o + 2] = M.z
                }
            }
  
            function Zo(t, e) {
                qi.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new Jo(t, e)), this.mergeVertices()
            }
  
            function Jo(t, e) {
                Br.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, e = e || 12;
                var n = [],
                    i = [],
                    r = [],
                    a = [],
                    o = 0,
                    s = 0;
                if (!1 === Array.isArray(t)) l(t);
                else
                    for (var c = 0; c < t.length; c++) l(t[c]), this.addGroup(o, s, c), o += s, s = 0;
  
                function l(t) {
                    var o, c, l, u = i.length / 3,
                        h = t.extractPoints(e),
                        d = h.shape,
                        p = h.holes;
                    if (!1 === zo.isClockWise(d))
                        for (d = d.reverse(), o = 0, c = p.length; o < c; o++) l = p[o], !0 === zo.isClockWise(l) && (p[o] = l.reverse());
                    var f = zo.triangulateShape(d, p);
                    for (o = 0, c = p.length; o < c; o++) l = p[o], d = d.concat(l);
                    for (o = 0, c = d.length; o < c; o++) {
                        var m = d[o];
                        i.push(m.x, m.y, 0), r.push(0, 0, 1), a.push(m.x, m.y)
                    }
                    for (o = 0, c = f.length; o < c; o++) {
                        var v = f[o],
                            g = v[0] + u,
                            y = v[1] + u,
                            x = v[2] + u;
                        n.push(g, y, x), s += 3
                    }
                }
                this.setIndex(n), this.addAttribute("position", new nr(i, 3)), this.addAttribute("normal", new nr(r, 3)), this.addAttribute("uv", new nr(a, 2))
            }
  
            function Ko(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (var n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }
  
            function Qo(t, e) {
                Br.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var n, i, r, a, o = [],
                    s = Math.cos(Le.DEG2RAD * e),
                    c = [0, 0],
                    l = {},
                    u = ["a", "b", "c"];
                t.isBufferGeometry ? (a = new qi).fromBufferGeometry(t) : a = t.clone(), a.mergeVertices(), a.computeFaceNormals();
                for (var h = a.vertices, d = a.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], v = 0; v < 3; v++) n = m[u[v]], i = m[u[(v + 1) % 3]], c[0] = Math.min(n, i), c[1] = Math.max(n, i), void 0 === l[r = c[0] + "," + c[1]] ? l[r] = {
                        index1: c[0],
                        index2: c[1],
                        face1: p,
                        face2: void 0
                    } : l[r].face2 = p;
                for (r in l) {
                    var g = l[r];
                    if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
                        var y = h[g.index1];
                        o.push(y.x, y.y, y.z), y = h[g.index2], o.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new nr(o, 3))
            }
  
            function ts(t, e, n, i, r, a, o, s) {
                qi.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s
                }, this.fromBufferGeometry(new es(t, e, n, i, r, a, o, s)), this.mergeVertices()
            }
  
            function es(t, e, n, i, r, a, o, s) {
                Br.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s
                };
                var c = this;
                t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, a = void 0 !== a && a, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 * Math.PI;
                var l = [],
                    u = [],
                    h = [],
                    d = [],
                    p = 0,
                    f = [],
                    m = n / 2,
                    v = 0;
  
                function g(n) {
                    var r, a, f, g = new Pe,
                        y = new Oe,
                        x = 0,
                        b = !0 === n ? t : e,
                        w = !0 === n ? 1 : -1;
                    for (a = p, r = 1; r <= i; r++) u.push(0, m * w, 0), h.push(0, w, 0), d.push(.5, .5), p++;
                    for (f = p, r = 0; r <= i; r++) {
                        var _ = r / i * s + o,
                            M = Math.cos(_),
                            E = Math.sin(_);
                        y.x = b * E, y.y = m * w, y.z = b * M, u.push(y.x, y.y, y.z), h.push(0, w, 0), g.x = .5 * M + .5, g.y = .5 * E * w + .5, d.push(g.x, g.y), p++
                    }
                    for (r = 0; r < i; r++) {
                        var T = a + r,
                            S = f + r;
                        !0 === n ? l.push(S, S + 1, T) : l.push(S + 1, S, T), x += 3
                    }
                    c.addGroup(v, x, !0 === n ? 1 : 2), v += x
                }! function() {
                    var a, g, y = new Oe,
                        x = new Oe,
                        b = 0,
                        w = (e - t) / n;
                    for (g = 0; g <= r; g++) {
                        var _ = [],
                            M = g / r,
                            E = M * (e - t) + t;
                        for (a = 0; a <= i; a++) {
                            var T = a / i,
                                S = T * s + o,
                                A = Math.sin(S),
                                L = Math.cos(S);
                            x.x = E * A, x.y = -M * n + m, x.z = E * L, u.push(x.x, x.y, x.z), y.set(A, w, L).normalize(), h.push(y.x, y.y, y.z), d.push(T, 1 - M), _.push(p++)
                        }
                        f.push(_)
                    }
                    for (a = 0; a < i; a++)
                        for (g = 0; g < r; g++) {
                            var P = f[g][a],
                                C = f[g + 1][a],
                                R = f[g + 1][a + 1],
                                O = f[g][a + 1];
                            l.push(P, C, O), l.push(C, R, O), b += 6
                        }
                    c.addGroup(v, b, 0), v += b
                }(), !1 === a && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(l), this.addAttribute("position", new nr(u, 3)), this.addAttribute("normal", new nr(h, 3)), this.addAttribute("uv", new nr(d, 2))
            }
  
            function ns(t, e, n, i, r, a, o) {
                ts.call(this, 0, t, e, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: o
                }
            }
  
            function is(t, e, n, i, r, a, o) {
                es.call(this, 0, t, e, n, i, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: o
                }
            }
  
            function rs(t, e, n, i) {
                qi.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: i
                }, this.fromBufferGeometry(new as(t, e, n, i)), this.mergeVertices()
            }
  
            function as(t, e, n, i) {
                Br.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: i
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI;
                var r, a, o = [],
                    s = [],
                    c = [],
                    l = [],
                    u = new Oe,
                    h = new Pe;
                for (s.push(0, 0, 0), c.push(0, 0, 1), l.push(.5, .5), a = 0, r = 3; a <= e; a++, r += 3) {
                    var d = n + a / e * i;
                    u.x = t * Math.cos(d), u.y = t * Math.sin(d), s.push(u.x, u.y, u.z), c.push(0, 0, 1), h.x = (s[r] / t + 1) / 2, h.y = (s[r + 1] / t + 1) / 2, l.push(h.x, h.y)
                }
                for (r = 1; r <= e; r++) o.push(r, r + 1, 0);
                this.setIndex(o), this.addAttribute("position", new nr(s, 3)), this.addAttribute("normal", new nr(c, 3)), this.addAttribute("uv", new nr(l, 2))
            }
            Bo.prototype = Object.create(qi.prototype), Bo.prototype.constructor = Bo, jo.prototype = Object.create(Br.prototype), jo.prototype.constructor = jo, jo.prototype.getArrays = function() {
                var t = this.getAttribute("position"),
                    e = t ? Array.prototype.slice.call(t.array) : [],
                    n = this.getAttribute("uv"),
                    i = n ? Array.prototype.slice.call(n.array) : [],
                    r = this.index;
                return {
                    position: e,
                    uv: i,
                    index: r ? Array.prototype.slice.call(r.array) : []
                }
            }, jo.prototype.addShapeList = function(t, e) {
                var n = t.length;
                e.arrays = this.getArrays();
                for (var i = 0; i < n; i++) {
                    var r = t[i];
                    this.addShape(r, e)
                }
                this.setIndex(e.arrays.index), this.addAttribute("position", new nr(e.arrays.position, 3)), this.addAttribute("uv", new nr(e.arrays.uv, 2))
            }, jo.prototype.addShape = function(t, e) {
                var n, i, r, a, o, s, c, l, u = e.arrays ? e.arrays : this.getArrays(),
                    h = u.position,
                    d = u.index,
                    p = u.uv,
                    f = [],
                    m = void 0 !== e.amount ? e.amount : 100,
                    v = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                    g = void 0 !== e.bevelSize ? e.bevelSize : v - 2,
                    y = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                    x = void 0 === e.bevelEnabled || e.bevelEnabled,
                    b = void 0 !== e.curveSegments ? e.curveSegments : 12,
                    w = void 0 !== e.steps ? e.steps : 1,
                    _ = e.extrudePath,
                    M = !1,
                    E = void 0 !== e.UVGenerator ? e.UVGenerator : Bo.WorldUVGenerator;
                _ && (n = _.getSpacedPoints(w), M = !0, x = !1, i = void 0 !== e.frames ? e.frames : _.computeFrenetFrames(w, !1), r = new Oe, a = new Oe, o = new Oe), x || (y = 0, v = 0, g = 0);
                var T = this,
                    S = t.extractPoints(b),
                    A = S.shape,
                    L = S.holes;
                if (!zo.isClockWise(A))
                    for (A = A.reverse(), c = 0, l = L.length; c < l; c++) s = L[c], zo.isClockWise(s) && (L[c] = s.reverse());
                var P = zo.triangulateShape(A, L),
                    C = A;
                for (c = 0, l = L.length; c < l; c++) s = L[c], A = A.concat(s);
  
                function R(t, e, n) {
                    return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                }
                var O, I, N, D, U, k, F = A.length,
                    z = P.length;
  
                function B(t, e, n) {
                    var i, r, a, o = t.x - e.x,
                        s = t.y - e.y,
                        c = n.x - t.x,
                        l = n.y - t.y,
                        u = o * o + s * s,
                        h = o * l - s * c;
                    if (Math.abs(h) > Number.EPSILON) {
                        var d = Math.sqrt(u),
                            p = Math.sqrt(c * c + l * l),
                            f = e.x - s / d,
                            m = e.y + o / d,
                            v = ((n.x - l / p - f) * l - (n.y + c / p - m) * c) / (o * l - s * c),
                            g = (i = f + o * v - t.x) * i + (r = m + s * v - t.y) * r;
                        if (g <= 2) return new Pe(i, r);
                        a = Math.sqrt(g / 2)
                    } else {
                        var y = !1;
                        o > Number.EPSILON ? c > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0), y ? (i = -s, r = o, a = Math.sqrt(u)) : (i = o, r = s, a = Math.sqrt(u / 2))
                    }
                    return new Pe(i / a, r / a)
                }
                for (var j = [], G = 0, H = C.length, V = H - 1, W = G + 1; G < H; G++, V++, W++) V === H && (V = 0), W === H && (W = 0), j[G] = B(C[G], C[V], C[W]);
                var X, q, Y = [],
                    $ = j.concat();
                for (c = 0, l = L.length; c < l; c++) {
                    for (s = L[c], X = [], G = 0, V = (H = s.length) - 1, W = G + 1; G < H; G++, V++, W++) V === H && (V = 0), W === H && (W = 0), X[G] = B(s[G], s[V], s[W]);
                    Y.push(X), $ = $.concat(X)
                }
                for (O = 0; O < y; O++) {
                    for (N = O / y, D = v * Math.cos(N * Math.PI / 2), I = g * Math.sin(N * Math.PI / 2), G = 0, H = C.length; G < H; G++) J((U = R(C[G], j[G], I)).x, U.y, -D);
                    for (c = 0, l = L.length; c < l; c++)
                        for (s = L[c], X = Y[c], G = 0, H = s.length; G < H; G++) J((U = R(s[G], X[G], I)).x, U.y, -D)
                }
                for (I = g, G = 0; G < F; G++) U = x ? R(A[G], $[G], I) : A[G], M ? (a.copy(i.normals[0]).multiplyScalar(U.x), r.copy(i.binormals[0]).multiplyScalar(U.y), o.copy(n[0]).add(a).add(r), J(o.x, o.y, o.z)) : J(U.x, U.y, 0);
                for (q = 1; q <= w; q++)
                    for (G = 0; G < F; G++) U = x ? R(A[G], $[G], I) : A[G], M ? (a.copy(i.normals[q]).multiplyScalar(U.x), r.copy(i.binormals[q]).multiplyScalar(U.y), o.copy(n[q]).add(a).add(r), J(o.x, o.y, o.z)) : J(U.x, U.y, m / w * q);
                for (O = y - 1; O >= 0; O--) {
                    for (N = O / y, D = v * Math.cos(N * Math.PI / 2), I = g * Math.sin(N * Math.PI / 2), G = 0, H = C.length; G < H; G++) J((U = R(C[G], j[G], I)).x, U.y, m + D);
                    for (c = 0, l = L.length; c < l; c++)
                        for (s = L[c], X = Y[c], G = 0, H = s.length; G < H; G++) U = R(s[G], X[G], I), M ? J(U.x, U.y + n[w - 1].y, n[w - 1].x + D) : J(U.x, U.y, m + D)
                }
  
                function Z(t, e) {
                    var n, i;
                    for (G = t.length; --G >= 0;) {
                        n = G, (i = G - 1) < 0 && (i = t.length - 1);
                        var r = 0,
                            a = w + 2 * y;
                        for (r = 0; r < a; r++) {
                            var o = F * r,
                                s = F * (r + 1);
                            Q(e + n + o, e + i + o, e + i + s, e + n + s)
                        }
                    }
                }
  
                function J(t, e, n) {
                    f.push(t), f.push(e), f.push(n)
                }
  
                function K(t, e, n) {
                    tt(t), tt(e), tt(n);
                    var i = h.length / 3,
                        r = E.generateTopUV(T, h, i - 3, i - 2, i - 1);
                    et(r[0]), et(r[1]), et(r[2])
                }
  
                function Q(t, e, n, i) {
                    tt(t), tt(e), tt(i), tt(e), tt(n), tt(i);
                    var r = h.length / 3,
                        a = E.generateSideWallUV(T, h, r - 6, r - 3, r - 2, r - 1);
                    et(a[0]), et(a[1]), et(a[3]), et(a[1]), et(a[2]), et(a[3])
                }
  
                function tt(t) {
                    d.push(h.length / 3), h.push(f[3 * t + 0]), h.push(f[3 * t + 1]), h.push(f[3 * t + 2])
                }
  
                function et(t) {
                    p.push(t.x), p.push(t.y)
                }! function() {
                    var t = h.length / 3;
                    if (x) {
                        var n = 0,
                            i = F * n;
                        for (G = 0; G < z; G++) K((k = P[G])[2] + i, k[1] + i, k[0] + i);
                        for (i = F * (n = w + 2 * y), G = 0; G < z; G++) K((k = P[G])[0] + i, k[1] + i, k[2] + i)
                    } else {
                        for (G = 0; G < z; G++) K((k = P[G])[2], k[1], k[0]);
                        for (G = 0; G < z; G++) K((k = P[G])[0] + F * w, k[1] + F * w, k[2] + F * w)
                    }
                    T.addGroup(t, h.length / 3 - t, void 0 !== e.material ? e.material : 0)
                }(),
                function() {
                    var t = h.length / 3,
                        n = 0;
                    for (Z(C, n), n += C.length, c = 0, l = L.length; c < l; c++) Z(s = L[c], n), n += s.length;
                    T.addGroup(t, h.length / 3 - t, void 0 !== e.extrudeMaterial ? e.extrudeMaterial : 1)
                }(), e.arrays || (this.setIndex(d), this.addAttribute("position", new nr(h, 3)), this.addAttribute("uv", new nr(p, 2)))
            }, Bo.WorldUVGenerator = {
                generateTopUV: function(t, e, n, i, r) {
                    var a = e[3 * n],
                        o = e[3 * n + 1],
                        s = e[3 * i],
                        c = e[3 * i + 1],
                        l = e[3 * r],
                        u = e[3 * r + 1];
                    return [new Pe(a, o), new Pe(s, c), new Pe(l, u)]
                },
                generateSideWallUV: function(t, e, n, i, r, a) {
                    var o = e[3 * n],
                        s = e[3 * n + 1],
                        c = e[3 * n + 2],
                        l = e[3 * i],
                        u = e[3 * i + 1],
                        h = e[3 * i + 2],
                        d = e[3 * r],
                        p = e[3 * r + 1],
                        f = e[3 * r + 2],
                        m = e[3 * a],
                        v = e[3 * a + 1],
                        g = e[3 * a + 2];
                    return Math.abs(s - u) < .01 ? [new Pe(o, 1 - c), new Pe(l, 1 - h), new Pe(d, 1 - f), new Pe(m, 1 - g)] : [new Pe(s, 1 - c), new Pe(u, 1 - h), new Pe(p, 1 - f), new Pe(v, 1 - g)]
                }
            }, Go.prototype = Object.create(qi.prototype), Go.prototype.constructor = Go, Ho.prototype = Object.create(jo.prototype), Ho.prototype.constructor = Ho, Vo.prototype = Object.create(qi.prototype), Vo.prototype.constructor = Vo, Wo.prototype = Object.create(Br.prototype), Wo.prototype.constructor = Wo, Xo.prototype = Object.create(qi.prototype), Xo.prototype.constructor = Xo, qo.prototype = Object.create(Br.prototype), qo.prototype.constructor = qo, Yo.prototype = Object.create(qi.prototype), Yo.prototype.constructor = Yo, $o.prototype = Object.create(Br.prototype), $o.prototype.constructor = $o, Zo.prototype = Object.create(qi.prototype), Zo.prototype.constructor = Zo, Zo.prototype.toJSON = function() {
                var t = qi.prototype.toJSON.call(this);
                return Ko(this.parameters.shapes, t)
            }, Jo.prototype = Object.create(Br.prototype), Jo.prototype.constructor = Jo, Jo.prototype.toJSON = function() {
                var t = Br.prototype.toJSON.call(this);
                return Ko(this.parameters.shapes, t)
            }, Qo.prototype = Object.create(Br.prototype), Qo.prototype.constructor = Qo, ts.prototype = Object.create(qi.prototype), ts.prototype.constructor = ts, es.prototype = Object.create(Br.prototype), es.prototype.constructor = es, ns.prototype = Object.create(ts.prototype), ns.prototype.constructor = ns, is.prototype = Object.create(es.prototype), is.prototype.constructor = is, rs.prototype = Object.create(qi.prototype), rs.prototype.constructor = rs, as.prototype = Object.create(Br.prototype), as.prototype.constructor = as;
            var os = Object.freeze({
                WireframeGeometry: Ka,
                ParametricGeometry: Qa,
                ParametricBufferGeometry: to,
                TetrahedronGeometry: io,
                TetrahedronBufferGeometry: ro,
                OctahedronGeometry: ao,
                OctahedronBufferGeometry: oo,
                IcosahedronGeometry: so,
                IcosahedronBufferGeometry: co,
                DodecahedronGeometry: lo,
                DodecahedronBufferGeometry: uo,
                PolyhedronGeometry: eo,
                PolyhedronBufferGeometry: no,
                TubeGeometry: ho,
                TubeBufferGeometry: po,
                TorusKnotGeometry: fo,
                TorusKnotBufferGeometry: mo,
                TorusGeometry: vo,
                TorusBufferGeometry: go,
                TextGeometry: Go,
                TextBufferGeometry: Ho,
                SphereGeometry: Vo,
                SphereBufferGeometry: Wo,
                RingGeometry: Xo,
                RingBufferGeometry: qo,
                PlaneGeometry: Hr,
                PlaneBufferGeometry: Vr,
                LatheGeometry: Yo,
                LatheBufferGeometry: $o,
                ShapeGeometry: Zo,
                ShapeBufferGeometry: Jo,
                ExtrudeGeometry: Bo,
                ExtrudeBufferGeometry: jo,
                EdgesGeometry: Qo,
                ConeGeometry: ns,
                ConeBufferGeometry: is,
                CylinderGeometry: ts,
                CylinderBufferGeometry: es,
                CircleGeometry: rs,
                CircleBufferGeometry: as,
                BoxGeometry: jr,
                BoxBufferGeometry: Gr
            });
  
            function ss(t) {
                ai.call(this), this.type = "ShadowMaterial", this.color = new Cn(0), this.opacity = 1, this.lights = !0, this.transparent = !0, this.setValues(t)
            }
  
            function cs(t) {
                Xr.call(this, t), this.type = "RawShaderMaterial"
            }
  
            function ls(t) {
                ai.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new Cn(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Cn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new Pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }
  
            function us(t) {
                ls.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
            }
  
            function hs(t) {
                ai.call(this), this.type = "MeshPhongMaterial", this.color = new Cn(16777215), this.specular = new Cn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Cn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new Pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ht, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }
  
            function ds(t) {
                hs.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
            }
  
            function ps(t) {
                ai.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new Pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }
  
            function fs(t) {
                ai.call(this), this.type = "MeshLambertMaterial", this.color = new Cn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Cn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ht, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }
  
            function ms(t) {
                Ga.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            ss.prototype = Object.create(ai.prototype), ss.prototype.constructor = ss, ss.prototype.isShadowMaterial = !0, cs.prototype = Object.create(Xr.prototype), cs.prototype.constructor = cs, cs.prototype.isRawShaderMaterial = !0, ls.prototype = Object.create(ai.prototype), ls.prototype.constructor = ls, ls.prototype.isMeshStandardMaterial = !0, ls.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, us.prototype = Object.create(ls.prototype), us.prototype.constructor = us, us.prototype.isMeshPhysicalMaterial = !0, us.prototype.copy = function(t) {
                return ls.prototype.copy.call(this, t), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
            }, hs.prototype = Object.create(ai.prototype), hs.prototype.constructor = hs, hs.prototype.isMeshPhongMaterial = !0, hs.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ds.prototype = Object.create(hs.prototype), ds.prototype.constructor = ds, ds.prototype.isMeshToonMaterial = !0, ds.prototype.copy = function(t) {
                return hs.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
            }, ps.prototype = Object.create(ai.prototype), ps.prototype.constructor = ps, ps.prototype.isMeshNormalMaterial = !0, ps.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, fs.prototype = Object.create(ai.prototype), fs.prototype.constructor = fs, fs.prototype.isMeshLambertMaterial = !0, fs.prototype.copy = function(t) {
                return ai.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ms.prototype = Object.create(Ga.prototype), ms.prototype.constructor = ms, ms.prototype.isLineDashedMaterial = !0, ms.prototype.copy = function(t) {
                return Ga.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var vs = Object.freeze({
                    ShadowMaterial: ss,
                    SpriteMaterial: Ua,
                    RawShaderMaterial: cs,
                    ShaderMaterial: Xr,
                    PointsMaterial: Xa,
                    MeshPhysicalMaterial: us,
                    MeshStandardMaterial: ls,
                    MeshPhongMaterial: hs,
                    MeshToonMaterial: ds,
                    MeshNormalMaterial: ps,
                    MeshLambertMaterial: fs,
                    MeshDepthMaterial: oi,
                    MeshDistanceMaterial: si,
                    MeshBasicMaterial: Wr,
                    LineDashedMaterial: ms,
                    LineBasicMaterial: Ga,
                    Material: ai
                }),
                gs = {
                    enabled: !1,
                    files: {},
                    add: function(t, e) {
                        !1 !== this.enabled && (this.files[t] = e)
                    },
                    get: function(t) {
                        if (!1 !== this.enabled) return this.files[t]
                    },
                    remove: function(t) {
                        delete this.files[t]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
  
            function ys(t, e, n) {
                var i = this,
                    r = !1,
                    a = 0,
                    o = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    o++, !1 === r && void 0 !== i.onStart && i.onStart(t, a, o), r = !0
                }, this.itemEnd = function(t) {
                    a++, void 0 !== i.onProgress && i.onProgress(t, a, o), a === o && (r = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function(t) {
                    return s ? s(t) : t
                }, this.setURLModifier = function(t) {
                    return s = t, this
                }
            }
            var xs = new ys,
                bs = {};
  
            function ws(t) {
                this.manager = void 0 !== t ? t : xs
            }
  
            function _s(t) {
                this.manager = void 0 !== t ? t : xs, this._parser = null
            }
  
            function Ms(t) {
                this.manager = void 0 !== t ? t : xs, this._parser = null
            }
  
            function Es(t) {
                this.manager = void 0 !== t ? t : xs
            }
  
            function Ts(t) {
                this.manager = void 0 !== t ? t : xs
            }
  
            function Ss(t) {
                this.manager = void 0 !== t ? t : xs
            }
  
            function As() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }
  
            function Ls(t, e, n, i, r, a, o, s) {
                As.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
            }
  
            function Ps(t, e, n, i, r, a) {
                Ls.call(this, t, e, n, n, i, r, a), this.type = "ArcCurve"
            }
  
            function Cs() {
                var t = 0,
                    e = 0,
                    n = 0,
                    i = 0;
  
                function r(r, a, o, s) {
                    t = r, e = o, n = -3 * r + 3 * a - 2 * o - s, i = 2 * r - 2 * a + o + s
                }
                return {
                    initCatmullRom: function(t, e, n, i, a) {
                        r(e, n, a * (n - t), a * (i - e))
                    },
                    initNonuniformCatmullRom: function(t, e, n, i, a, o, s) {
                        var c = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
                            l = (n - e) / o - (i - e) / (o + s) + (i - n) / s;
                        r(e, n, c *= o, l *= o)
                    },
                    calc: function(r) {
                        var a = r * r;
                        return t + e * r + n * a + i * (a * r)
                    }
                }
            }
            Object.assign(ws.prototype, {
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        a = gs.get(t);
                    if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(a), r.manager.itemEnd(t)
                    }, 0), a;
                    if (void 0 === bs[t]) {
                        var o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (o) {
                            var s = o[1],
                                c = !!o[2],
                                l = o[3];
                            l = window.decodeURIComponent(l), c && (l = window.atob(l));
                            try {
                                var u, h = (this.responseType || "").toLowerCase();
                                switch (h) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var d = new Uint8Array(l.length), p = 0; p < l.length; p++) d[p] = l.charCodeAt(p);
                                        u = "blob" === h ? new Blob([d.buffer], {
                                            type: s
                                        }) : d.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        u = f.parseFromString(l, s);
                                        break;
                                    case "json":
                                        u = JSON.parse(l);
                                        break;
                                    default:
                                        u = l
                                }
                                window.setTimeout(function() {
                                    e && e(u), r.manager.itemEnd(t)
                                }, 0)
                            } catch (e) {
                                window.setTimeout(function() {
                                    i && i(e), r.manager.itemEnd(t), r.manager.itemError(t)
                                }, 0)
                            }
                        } else {
                            bs[t] = [], bs[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: i
                            });
                            var m = new XMLHttpRequest;
                            for (var v in m.open("GET", t, !0), m.addEventListener("load", function(e) {
                                    var n = this.response;
                                    gs.add(t, n);
                                    var i = bs[t];
                                    if (delete bs[t], 200 === this.status) {
                                        for (var a = 0, o = i.length; a < o; a++) {
                                            (s = i[a]).onLoad && s.onLoad(n)
                                        }
                                        r.manager.itemEnd(t)
                                    } else if (0 === this.status) {
                                        console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                        for (a = 0, o = i.length; a < o; a++) {
                                            (s = i[a]).onLoad && s.onLoad(n)
                                        }
                                        r.manager.itemEnd(t)
                                    } else {
                                        for (a = 0, o = i.length; a < o; a++) {
                                            var s;
                                            (s = i[a]).onError && s.onError(e)
                                        }
                                        r.manager.itemEnd(t), r.manager.itemError(t)
                                    }
                                }, !1), m.addEventListener("progress", function(e) {
                                    for (var n = bs[t], i = 0, r = n.length; i < r; i++) {
                                        var a = n[i];
                                        a.onProgress && a.onProgress(e)
                                    }
                                }, !1), m.addEventListener("error", function(e) {
                                    var n = bs[t];
                                    delete bs[t];
                                    for (var i = 0, a = n.length; i < a; i++) {
                                        var o = n[i];
                                        o.onError && o.onError(e)
                                    }
                                    r.manager.itemEnd(t), r.manager.itemError(t)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                            m.send(null)
                        }
                        return r.manager.itemStart(t), m
                    }
                    bs[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    })
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            }), Object.assign(_s.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = [],
                        o = new Za;
                    o.image = a;
                    var s = new ws(this.manager);
  
                    function c(c) {
                        s.load(t[c], function(t) {
                            var n = r._parser(t, !0);
                            a[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, 6 === (l += 1) && (1 === n.mipmapCount && (o.minFilter = Ot), o.format = n.format, o.needsUpdate = !0, e && e(o))
                        }, n, i)
                    }
                    if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                        for (var l = 0, u = 0, h = t.length; u < h; ++u) c(u);
                    else s.load(t, function(t) {
                        var n = r._parser(t, !0);
                        if (n.isCubemap)
                            for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                                a[s] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < n.mipmapCount; c++) a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), a[s].format = n.format, a[s].width = n.width, a[s].height = n.height
                            } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (o.minFilter = Ot), o.format = n.format, o.needsUpdate = !0, e && e(o)
                    }, n, i);
                    return o
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ms.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = new je,
                        o = new ws(this.manager);
                    return o.setResponseType("arraybuffer"), o.load(t, function(t) {
                        var n = r._parser(t);
                        n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : At, a.wrapT = void 0 !== n.wrapT ? n.wrapT : At, a.magFilter = void 0 !== n.magFilter ? n.magFilter : Ot, a.minFilter = void 0 !== n.minFilter ? n.minFilter : Nt, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps), 1 === n.mipmapCount && (a.minFilter = Ot), a.needsUpdate = !0, e && e(a, n))
                    }, n, i), a
                }
            }), Object.assign(Es.prototype, {
                crossOrigin: "Anonymous",
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        a = gs.get(t);
                    if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(a), r.manager.itemEnd(t)
                    }, 0), a;
                    var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    return o.addEventListener("load", function() {
                        gs.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }, !1), o.addEventListener("error", function(e) {
                        i && i(e), r.manager.itemEnd(t), r.manager.itemError(t)
                    }, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ts.prototype, {
                crossOrigin: "Anonymous",
                load: function(t, e, n, i) {
                    var r = new Ge,
                        a = new Es(this.manager);
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                    var o = 0;
  
                    function s(n) {
                        a.load(t[n], function(t) {
                            r.images[n] = t, 6 === ++o && (r.needsUpdate = !0, e && e(r))
                        }, void 0, i)
                    }
                    for (var c = 0; c < t.length; ++c) s(c);
                    return r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ss.prototype, {
                crossOrigin: "Anonymous",
                load: function(t, e, n, i) {
                    var r = new ke,
                        a = new Es(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function(n) {
                        r.image = n;
                        var i = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        r.format = i ? Yt : $t, r.needsUpdate = !0, void 0 !== e && e(r)
                    }, n, i), r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(As.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    var n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, n, i = [],
                        r = this.getPoint(0),
                        a = 0;
                    for (i.push(0), n = 1; n <= t; n++) a += (e = this.getPoint(n / t)).distanceTo(r), i.push(a), r = e;
                    return this.cacheArcLengths = i, i
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    var n, i = this.getLengths(),
                        r = 0,
                        a = i.length;
                    n = e || t * i[a - 1];
                    for (var o, s = 0, c = a - 1; s <= c;)
                        if ((o = i[r = Math.floor(s + (c - s) / 2)] - n) < 0) s = r + 1;
                        else {
                            if (!(o > 0)) {
                                c = r;
                                break
                            }
                            c = r - 1
                        }
                    if (i[r = c] === n) return r / (a - 1);
                    var l = i[r];
                    return (r + (n - l) / (i[r + 1] - l)) / (a - 1)
                },
                getTangent: function(t) {
                    var e = t - 1e-4,
                        n = t + 1e-4;
                    e < 0 && (e = 0), n > 1 && (n = 1);
                    var i = this.getPoint(e);
                    return this.getPoint(n).clone().sub(i).normalize()
                },
                getTangentAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getTangent(e)
                },
                computeFrenetFrames: function(t, e) {
                    var n, i, r, a = new Oe,
                        o = [],
                        s = [],
                        c = [],
                        l = new Oe,
                        u = new Ce;
                    for (n = 0; n <= t; n++) i = n / t, o[n] = this.getTangentAt(i), o[n].normalize();
                    s[0] = new Oe, c[0] = new Oe;
                    var h = Number.MAX_VALUE,
                        d = Math.abs(o[0].x),
                        p = Math.abs(o[0].y),
                        f = Math.abs(o[0].z);
                    for (d <= h && (h = d, a.set(1, 0, 0)), p <= h && (h = p, a.set(0, 1, 0)), f <= h && a.set(0, 0, 1), l.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[0], l), c[0].crossVectors(o[0], s[0]), n = 1; n <= t; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), l.crossVectors(o[n - 1], o[n]), l.length() > Number.EPSILON && (l.normalize(), r = Math.acos(Le.clamp(o[n - 1].dot(o[n]), -1, 1)), s[n].applyMatrix4(u.makeRotationAxis(l, r))), c[n].crossVectors(o[n], s[n]);
                    if (!0 === e)
                        for (r = Math.acos(Le.clamp(s[0].dot(s[t]), -1, 1)), r /= t, o[0].dot(l.crossVectors(s[0], s[t])) > 0 && (r = -r), n = 1; n <= t; n++) s[n].applyMatrix4(u.makeRotationAxis(o[n], r * n)), c[n].crossVectors(o[n], s[n]);
                    return {
                        tangents: o,
                        normals: s,
                        binormals: c
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), Ls.prototype = Object.create(As.prototype), Ls.prototype.constructor = Ls, Ls.prototype.isEllipseCurve = !0, Ls.prototype.getPoint = function(t, e) {
                for (var n = e || new Pe, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0;) r += i;
                for (; r > i;) r -= i;
                r < Number.EPSILON && (r = a ? 0 : i), !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i);
                var o = this.aStartAngle + t * r,
                    s = this.aX + this.xRadius * Math.cos(o),
                    c = this.aY + this.yRadius * Math.sin(o);
                if (0 !== this.aRotation) {
                    var l = Math.cos(this.aRotation),
                        u = Math.sin(this.aRotation),
                        h = s - this.aX,
                        d = c - this.aY;
                    s = h * l - d * u + this.aX, c = h * u + d * l + this.aY
                }
                return n.set(s, c)
            }, Ls.prototype.copy = function(t) {
                return As.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Ls.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, Ls.prototype.fromJSON = function(t) {
                return As.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Ps.prototype = Object.create(Ls.prototype), Ps.prototype.constructor = Ps, Ps.prototype.isArcCurve = !0;
            var Rs = new Oe,
                Os = new Cs,
                Is = new Cs,
                Ns = new Cs;
  
            function Ds(t, e, n, i) {
                As.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = i || .5
            }
  
            function Us(t, e, n, i, r) {
                var a = .5 * (i - e),
                    o = .5 * (r - n),
                    s = t * t;
                return (2 * n - 2 * i + a + o) * (t * s) + (-3 * n + 3 * i - 2 * a - o) * s + a * t + n
            }
  
            function ks(t, e, n, i) {
                return (o = 1 - t) * o * e + 2 * (1 - (a = t)) * a * n + (r = t) * r * i;
                var r, a, o
            }
  
            function Fs(t, e, n, i, r) {
                return (l = 1 - t) * l * l * e + 3 * (c = 1 - (s = t)) * c * s * n + 3 * (1 - (o = t)) * o * o * i + (a = t) * a * a * r;
                var a, o, s, c, l
            }
  
            function zs(t, e, n, i) {
                As.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Pe, this.v1 = e || new Pe, this.v2 = n || new Pe, this.v3 = i || new Pe
            }
  
            function Bs(t, e, n, i) {
                As.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Oe, this.v1 = e || new Oe, this.v2 = n || new Oe, this.v3 = i || new Oe
            }
  
            function js(t, e) {
                As.call(this), this.type = "LineCurve", this.v1 = t || new Pe, this.v2 = e || new Pe
            }
  
            function Gs(t, e) {
                As.call(this), this.type = "LineCurve3", this.v1 = t || new Oe, this.v2 = e || new Oe
            }
  
            function Hs(t, e, n) {
                As.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Pe, this.v1 = e || new Pe, this.v2 = n || new Pe
            }
  
            function Vs(t, e, n) {
                As.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Oe, this.v1 = e || new Oe, this.v2 = n || new Oe
            }
  
            function Ws(t) {
                As.call(this), this.type = "SplineCurve", this.points = t || []
            }
            Ds.prototype = Object.create(As.prototype), Ds.prototype.constructor = Ds, Ds.prototype.isCatmullRomCurve3 = !0, Ds.prototype.getPoint = function(t, e) {
                var n, i, r, a, o = e || new Oe,
                    s = this.points,
                    c = s.length,
                    l = (c - (this.closed ? 0 : 1)) * t,
                    u = Math.floor(l),
                    h = l - u;
                if (this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / s.length) + 1) * s.length : 0 === h && u === c - 1 && (u = c - 2, h = 1), this.closed || u > 0 ? n = s[(u - 1) % c] : (Rs.subVectors(s[0], s[1]).add(s[0]), n = Rs), i = s[u % c], r = s[(u + 1) % c], this.closed || u + 2 < c ? a = s[(u + 2) % c] : (Rs.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), a = Rs), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var d = "chordal" === this.curveType ? .5 : .25,
                        p = Math.pow(n.distanceToSquared(i), d),
                        f = Math.pow(i.distanceToSquared(r), d),
                        m = Math.pow(r.distanceToSquared(a), d);
                    f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), Os.initNonuniformCatmullRom(n.x, i.x, r.x, a.x, p, f, m), Is.initNonuniformCatmullRom(n.y, i.y, r.y, a.y, p, f, m), Ns.initNonuniformCatmullRom(n.z, i.z, r.z, a.z, p, f, m)
                } else "catmullrom" === this.curveType && (Os.initCatmullRom(n.x, i.x, r.x, a.x, this.tension), Is.initCatmullRom(n.y, i.y, r.y, a.y, this.tension), Ns.initCatmullRom(n.z, i.z, r.z, a.z, this.tension));
                return o.set(Os.calc(h), Is.calc(h), Ns.calc(h)), o
            }, Ds.prototype.copy = function(t) {
                As.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push(i.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, Ds.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, Ds.prototype.fromJSON = function(t) {
                As.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push((new Oe).fromArray(i))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, zs.prototype = Object.create(As.prototype), zs.prototype.constructor = zs, zs.prototype.isCubicBezierCurve = !0, zs.prototype.getPoint = function(t, e) {
                var n = e || new Pe,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3;
                return n.set(Fs(t, i.x, r.x, a.x, o.x), Fs(t, i.y, r.y, a.y, o.y)), n
            }, zs.prototype.copy = function(t) {
                return As.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, zs.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, zs.prototype.fromJSON = function(t) {
                return As.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, Bs.prototype = Object.create(As.prototype), Bs.prototype.constructor = Bs, Bs.prototype.isCubicBezierCurve3 = !0, Bs.prototype.getPoint = function(t, e) {
                var n = e || new Oe,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3;
                return n.set(Fs(t, i.x, r.x, a.x, o.x), Fs(t, i.y, r.y, a.y, o.y), Fs(t, i.z, r.z, a.z, o.z)), n
            }, Bs.prototype.copy = function(t) {
                return As.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, Bs.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, Bs.prototype.fromJSON = function(t) {
                return As.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, js.prototype = Object.create(As.prototype), js.prototype.constructor = js, js.prototype.isLineCurve = !0, js.prototype.getPoint = function(t, e) {
                var n = e || new Pe;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, js.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, js.prototype.getTangent = function() {
                return this.v2.clone().sub(this.v1).normalize()
            }, js.prototype.copy = function(t) {
                return As.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, js.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, js.prototype.fromJSON = function(t) {
                return As.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Gs.prototype = Object.create(As.prototype), Gs.prototype.constructor = Gs, Gs.prototype.isLineCurve3 = !0, Gs.prototype.getPoint = function(t, e) {
                var n = e || new Oe;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, Gs.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Gs.prototype.copy = function(t) {
                return As.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Gs.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Gs.prototype.fromJSON = function(t) {
                return As.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Hs.prototype = Object.create(As.prototype), Hs.prototype.constructor = Hs, Hs.prototype.isQuadraticBezierCurve = !0, Hs.prototype.getPoint = function(t, e) {
                var n = e || new Pe,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2;
                return n.set(ks(t, i.x, r.x, a.x), ks(t, i.y, r.y, a.y)), n
            }, Hs.prototype.copy = function(t) {
                return As.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Hs.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Hs.prototype.fromJSON = function(t) {
                return As.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Vs.prototype = Object.create(As.prototype), Vs.prototype.constructor = Vs, Vs.prototype.isQuadraticBezierCurve3 = !0, Vs.prototype.getPoint = function(t, e) {
                var n = e || new Oe,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2;
                return n.set(ks(t, i.x, r.x, a.x), ks(t, i.y, r.y, a.y), ks(t, i.z, r.z, a.z)), n
            }, Vs.prototype.copy = function(t) {
                return As.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Vs.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Vs.prototype.fromJSON = function(t) {
                return As.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Ws.prototype = Object.create(As.prototype), Ws.prototype.constructor = Ws, Ws.prototype.isSplineCurve = !0, Ws.prototype.getPoint = function(t, e) {
                var n = e || new Pe,
                    i = this.points,
                    r = (i.length - 1) * t,
                    a = Math.floor(r),
                    o = r - a,
                    s = i[0 === a ? a : a - 1],
                    c = i[a],
                    l = i[a > i.length - 2 ? i.length - 1 : a + 1],
                    u = i[a > i.length - 3 ? i.length - 1 : a + 2];
                return n.set(Us(o, s.x, c.x, l.x, u.x), Us(o, s.y, c.y, l.y, u.y)), n
            }, Ws.prototype.copy = function(t) {
                As.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push(i.clone())
                }
                return this
            }, Ws.prototype.toJSON = function() {
                var t = As.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t
            }, Ws.prototype.fromJSON = function(t) {
                As.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push((new Pe).fromArray(i))
                }
                return this
            };
            var Xs = Object.freeze({
                ArcCurve: Ps,
                CatmullRomCurve3: Ds,
                CubicBezierCurve: zs,
                CubicBezierCurve3: Bs,
                EllipseCurve: Ls,
                LineCurve: js,
                LineCurve3: Gs,
                QuadraticBezierCurve: Hs,
                QuadraticBezierCurve3: Vs,
                SplineCurve: Ws
            });
  
            function qs() {
                As.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }
  
            function Ys(t) {
                qs.call(this), this.type = "Path", this.currentPoint = new Pe, t && this.setFromPoints(t)
            }
  
            function $s(t) {
                Ys.call(this, t), this.uuid = Le.generateUUID(), this.type = "Shape", this.holes = []
            }
  
            function Zs(t, e) {
                Ui.call(this), this.type = "Light", this.color = new Cn(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
            }
  
            function Js(t, e, n) {
                Zs.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Ui.DefaultUp), this.updateMatrix(), this.groundColor = new Cn(e)
            }
  
            function Ks(t) {
                this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new Pe(512, 512), this.map = null, this.matrix = new Ce
            }
  
            function Qs() {
                Ks.call(this, new Aa(50, 1, .5, 500))
            }
  
            function tc(t, e, n, i, r, a) {
                Zs.call(this, t, e), this.type = "SpotLight", this.position.copy(Ui.DefaultUp), this.updateMatrix(), this.target = new Ui, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Qs
            }
  
            function ec(t, e, n, i) {
                Zs.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Ks(new Aa(90, 1, .5, 500))
            }
  
            function nc() {
                Ks.call(this, new Fi(-5, 5, 5, -5, .5, 500))
            }
  
            function ic(t, e) {
                Zs.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Ui.DefaultUp), this.updateMatrix(), this.target = new Ui, this.shadow = new nc
            }
  
            function rc(t, e) {
                Zs.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
            }
  
            function ac(t, e, n, i) {
                Zs.call(this, t, e), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
            }
  
            function oc(t, e, n, i) {
                gc.call(this, t, e, n, i)
            }
  
            function sc(t, e, n) {
                gc.call(this, t, e, n)
            }
  
            function cc(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
            }
  
            function lc(t, e, n, i) {
                cc.call(this, t, e, n, i)
            }
  
            function uc(t, e, n, i) {
                gc.call(this, t, e, n, i)
            }
  
            function hc(t, e, n, i) {
                gc.call(this, t, e, n, i)
            }
  
            function dc(t, e, n, i) {
                gc.call(this, t, e, n, i)
            }
  
            function pc(t, e, n, i) {
                cc.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }
  
            function fc(t, e, n, i) {
                cc.call(this, t, e, n, i)
            }
  
            function mc(t, e, n, i) {
                cc.call(this, t, e, n, i)
            }
            qs.prototype = Object.assign(Object.create(As.prototype), {
                constructor: qs,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new js(e, t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                        if (n[i] >= e) {
                            var r = n[i] - e,
                                a = this.curves[i],
                                o = a.getLength(),
                                s = 0 === o ? 0 : 1 - r / o;
                            return a.getPointAt(s)
                        }
                        i++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
                        for (var a = r[i], o = a && a.isEllipseCurve ? 2 * t : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), c = 0; c < s.length; c++) {
                            var l = s[c];
                            e && e.equals(l) || (n.push(l), e = l)
                        }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function(t) {
                    As.prototype.copy.call(this, t), this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var i = t.curves[e];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    var t = As.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (var e = 0, n = this.curves.length; e < n; e++) {
                        var i = this.curves[e];
                        t.curves.push(i.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    As.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var i = t.curves[e];
                        this.curves.push((new Xs[i.type]).fromJSON(i))
                    }
                    return this
                }
            }), Ys.prototype = Object.assign(Object.create(qs.prototype), {
                constructor: Ys,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
                },
                moveTo: function(t, e) {
                    this.currentPoint.set(t, e)
                },
                lineTo: function(t, e) {
                    var n = new js(this.currentPoint.clone(), new Pe(t, e));
                    this.curves.push(n), this.currentPoint.set(t, e)
                },
                quadraticCurveTo: function(t, e, n, i) {
                    var r = new Hs(this.currentPoint.clone(), new Pe(t, e), new Pe(n, i));
                    this.curves.push(r), this.currentPoint.set(n, i)
                },
                bezierCurveTo: function(t, e, n, i, r, a) {
                    var o = new zs(this.currentPoint.clone(), new Pe(t, e), new Pe(n, i), new Pe(r, a));
                    this.curves.push(o), this.currentPoint.set(r, a)
                },
                splineThru: function(t) {
                    var e = new Ws([this.currentPoint.clone()].concat(t));
                    this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
                },
                arc: function(t, e, n, i, r, a) {
                    var o = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(t + o, e + s, n, i, r, a)
                },
                absarc: function(t, e, n, i, r, a) {
                    this.absellipse(t, e, n, n, i, r, a)
                },
                ellipse: function(t, e, n, i, r, a, o, s) {
                    var c = this.currentPoint.x,
                        l = this.currentPoint.y;
                    this.absellipse(t + c, e + l, n, i, r, a, o, s)
                },
                absellipse: function(t, e, n, i, r, a, o, s) {
                    var c = new Ls(t, e, n, i, r, a, o, s);
                    if (this.curves.length > 0) {
                        var l = c.getPoint(0);
                        l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
                    }
                    this.curves.push(c);
                    var u = c.getPoint(1);
                    this.currentPoint.copy(u)
                },
                copy: function(t) {
                    return qs.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    var t = qs.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return qs.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), $s.prototype = Object.assign(Object.create(Ys.prototype), {
                constructor: $s,
                getPointsHoles: function(t) {
                    for (var e = [], n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    Ys.prototype.copy.call(this, t), this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var i = t.holes[e];
                        this.holes.push(i.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var t = Ys.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (var e = 0, n = this.holes.length; e < n; e++) {
                        var i = this.holes[e];
                        t.holes.push(i.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    Ys.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var i = t.holes[e];
                        this.holes.push((new Ys).fromJSON(i))
                    }
                    return this
                }
            }), Zs.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Zs,
                isLight: !0,
                copy: function(t) {
                    return Ui.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = Ui.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), Js.prototype = Object.assign(Object.create(Zs.prototype), {
                constructor: Js,
                isHemisphereLight: !0,
                copy: function(t) {
                    return Zs.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(Ks.prototype, {
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), Qs.prototype = Object.assign(Object.create(Ks.prototype), {
                constructor: Qs,
                isSpotLightShadow: !0,
                update: function(t) {
                    var e = this.camera,
                        n = 2 * Le.RAD2DEG * t.angle,
                        i = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix())
                }
            }), tc.prototype = Object.assign(Object.create(Zs.prototype), {
                constructor: tc,
                isSpotLight: !0,
                copy: function(t) {
                    return Zs.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), ec.prototype = Object.assign(Object.create(Zs.prototype), {
                constructor: ec,
                isPointLight: !0,
                copy: function(t) {
                    return Zs.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), nc.prototype = Object.assign(Object.create(Ks.prototype), {
                constructor: nc
            }), ic.prototype = Object.assign(Object.create(Zs.prototype), {
                constructor: ic,
                isDirectionalLight: !0,
                copy: function(t) {
                    return Zs.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), rc.prototype = Object.assign(Object.create(Zs.prototype), {
                constructor: rc,
                isAmbientLight: !0
            }), ac.prototype = Object.assign(Object.create(Zs.prototype), {
                constructor: ac,
                isRectAreaLight: !0,
                copy: function(t) {
                    return Zs.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    var e = Zs.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            }), oc.prototype = Object.assign(Object.create(gc.prototype), {
                constructor: oc,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: he,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), sc.prototype = Object.assign(Object.create(gc.prototype), {
                constructor: sc,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: he,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Object.assign(cc.prototype, {
                evaluate: function(t) {
                    var e = this.parameterPositions,
                        n = this._cachedIndex,
                        i = e[n],
                        r = e[n - 1];
                    t: {
                        e: {
                            var a;
                            n: {
                                i: if (!(t < i)) {
                                    for (var o = n + 2;;) {
                                        if (void 0 === i) {
                                            if (t < r) break i;
                                            return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                        }
                                        if (n === o) break;
                                        if (r = i, t < (i = e[++n])) break e
                                    }
                                    a = e.length;
                                    break n
                                }if (t >= r) break t;
                                var s = e[1];t < s && (n = 2, r = s);
                                for (o = n - 2;;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                    if (n === o) break;
                                    if (i = r, t >= (r = e[--n - 1])) break e
                                }
                                a = n,
                                n = 0
                            }
                            for (; n < a;) {
                                var c = n + a >>> 1;
                                t < e[c] ? a = c : n = c + 1
                            }
                            if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                            if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, t, i)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(t) {
                    for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, a = 0; a !== i; ++a) e[a] = n[r + a];
                    return e
                },
                interpolate_: function() {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function() {}
            }), Object.assign(cc.prototype, {
                beforeStart_: cc.prototype.copySampleValue_,
                afterEnd_: cc.prototype.copySampleValue_
            }), lc.prototype = Object.assign(Object.create(cc.prototype), {
                constructor: lc,
                interpolate_: function(t, e, n, i) {
                    for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = (n - e) / (i - e), l = s + o; s !== l; s += 4) Re.slerpFlat(r, 0, a, s - o, a, s, c);
                    return r
                }
            }), uc.prototype = Object.assign(Object.create(gc.prototype), {
                constructor: uc,
                ValueTypeName: "quaternion",
                DefaultInterpolation: de,
                InterpolantFactoryMethodLinear: function(t) {
                    return new lc(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), hc.prototype = Object.assign(Object.create(gc.prototype), {
                constructor: hc,
                ValueTypeName: "color"
            }), dc.prototype = Object.assign(Object.create(gc.prototype), {
                constructor: dc,
                ValueTypeName: "number"
            }), pc.prototype = Object.assign(Object.create(cc.prototype), {
                constructor: pc,
                DefaultSettings_: {
                    endingStart: pe,
                    endingEnd: pe
                },
                intervalChanged_: function(t, e, n) {
                    var i = this.parameterPositions,
                        r = t - 2,
                        a = t + 1,
                        o = i[r],
                        s = i[a];
                    if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case fe:
                            r = t, o = 2 * e - n;
                            break;
                        case me:
                            o = e + i[r = i.length - 2] - i[r + 1];
                            break;
                        default:
                            r = t, o = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case fe:
                            a = t, s = 2 * n - e;
                            break;
                        case me:
                            a = 1, s = n + i[1] - i[0];
                            break;
                        default:
                            a = t - 1, s = e
                    }
                    var c = .5 * (n - e),
                        l = this.valueSize;
                    this._weightPrev = c / (e - o), this._weightNext = c / (s - n), this._offsetPrev = r * l, this._offsetNext = a * l
                },
                interpolate_: function(t, e, n, i) {
                    for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - e) / (i - e), f = p * p, m = f * p, v = -h * m + 2 * h * f - h * p, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f, b = 0; b !== o; ++b) r[b] = v * a[l + b] + g * a[c + b] + y * a[s + b] + x * a[u + b];
                    return r
                }
            }), fc.prototype = Object.assign(Object.create(cc.prototype), {
                constructor: fc,
                interpolate_: function(t, e, n, i) {
                    for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, l = (n - e) / (i - e), u = 1 - l, h = 0; h !== o; ++h) r[h] = a[c + h] * u + a[s + h] * l;
                    return r
                }
            }), mc.prototype = Object.assign(Object.create(cc.prototype), {
                constructor: mc,
                interpolate_: function(t) {
                    return this.copySampleValue_(t - 1)
                }
            });
            var vc = {
                arraySlice: function(t, e, n) {
                    return vc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                },
                convertArray: function(t, e, n) {
                    return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(t) {
                    for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i) n[i] = i;
                    return n.sort(function(e, n) {
                        return t[e] - t[n]
                    }), n
                },
                sortedArray: function(t, e, n) {
                    for (var i = t.length, r = new t.constructor(i), a = 0, o = 0; o !== i; ++a)
                        for (var s = n[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
                    return r
                },
                flattenJSON: function(t, e, n, i) {
                    for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[i];) a = t[r++];
                    if (void 0 !== a) {
                        var o = a[i];
                        if (void 0 !== o)
                            if (Array.isArray(o))
                                do {
                                    void 0 !== (o = a[i]) && (e.push(a.time), n.push.apply(n, o)), a = t[r++]
                                } while (void 0 !== a);
                            else if (void 0 !== o.toArray)
                            do {
                                void 0 !== (o = a[i]) && (e.push(a.time), o.toArray(n, n.length)), a = t[r++]
                            } while (void 0 !== a);
                        else
                            do {
                                void 0 !== (o = a[i]) && (e.push(a.time), n.push(o)), a = t[r++]
                            } while (void 0 !== a)
                    }
                }
            };
  
            function gc(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = vc.convertArray(e, this.TimeBufferType), this.values = vc.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation), this.validate(), this.optimize()
            }
  
            function yc(t, e, n, i) {
                gc.call(this, t, e, n, i)
            }
  
            function xc(t, e, n) {
                this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = Le.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
            }
  
            function bc(t) {
                this.manager = void 0 !== t ? t : xs, this.textures = {}
            }
  
            function wc(t) {
                this.manager = void 0 !== t ? t : xs
            }
            Object.assign(gc, {
                parse: function(t) {
                    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    var e = gc._getTrackTypeForValueTypeName(t.type);
                    if (void 0 === t.times) {
                        var n = [],
                            i = [];
                        vc.flattenJSON(t.keys, n, i, "value"), t.times = n, t.values = i
                    }
                    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                },
                toJSON: function(t) {
                    var e, n = t.constructor;
                    if (void 0 !== n.toJSON) e = n.toJSON(t);
                    else {
                        e = {
                            name: t.name,
                            times: vc.convertArray(t.times, Array),
                            values: vc.convertArray(t.values, Array)
                        };
                        var i = t.getInterpolation();
                        i !== t.DefaultInterpolation && (e.interpolation = i)
                    }
                    return e.type = t.ValueTypeName, e
                },
                _getTrackTypeForValueTypeName: function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return dc;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return yc;
                        case "color":
                            return hc;
                        case "quaternion":
                            return uc;
                        case "bool":
                        case "boolean":
                            return sc;
                        case "string":
                            return oc
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }
            }), Object.assign(gc.prototype, {
                constructor: gc,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: de,
                InterpolantFactoryMethodDiscrete: function(t) {
                    return new mc(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodLinear: function(t) {
                    return new fc(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: function(t) {
                    return new pc(this.times, this.values, this.getValueSize(), t)
                },
                setInterpolation: function(t) {
                    var e;
                    switch (t) {
                        case he:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case de:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 !== e) this.createInterpolant = e;
                    else {
                        var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(n);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        console.warn("THREE.KeyframeTrack:", n)
                    }
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return he;
                        case this.InterpolantFactoryMethodLinear:
                            return de;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(t) {
                    if (0 !== t)
                        for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] += t;
                    return this
                },
                scale: function(t) {
                    if (1 !== t)
                        for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] *= t;
                    return this
                },
                trim: function(t, e) {
                    for (var n = this.times, i = n.length, r = 0, a = i - 1; r !== i && n[r] < t;) ++r;
                    for (; - 1 !== a && n[a] > e;) --a;
                    if (++a, 0 !== r || a !== i) {
                        r >= a && (r = (a = Math.max(a, 1)) - 1);
                        var o = this.getValueSize();
                        this.times = vc.arraySlice(n, r, a), this.values = vc.arraySlice(this.values, r * o, a * o)
                    }
                    return this
                },
                validate: function() {
                    var t = !0,
                        e = this.getValueSize();
                    e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                    var n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                    for (var a = null, o = 0; o !== r; o++) {
                        var s = n[o];
                        if ("number" == typeof s && isNaN(s)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), t = !1;
                            break
                        }
                        if (null !== a && a > s) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), t = !1;
                            break
                        }
                        a = s
                    }
                    if (void 0 !== i && vc.isTypedArray(i)) {
                        o = 0;
                        for (var c = i.length; o !== c; ++o) {
                            var l = i[o];
                            if (isNaN(l)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), t = !1;
                                break
                            }
                        }
                    }
                    return t
                },
                optimize: function() {
                    for (var t = this.times, e = this.values, n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, a = t.length - 1, o = 1; o < a; ++o) {
                        var s = !1,
                            c = t[o];
                        if (c !== t[o + 1] && (1 !== o || c !== c[0]))
                            if (i) s = !0;
                            else
                                for (var l = o * n, u = l - n, h = l + n, d = 0; d !== n; ++d) {
                                    var p = e[l + d];
                                    if (p !== e[u + d] || p !== e[h + d]) {
                                        s = !0;
                                        break
                                    }
                                }
                            if (s) {
                                if (o !== r) {
                                    t[r] = t[o];
                                    var f = o * n,
                                        m = r * n;
                                    for (d = 0; d !== n; ++d) e[m + d] = e[f + d]
                                }++r
                            }
                    }
                    if (a > 0) {
                        t[r] = t[a];
                        for (f = a * n, m = r * n, d = 0; d !== n; ++d) e[m + d] = e[f + d];
                        ++r
                    }
                    return r !== t.length && (this.times = vc.arraySlice(t, 0, r), this.values = vc.arraySlice(e, 0, r * n)), this
                }
            }), yc.prototype = Object.assign(Object.create(gc.prototype), {
                constructor: yc,
                ValueTypeName: "vector"
            }), Object.assign(xc, {
                parse: function(t) {
                    for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, a = n.length; r !== a; ++r) e.push(gc.parse(n[r]).scale(i));
                    return new xc(t.name, t.duration, e)
                },
                toJSON: function(t) {
                    for (var e = [], n = t.tracks, i = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e
                        }, r = 0, a = n.length; r !== a; ++r) e.push(gc.toJSON(n[r]));
                    return i
                },
                CreateFromMorphTargetSequence: function(t, e, n, i) {
                    for (var r = e.length, a = [], o = 0; o < r; o++) {
                        var s = [],
                            c = [];
                        s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
                        var l = vc.getKeyframeOrder(s);
                        s = vc.sortedArray(s, 1, l), c = vc.sortedArray(c, 1, l), i || 0 !== s[0] || (s.push(r), c.push(c[0])), a.push(new dc(".morphTargetInfluences[" + e[o].name + "]", s, c).scale(1 / n))
                    }
                    return new xc(t, -1, a)
                },
                findByName: function(t, e) {
                    var n = t;
                    if (!Array.isArray(t)) {
                        var i = t;
                        n = i.geometry && i.geometry.animations || i.animations
                    }
                    for (var r = 0; r < n.length; r++)
                        if (n[r].name === e) return n[r];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(t, e, n) {
                    for (var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
                        var s = t[a],
                            c = s.name.match(r);
                        if (c && c.length > 1) {
                            var l = i[h = c[1]];
                            l || (i[h] = l = []), l.push(s)
                        }
                    }
                    var u = [];
                    for (var h in i) u.push(xc.CreateFromMorphTargetSequence(h, i[h], e, n));
                    return u
                },
                parseAnimation: function(t, e) {
                    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    for (var n = function(t, e, n, i, r) {
                            if (0 !== n.length) {
                                var a = [],
                                    o = [];
                                vc.flattenJSON(n, a, o, i), 0 !== a.length && r.push(new t(e, a, o))
                            }
                        }, i = [], r = t.name || "default", a = t.length || -1, o = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                        var l = s[c].keys;
                        if (l && 0 !== l.length)
                            if (l[0].morphTargets) {
                                for (var u = {}, h = 0; h < l.length; h++)
                                    if (l[h].morphTargets)
                                        for (var d = 0; d < l[h].morphTargets.length; d++) u[l[h].morphTargets[d]] = -1;
                                for (var p in u) {
                                    var f = [],
                                        m = [];
                                    for (d = 0; d !== l[h].morphTargets.length; ++d) {
                                        var v = l[h];
                                        f.push(v.time), m.push(v.morphTarget === p ? 1 : 0)
                                    }
                                    i.push(new dc(".morphTargetInfluence[" + p + "]", f, m))
                                }
                                a = u.length * (o || 1)
                            } else {
                                var g = ".bones[" + e[c].name + "]";
                                n(yc, g + ".position", l, "pos", i), n(uc, g + ".quaternion", l, "rot", i), n(yc, g + ".scale", l, "scl", i)
                            }
                    }
                    return 0 === i.length ? null : new xc(r, a, i)
                }
            }), Object.assign(xc.prototype, {
                resetDuration: function() {
                    for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
                        var i = this.tracks[e];
                        t = Math.max(t, i.times[i.times.length - 1])
                    }
                    this.duration = t
                },
                trim: function() {
                    for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this
                },
                optimize: function() {
                    for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this
                }
            }), Object.assign(bc.prototype, {
                load: function(t, e, n, i) {
                    var r = this;
                    new ws(r.manager).load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, n, i)
                },
                setTextures: function(t) {
                    this.textures = t
                },
                parse: function(t) {
                    var e = this.textures;
  
                    function n(t) {
                        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                    }
                    var i = new vs[t.type];
                    if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearCoat && (i.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (i.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (i.uniforms = t.uniforms), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (i.vertexColors = t.vertexColors), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap), i.transparent = !0), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalScale) {
                        var r = t.normalScale;
                        !1 === Array.isArray(r) && (r = [r, r]), i.normalScale = (new Pe).fromArray(r)
                    }
                    return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), i
                }
            }), Object.assign(wc.prototype, {
                load: function(t, e, n, i) {
                    var r = this;
                    new ws(r.manager).load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, n, i)
                },
                parse: function(t) {
                    var e = new Br,
                        n = t.data.index;
                    if (void 0 !== n) {
                        var i = new Sc[n.type](n.array);
                        e.setIndex(new Yi(i, 1))
                    }
                    var r = t.data.attributes;
                    for (var a in r) {
                        var o = r[a];
                        i = new Sc[o.type](o.array);
                        e.addAttribute(a, new Yi(i, o.itemSize, o.normalized))
                    }
                    var s = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== s)
                        for (var c = 0, l = s.length; c !== l; ++c) {
                            var u = s[c];
                            e.addGroup(u.start, u.count, u.materialIndex)
                        }
                    var h = t.data.boundingSphere;
                    if (void 0 !== h) {
                        var d = new Oe;
                        void 0 !== h.center && d.fromArray(h.center), e.boundingSphere = new li(d, h.radius)
                    }
                    return e
                }
            });
            var _c, Mc, Ec, Tc, Sc = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
  
            function Ac() {
                this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
            }
            Ac.Handlers = {
                handlers: [],
                add: function(t, e) {
                    this.handlers.push(t, e)
                },
                get: function(t) {
                    for (var e = this.handlers, n = 0, i = e.length; n < i; n += 2) {
                        var r = e[n],
                            a = e[n + 1];
                        if (r.test(t)) return a
                    }
                    return null
                }
            }, Object.assign(Ac.prototype, {
                crossOrigin: void 0,
                initMaterials: function(t, e, n) {
                    for (var i = [], r = 0; r < t.length; ++r) i[r] = this.createMaterial(t[r], e, n);
                    return i
                },
                createMaterial: (_c = {
                    NoBlending: D,
                    NormalBlending: U,
                    AdditiveBlending: k,
                    SubtractiveBlending: F,
                    MultiplyBlending: z,
                    CustomBlending: B
                }, Mc = new Cn, Ec = new Ss, Tc = new bc, function(t, e, n) {
                    var i = {};
  
                    function r(t, r, a, o, s) {
                        var c, l = e + t,
                            u = Ac.Handlers.get(l);
                        null !== u ? c = u.load(l) : (Ec.setCrossOrigin(n), c = Ec.load(l)), void 0 !== r && (c.repeat.fromArray(r), 1 !== r[0] && (c.wrapS = St), 1 !== r[1] && (c.wrapT = St)), void 0 !== a && c.offset.fromArray(a), void 0 !== o && ("repeat" === o[0] && (c.wrapS = St), "mirror" === o[0] && (c.wrapS = Lt), "repeat" === o[1] && (c.wrapT = St), "mirror" === o[1] && (c.wrapT = Lt)), void 0 !== s && (c.anisotropy = s);
                        var h = Le.generateUUID();
                        return i[h] = c, h
                    }
                    var a = {
                        uuid: Le.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                    for (var o in t) {
                        var s = t[o];
                        switch (o) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                a.name = s;
                                break;
                            case "blending":
                                a.blending = _c[s];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", o, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                a.color = Mc.fromArray(s).getHex();
                                break;
                            case "colorSpecular":
                                a.specular = Mc.fromArray(s).getHex();
                                break;
                            case "colorEmissive":
                                a.emissive = Mc.fromArray(s).getHex();
                                break;
                            case "specularCoef":
                                a.shininess = s;
                                break;
                            case "shading":
                                "basic" === s.toLowerCase() && (a.type = "MeshBasicMaterial"), "phong" === s.toLowerCase() && (a.type = "MeshPhongMaterial"), "standard" === s.toLowerCase() && (a.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                a.map = r(s, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                a.emissiveMap = r(s, t.mapEmissiveRepeat, t.mapEmissiveOffset, t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                a.lightMap = r(s, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                a.aoMap = r(s, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                a.bumpMap = r(s, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                a.bumpScale = s;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                a.normalMap = r(s, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                a.normalScale = [s, s];
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                a.specularMap = r(s, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                a.metalnessMap = r(s, t.mapMetalnessRepeat, t.mapMetalnessOffset, t.mapMetalnessWrap, t.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                a.roughnessMap = r(s, t.mapRoughnessRepeat, t.mapRoughnessOffset, t.mapRoughnessWrap, t.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                a.alphaMap = r(s, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                a.side = C;
                                break;
                            case "doubleSided":
                                a.side = R;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), a.opacity = s;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                a[o] = s;
                                break;
                            case "vertexColors":
                                !0 === s && (a.vertexColors = N), "face" === s && (a.vertexColors = I);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", o, s)
                        }
                    }
                    return "MeshBasicMaterial" === a.type && delete a.emissive, "MeshPhongMaterial" !== a.type && delete a.specular, a.opacity < 1 && (a.transparent = !0), Tc.setTextures(i), Tc.parse(a)
                })
            });
            var Lc, Pc = {
                decodeText: function(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    for (var e = "", n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                    return e
                },
                extractUrlBase: function(t) {
                    var e = t.split("/");
                    return 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
                }
            };
  
            function Cc(t) {
                "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : xs, this.withCredentials = !1
            }
  
            function Rc(t) {
                this.manager = void 0 !== t ? t : xs, this.texturePath = ""
            }
            Object.assign(Cc.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Pc.extractUrlBase(t),
                        o = new ws(this.manager);
                    o.setWithCredentials(this.withCredentials), o.load(t, function(n) {
                        var i = JSON.parse(n),
                            o = i.metadata;
                        if (void 0 !== o) {
                            var s = o.type;
                            if (void 0 !== s) {
                                if ("object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                                if ("scene" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                            }
                        }
                        var c = r.parse(i, a);
                        e(c.geometry, c.materials)
                    }, n, i)
                },
                setTexturePath: function(t) {
                    this.texturePath = t
                },
                parse: function() {
                    return function(t, e) {
                        void 0 !== t.data && (t = t.data), void 0 !== t.scale ? t.scale = 1 / t.scale : t.scale = 1;
                        var n = new qi;
                        return function(t, e) {
                                function n(t, e) {
                                    return t & 1 << e
                                }
                                var i, r, a, o, s, c, l, u, h, d, p, f, m, v, g, y, x, b, w, _, M, E, T, S, A, L = t.faces,
                                    P = t.vertices,
                                    C = t.normals,
                                    R = t.colors,
                                    O = t.scale,
                                    I = 0;
                                if (void 0 !== t.uvs) {
                                    for (i = 0; i < t.uvs.length; i++) t.uvs[i].length && I++;
                                    for (i = 0; i < I; i++) e.faceVertexUvs[i] = []
                                }
                                for (o = 0, s = P.length; o < s;)(b = new Oe).x = P[o++] * O, b.y = P[o++] * O, b.z = P[o++] * O, e.vertices.push(b);
                                for (o = 0, s = L.length; o < s;)
                                    if (p = n(d = L[o++], 0), f = n(d, 1), m = n(d, 3), v = n(d, 4), g = n(d, 5), y = n(d, 6), x = n(d, 7), p) {
                                        if ((_ = new zi).a = L[o], _.b = L[o + 1], _.c = L[o + 3], (M = new zi).a = L[o + 1], M.b = L[o + 2], M.c = L[o + 3], o += 4, f && (h = L[o++], _.materialIndex = h, M.materialIndex = h), a = e.faces.length, m)
                                            for (i = 0; i < I; i++)
                                                for (S = t.uvs[i], e.faceVertexUvs[i][a] = [], e.faceVertexUvs[i][a + 1] = [], r = 0; r < 4; r++) A = new Pe(S[2 * (u = L[o++])], S[2 * u + 1]), 2 !== r && e.faceVertexUvs[i][a].push(A), 0 !== r && e.faceVertexUvs[i][a + 1].push(A);
                                        if (v && (l = 3 * L[o++], _.normal.set(C[l++], C[l++], C[l]), M.normal.copy(_.normal)), g)
                                            for (i = 0; i < 4; i++) l = 3 * L[o++], T = new Oe(C[l++], C[l++], C[l]), 2 !== i && _.vertexNormals.push(T), 0 !== i && M.vertexNormals.push(T);
                                        if (y && (E = R[c = L[o++]], _.color.setHex(E), M.color.setHex(E)), x)
                                            for (i = 0; i < 4; i++) E = R[c = L[o++]], 2 !== i && _.vertexColors.push(new Cn(E)), 0 !== i && M.vertexColors.push(new Cn(E));
                                        e.faces.push(_), e.faces.push(M)
                                    } else {
                                        if ((w = new zi).a = L[o++], w.b = L[o++], w.c = L[o++], f && (h = L[o++], w.materialIndex = h), a = e.faces.length, m)
                                            for (i = 0; i < I; i++)
                                                for (S = t.uvs[i], e.faceVertexUvs[i][a] = [], r = 0; r < 3; r++) A = new Pe(S[2 * (u = L[o++])], S[2 * u + 1]), e.faceVertexUvs[i][a].push(A);
                                        if (v && (l = 3 * L[o++], w.normal.set(C[l++], C[l++], C[l])), g)
                                            for (i = 0; i < 3; i++) l = 3 * L[o++], T = new Oe(C[l++], C[l++], C[l]), w.vertexNormals.push(T);
                                        if (y && (c = L[o++], w.color.setHex(R[c])), x)
                                            for (i = 0; i < 3; i++) c = L[o++], w.vertexColors.push(new Cn(R[c]));
                                        e.faces.push(w)
                                    }
                            }(t, n),
                            function(t, e) {
                                var n = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                                if (t.skinWeights)
                                    for (var i = 0, r = t.skinWeights.length; i < r; i += n) {
                                        var a = t.skinWeights[i],
                                            o = n > 1 ? t.skinWeights[i + 1] : 0,
                                            s = n > 2 ? t.skinWeights[i + 2] : 0,
                                            c = n > 3 ? t.skinWeights[i + 3] : 0;
                                        e.skinWeights.push(new Fe(a, o, s, c))
                                    }
                                if (t.skinIndices)
                                    for (i = 0, r = t.skinIndices.length; i < r; i += n) {
                                        var l = t.skinIndices[i],
                                            u = n > 1 ? t.skinIndices[i + 1] : 0,
                                            h = n > 2 ? t.skinIndices[i + 2] : 0,
                                            d = n > 3 ? t.skinIndices[i + 3] : 0;
                                        e.skinIndices.push(new Fe(l, u, h, d))
                                    }
                                e.bones = t.bones, e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
                            }(t, n),
                            function(t, e) {
                                var n = t.scale;
                                if (void 0 !== t.morphTargets)
                                    for (var i = 0, r = t.morphTargets.length; i < r; i++) {
                                        e.morphTargets[i] = {}, e.morphTargets[i].name = t.morphTargets[i].name, e.morphTargets[i].vertices = [];
                                        for (var a = e.morphTargets[i].vertices, o = t.morphTargets[i].vertices, s = 0, c = o.length; s < c; s += 3) {
                                            var l = new Oe;
                                            l.x = o[s] * n, l.y = o[s + 1] * n, l.z = o[s + 2] * n, a.push(l)
                                        }
                                    }
                                if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                                    var u = e.faces,
                                        h = t.morphColors[0].colors;
                                    for (i = 0, r = u.length; i < r; i++) u[i].color.fromArray(h, 3 * i)
                                }
                            }(t, n),
                            function(t, e) {
                                var n = [],
                                    i = [];
                                void 0 !== t.animation && i.push(t.animation), void 0 !== t.animations && (t.animations.length ? i = i.concat(t.animations) : i.push(t.animations));
                                for (var r = 0; r < i.length; r++) {
                                    var a = xc.parseAnimation(i[r], e.bones);
                                    a && n.push(a)
                                }
                                if (e.morphTargets) {
                                    var o = xc.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                                    n = n.concat(o)
                                }
                                n.length > 0 && (e.animations = n)
                            }(t, n), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length ? {
                                geometry: n
                            } : {
                                geometry: n,
                                materials: Ac.prototype.initMaterials(t.materials, e, this.crossOrigin)
                            }
                    }
                }()
            }), Object.assign(Rc.prototype, {
                load: function(t, e, n, i) {
                    "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                    var r = this;
                    new ws(r.manager).load(t, function(n) {
                        var a = null;
                        try {
                            a = JSON.parse(n)
                        } catch (e) {
                            return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                        }
                        var o = a.metadata;
                        void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? r.parse(a, e) : console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.")
                    }, n, i)
                },
                setTexturePath: function(t) {
                    this.texturePath = t
                },
                setCrossOrigin: function(t) {
                    this.crossOrigin = t
                },
                parse: function(t, e) {
                    var n = this.parseShape(t.shapes),
                        i = this.parseGeometries(t.geometries, n),
                        r = this.parseImages(t.images, function() {
                            void 0 !== e && e(s)
                        }),
                        a = this.parseTextures(t.textures, r),
                        o = this.parseMaterials(t.materials, a),
                        s = this.parseObject(t.object, i, o);
                    return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
                },
                parseShape: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var n = 0, i = t.length; n < i; n++) {
                            var r = (new $s).fromJSON(t[n]);
                            e[r.uuid] = r
                        }
                    return e
                },
                parseGeometries: function(t, e) {
                    var n = {};
                    if (void 0 !== t)
                        for (var i = new Cc, r = new wc, a = 0, o = t.length; a < o; a++) {
                            var s, c = t[a];
                            switch (c.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new os[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new os[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new os[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new os[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new os[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new os[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new os[c.type](c.radius, c.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new os[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new os[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new os[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new os[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new os[c.type](c.vertices, c.indices, c.radius, c.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    var l = [];
                                    for (a = 0, o = c.shapes.length; a < o; a++) {
                                        var u = e[c.shapes[a]];
                                        l.push(u)
                                    }
                                    s = new os[c.type](l, c.curveSegments);
                                    break;
                                case "BufferGeometry":
                                    s = r.parse(c);
                                    break;
                                case "Geometry":
                                    s = i.parse(c, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
                                    continue
                            }
                            s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), n[c.uuid] = s
                        }
                    return n
                },
                parseMaterials: function(t, e) {
                    var n = {};
                    if (void 0 !== t) {
                        var i = new bc;
                        i.setTextures(e);
                        for (var r = 0, a = t.length; r < a; r++) {
                            var o = t[r];
                            if ("MultiMaterial" === o.type) {
                                for (var s = [], c = 0; c < o.materials.length; c++) s.push(i.parse(o.materials[c]));
                                n[o.uuid] = s
                            } else n[o.uuid] = i.parse(o)
                        }
                    }
                    return n
                },
                parseAnimations: function(t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                        var i = xc.parse(t[n]);
                        e.push(i)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    var n = this,
                        i = {};
  
                    function r(t) {
                        return n.manager.itemStart(t), a.load(t, function() {
                            n.manager.itemEnd(t)
                        }, void 0, function() {
                            n.manager.itemEnd(t), n.manager.itemError(t)
                        })
                    }
                    if (void 0 !== t && t.length > 0) {
                        var a = new Es(new ys(e));
                        a.setCrossOrigin(this.crossOrigin);
                        for (var o = 0, s = t.length; o < s; o++) {
                            var c = t[o],
                                l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.texturePath + c.url;
                            i[c.uuid] = r(l)
                        }
                    }
                    return i
                },
                parseTextures: function(t, e) {
                    function n(t, e) {
                        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                    }
                    var i = {};
                    if (void 0 !== t)
                        for (var r = 0, a = t.length; r < a; r++) {
                            var o = t[r];
                            void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                            var s = new ke(e[o.image]);
                            s.needsUpdate = !0, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, Ic)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], Nc), s.wrapT = n(o.wrap[1], Nc)), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, Dc)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, Dc)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), i[o.uuid] = s
                        }
                    return i
                },
                parseObject: (Lc = new Ce, function(t, e, n) {
                    var i;
  
                    function r(t) {
                        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                    }
  
                    function a(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], i = 0, r = t.length; i < r; i++) {
                                    var a = t[i];
                                    void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a), e.push(n[a])
                                }
                                return e
                            }
                            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                        }
                    }
                    switch (t.type) {
                        case "Scene":
                            i = new Na, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new Cn(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new Ia(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new Oa(t.fog.color, t.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            i = new Aa(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            i = new Fi(t.left, t.right, t.top, t.bottom, t.near, t.far);
                            break;
                        case "AmbientLight":
                            i = new rc(t.color, t.intensity);
                            break;
                        case "DirectionalLight":
                            i = new ic(t.color, t.intensity);
                            break;
                        case "PointLight":
                            i = new ec(t.color, t.intensity, t.distance, t.decay);
                            break;
                        case "RectAreaLight":
                            i = new ac(t.color, t.intensity, t.width, t.height);
                            break;
                        case "SpotLight":
                            i = new tc(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                            break;
                        case "HemisphereLight":
                            i = new Js(t.color, t.groundColor, t.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var o = r(t.geometry),
                                s = a(t.material);
                            i = o.bones && o.bones.length > 0 ? new ja(o, s) : new Zr(o, s);
                            break;
                        case "LOD":
                            i = new Fa;
                            break;
                        case "Line":
                            i = new Ha(r(t.geometry), a(t.material), t.mode);
                            break;
                        case "LineLoop":
                            i = new Wa(r(t.geometry), a(t.material));
                            break;
                        case "LineSegments":
                            i = new Va(r(t.geometry), a(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            i = new qa(r(t.geometry), a(t.material));
                            break;
                        case "Sprite":
                            i = new ka(a(t.material));
                            break;
                        case "Group":
                            i = new Ya;
                            break;
                        default:
                            i = new Ui
                    }
                    if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (Lc.fromArray(t.matrix), Lc.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.children)
                        for (var c = t.children, l = 0; l < c.length; l++) i.add(this.parseObject(c[l], e, n));
                    if ("LOD" === t.type)
                        for (var u = t.levels, h = 0; h < u.length; h++) {
                            var d = u[h],
                                p = i.getObjectByProperty("uuid", d.object);
                            void 0 !== p && i.addLevel(p, d.distance)
                        }
                    return i
                })
            });
            var Oc, Ic = {
                    UVMapping: 300,
                    CubeReflectionMapping: xt,
                    CubeRefractionMapping: bt,
                    EquirectangularReflectionMapping: wt,
                    EquirectangularRefractionMapping: _t,
                    SphericalReflectionMapping: Mt,
                    CubeUVReflectionMapping: Et,
                    CubeUVRefractionMapping: Tt
                },
                Nc = {
                    RepeatWrapping: St,
                    ClampToEdgeWrapping: At,
                    MirroredRepeatWrapping: Lt
                },
                Dc = {
                    NearestFilter: Pt,
                    NearestMipMapNearestFilter: Ct,
                    NearestMipMapLinearFilter: Rt,
                    LinearFilter: Ot,
                    LinearMipMapNearestFilter: It,
                    LinearMipMapLinearFilter: Nt
                };
  
            function Uc(t) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : xs, this.options = void 0
            }
  
            function kc() {
                this.type = "ShapePath", this.subPaths = [], this.currentPath = null
            }
  
            function Fc(t) {
                this.type = "Font", this.data = t
            }
  
            function zc(t) {
                this.manager = void 0 !== t ? t : xs
            }
            Uc.prototype = {
                constructor: Uc,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
                    var r = this,
                        a = gs.get(t);
                    if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(a), r.manager.itemEnd(t)
                    }, 0), a;
                    fetch(t).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return createImageBitmap(t, r.options)
                    }).then(function(n) {
                        gs.add(t, n), e && e(n), r.manager.itemEnd(t)
                    }).catch(function(e) {
                        i && i(e), r.manager.itemEnd(t), r.manager.itemError(t)
                    })
                },
                setCrossOrigin: function() {
                    return this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }, Object.assign(kc.prototype, {
                moveTo: function(t, e) {
                    this.currentPath = new Ys, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
                },
                lineTo: function(t, e) {
                    this.currentPath.lineTo(t, e)
                },
                quadraticCurveTo: function(t, e, n, i) {
                    this.currentPath.quadraticCurveTo(t, e, n, i)
                },
                bezierCurveTo: function(t, e, n, i, r, a) {
                    this.currentPath.bezierCurveTo(t, e, n, i, r, a)
                },
                splineThru: function(t) {
                    this.currentPath.splineThru(t)
                },
                toShapes: function(t, e) {
                    function n(t) {
                        for (var e = [], n = 0, i = t.length; n < i; n++) {
                            var r = t[n],
                                a = new $s;
                            a.curves = r.curves, e.push(a)
                        }
                        return e
                    }
  
                    function i(t, e) {
                        for (var n = e.length, i = !1, r = n - 1, a = 0; a < n; r = a++) {
                            var o = e[r],
                                s = e[a],
                                c = s.x - o.x,
                                l = s.y - o.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (o = e[a], c = -c, s = e[r], l = -l), t.y < o.y || t.y > s.y) continue;
                                if (t.y === o.y) {
                                    if (t.x === o.x) return !0
                                } else {
                                    var u = l * (t.x - o.x) - c * (t.y - o.y);
                                    if (0 === u) return !0;
                                    if (u < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (t.y !== o.y) continue;
                                if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !0
                            }
                        }
                        return i
                    }
                    var r = zo.isClockWise,
                        a = this.subPaths;
                    if (0 === a.length) return [];
                    if (!0 === e) return n(a);
                    var o, s, c, l = [];
                    if (1 === a.length) return s = a[0], (c = new $s).curves = s.curves, l.push(c), l;
                    var u = !r(a[0].getPoints());
                    u = t ? !u : u;
                    var h, d, p = [],
                        f = [],
                        m = [],
                        v = 0;
                    f[v] = void 0, m[v] = [];
                    for (var g = 0, y = a.length; g < y; g++) o = r(h = (s = a[g]).getPoints()), (o = t ? !o : o) ? (!u && f[v] && v++, f[v] = {
                        s: new $s,
                        p: h
                    }, f[v].s.curves = s.curves, u && v++, m[v] = []) : m[v].push({
                        h: s,
                        p: h[0]
                    });
                    if (!f[0]) return n(a);
                    if (f.length > 1) {
                        for (var x = !1, b = [], w = 0, _ = f.length; w < _; w++) p[w] = [];
                        for (w = 0, _ = f.length; w < _; w++)
                            for (var M = m[w], E = 0; E < M.length; E++) {
                                for (var T = M[E], S = !0, A = 0; A < f.length; A++) i(T.p, f[A].p) && (w !== A && b.push({
                                    froms: w,
                                    tos: A,
                                    hole: E
                                }), S ? (S = !1, p[A].push(T)) : x = !0);
                                S && p[w].push(T)
                            }
                        b.length > 0 && (x || (m = p))
                    }
                    g = 0;
                    for (var L = f.length; g < L; g++) {
                        c = f[g].s, l.push(c);
                        for (var P = 0, C = (d = m[g]).length; P < C; P++) c.holes.push(d[P].h)
                    }
                    return l
                }
            }), Object.assign(Fc.prototype, {
                isFont: !0,
                generateShapes: function(t, e, n) {
                    function i(t, e, n, i) {
                        var a = r.glyphs[t] || r.glyphs["?"];
                        if (a) {
                            var o, s, c, l, u, h, d, p, f, m = new kc,
                                v = [];
                            if (a.o)
                                for (var g = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), y = 0, x = g.length; y < x;) {
                                    switch (g[y++]) {
                                        case "m":
                                            o = g[y++] * e + n, s = g[y++] * e + i, m.moveTo(o, s);
                                            break;
                                        case "l":
                                            o = g[y++] * e + n, s = g[y++] * e + i, m.lineTo(o, s);
                                            break;
                                        case "q":
                                            c = g[y++] * e + n, l = g[y++] * e + i, u = g[y++] * e + n, h = g[y++] * e + i, m.quadraticCurveTo(u, h, c, l), (f = v[v.length - 1]) && (f.x, f.y);
                                            break;
                                        case "b":
                                            c = g[y++] * e + n, l = g[y++] * e + i, u = g[y++] * e + n, h = g[y++] * e + i, d = g[y++] * e + n, p = g[y++] * e + i, m.bezierCurveTo(u, h, d, p, c, l), (f = v[v.length - 1]) && (f.x, f.y)
                                    }
                                }
                            return {
                                offsetX: a.ha * e,
                                path: m
                            }
                        }
                    }
                    void 0 === e && (e = 100), void 0 === n && (n = 4);
                    for (var r = this.data, a = function(t) {
                            for (var n = String(t).split(""), a = e / r.resolution, o = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * a, s = 0, c = 0, l = [], u = 0; u < n.length; u++) {
                                var h = n[u];
                                if ("\n" === h) s = 0, c -= o;
                                else {
                                    var d = i(h, a, s, c);
                                    s += d.offsetX, l.push(d.path)
                                }
                            }
                            return l
                        }(t), o = [], s = 0, c = a.length; s < c; s++) Array.prototype.push.apply(o, a[s].toShapes());
                    return o
                }
            }), Object.assign(zc.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = new ws(this.manager);
                    a.setPath(this.path), a.load(t, function(t) {
                        var n;
                        try {
                            n = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var i = r.parse(n);
                        e && e(i)
                    }, n, i)
                },
                parse: function(t) {
                    return new Fc(t)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            });
            var Bc, jc, Gc, Hc, Vc, Wc, Xc, qc, Yc, $c, Zc, Jc, Kc, Qc, tl, el, nl, il, rl, al, ol, sl, cl, ll, ul, hl, dl, pl, fl, ml, vl, gl, yl, xl, bl, wl, _l, Ml, El, Tl = {
                getContext: function() {
                    return void 0 === Oc && (Oc = new(window.AudioContext || window.webkitAudioContext)), Oc
                },
                setContext: function(t) {
                    Oc = t
                }
            };
  
            function Sl(t) {
                this.manager = void 0 !== t ? t : xs
            }
  
            function Al() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Aa, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Aa, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }
  
            function Ll(t, e, n) {
                Ui.call(this), this.type = "CubeCamera";
                var i = new Aa(90, 1, t, e);
                i.up.set(0, -1, 0), i.lookAt(new Oe(1, 0, 0)), this.add(i);
                var r = new Aa(90, 1, t, e);
                r.up.set(0, -1, 0), r.lookAt(new Oe(-1, 0, 0)), this.add(r);
                var a = new Aa(90, 1, t, e);
                a.up.set(0, 0, 1), a.lookAt(new Oe(0, 1, 0)), this.add(a);
                var o = new Aa(90, 1, t, e);
                o.up.set(0, 0, -1), o.lookAt(new Oe(0, -1, 0)), this.add(o);
                var s = new Aa(90, 1, t, e);
                s.up.set(0, -1, 0), s.lookAt(new Oe(0, 0, 1)), this.add(s);
                var c = new Aa(90, 1, t, e);
                c.up.set(0, -1, 0), c.lookAt(new Oe(0, 0, -1)), this.add(c);
                var l = {
                    format: Yt,
                    magFilter: Ot,
                    minFilter: Ot
                };
                this.renderTarget = new Be(n, n, l), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = this.renderTarget,
                        l = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, n.activeCubeFace = 0, t.render(e, i, n), n.activeCubeFace = 1, t.render(e, r, n), n.activeCubeFace = 2, t.render(e, a, n), n.activeCubeFace = 3, t.render(e, o, n), n.activeCubeFace = 4, t.render(e, s, n), n.texture.generateMipmaps = l, n.activeCubeFace = 5, t.render(e, c, n), t.setRenderTarget(null)
                }, this.clear = function(t, e, n, i) {
                    for (var r = this.renderTarget, a = 0; a < 6; a++) r.activeCubeFace = a, t.setRenderTarget(r), t.clear(e, n, i);
                    t.setRenderTarget(null)
                }
            }
  
            function Pl() {
                Ui.call(this), this.type = "AudioListener", this.context = Tl.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
            }
  
            function Cl(t) {
                Ui.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }
  
            function Rl(t) {
                Cl.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }
  
            function Ol(t, e) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }
  
            function Il(t, e, n) {
                this.binding = t, this.valueSize = n;
                var i, r = Float64Array;
                switch (e) {
                    case "quaternion":
                        i = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array, i = this._select;
                        break;
                    default:
                        i = this._lerp
                }
                this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
  
            function Nl(t, e, n) {
                var i = n || Dl.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }
  
            function Dl(t, e, n) {
                this.path = e, this.parsedPath = n || Dl.parseTrackName(e), this.node = Dl.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }
  
            function Ul() {
                this.uuid = Le.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var t = {};
                this._indicesByUUID = t;
                for (var e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var i = this;
                this.stats = {
                    objects: {get total() {
                            return i._objects.length
                        },
                        get inUse() {
                            return this.total - i.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return i._bindings.length
                    }
                }
            }
  
            function kl(t, e, n) {
                this._mixer = t, this._clip = e, this._localRoot = n || null;
                for (var i = e.tracks, r = i.length, a = new Array(r), o = {
                        endingStart: pe,
                        endingEnd: pe
                    }, s = 0; s !== r; ++s) {
                    var c = i[s].createInterpolant(null);
                    a[s] = c, c.settings = o
                }
                this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ue, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
  
            function Fl(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
  
            function zl(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }
  
            function Bl() {
                Br.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }
  
            function jl(t, e, n, i) {
                this.uuid = Le.generateUUID(), this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
            }
  
            function Gl(t, e) {
                this.uuid = Le.generateUUID(), this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.onUploadCallback = function() {}, this.version = 0
            }
  
            function Hl(t, e, n) {
                Gl.call(this, t, e), this.meshPerAttribute = n || 1
            }
  
            function Vl(t, e, n) {
                Yi.call(this, t, e), this.meshPerAttribute = n || 1
            }
  
            function Wl(t, e, n, i) {
                this.ray = new qr(t, e), this.near = n || 0, this.far = i || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }
  
            function Xl(t, e) {
                return t.distance - e.distance
            }
  
            function ql(t, e, n, i) {
                if (!1 !== t.visible && (t.raycast(e, n), !0 === i))
                    for (var r = t.children, a = 0, o = r.length; a < o; a++) ql(r[a], e, n, !0)
            }
  
            function Yl(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
  
            function $l(t, e, n) {
                return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
            }
  
            function Zl(t, e, n) {
                return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
            }
  
            function Jl(t) {
                Ui.call(this), this.material = t, this.render = function() {}
            }
  
            function Kl(t, e, n, i) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== n ? n : 16711680,
                    a = void 0 !== i ? i : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count);
                var c = new Br,
                    l = new nr(2 * o * 3, 3);
                c.addAttribute("position", l), Va.call(this, c, new Ga({
                    color: r,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }
  
            function Ql(t, e) {
                Ui.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var n = new Br, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1; r < 32; r++, a++) {
                    var o = r / 32 * Math.PI * 2,
                        s = a / 32 * Math.PI * 2;
                    i.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
                }
                n.addAttribute("position", new nr(i, 3));
                var c = new Ga({
                    fog: !1
                });
                this.cone = new Va(n, c), this.add(this.cone), this.update()
            }
  
            function tu(t) {
                for (var e = function t(e) {
                        var n = [];
                        e && e.isBone && n.push(e);
                        for (var i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                        return n
                    }(t), n = new Br, i = [], r = [], a = new Cn(0, 0, 1), o = new Cn(0, 1, 0), s = 0; s < e.length; s++) {
                    var c = e[s];
                    c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b))
                }
                n.addAttribute("position", new nr(i, 3)), n.addAttribute("color", new nr(r, 3));
                var l = new Ga({
                    vertexColors: N,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                Va.call(this, n, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }
  
            function eu(t, e, n) {
                this.light = t, this.light.updateMatrixWorld(), this.color = n;
                var i = new Wo(e, 4, 2),
                    r = new Wr({
                        wireframe: !0,
                        fog: !1
                    });
                Zr.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }
  
            function nu(t, e) {
                Ui.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                var n = new Ga({
                        fog: !1
                    }),
                    i = new Br;
                i.addAttribute("position", new Yi(new Float32Array(15), 3)), this.line = new Ha(i, n), this.add(this.line), this.update()
            }
  
            function iu(t, e, n) {
                Ui.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var i = new oo(e);
                i.rotateY(.5 * Math.PI), this.material = new Wr({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = N);
                var r = i.getAttribute("position"),
                    a = new Float32Array(3 * r.count);
                i.addAttribute("color", new Yi(a, 3)), this.add(new Zr(i, this.material)), this.update()
            }
  
            function ru(t, e, n, i) {
                t = t || 10, e = e || 10, n = new Cn(void 0 !== n ? n : 4473924), i = new Cn(void 0 !== i ? i : 8947848);
                for (var r = e / 2, a = t / e, o = t / 2, s = [], c = [], l = 0, u = 0, h = -o; l <= e; l++, h += a) {
                    s.push(-o, 0, h, o, 0, h), s.push(h, 0, -o, h, 0, o);
                    var d = l === r ? n : i;
                    d.toArray(c, u), u += 3, d.toArray(c, u), u += 3, d.toArray(c, u), u += 3, d.toArray(c, u), u += 3
                }
                var p = new Br;
                p.addAttribute("position", new nr(s, 3)), p.addAttribute("color", new nr(c, 3));
                var f = new Ga({
                    vertexColors: N
                });
                Va.call(this, p, f)
            }
  
            function au(t, e, n, i, r, a) {
                t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new Cn(void 0 !== r ? r : 4473924), a = new Cn(void 0 !== a ? a : 8947848);
                var o, s, c, l, u, h, d, p = [],
                    f = [];
                for (l = 0; l <= e; l++) c = l / e * (2 * Math.PI), o = Math.sin(c) * t, s = Math.cos(c) * t, p.push(0, 0, 0), p.push(o, 0, s), d = 1 & l ? r : a, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
                for (l = 0; l <= n; l++)
                    for (d = 1 & l ? r : a, h = t - t / n * l, u = 0; u < i; u++) c = u / i * (2 * Math.PI), o = Math.sin(c) * h, s = Math.cos(c) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b), c = (u + 1) / i * (2 * Math.PI), o = Math.sin(c) * h, s = Math.cos(c) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b);
                var m = new Br;
                m.addAttribute("position", new nr(p, 3)), m.addAttribute("color", new nr(f, 3));
                var v = new Ga({
                    vertexColors: N
                });
                Va.call(this, m, v)
            }
  
            function ou(t, e, n, i) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== n ? n : 16776960,
                    a = void 0 !== i ? i : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new Br,
                    l = new nr(2 * o * 3, 3);
                c.addAttribute("position", l), Va.call(this, c, new Ga({
                    color: r,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }
  
            function su(t, e, n) {
                Ui.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                var i = new Br;
                i.addAttribute("position", new nr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                var r = new Ga({
                    fog: !1
                });
                this.lightPlane = new Ha(i, r), this.add(this.lightPlane), (i = new Br).addAttribute("position", new nr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ha(i, r), this.add(this.targetLine), this.update()
            }
  
            function cu(t) {
                var e = new Br,
                    n = new Ga({
                        color: 16777215,
                        vertexColors: I
                    }),
                    i = [],
                    r = [],
                    a = {},
                    o = new Cn(16755200),
                    s = new Cn(16711680),
                    c = new Cn(43775),
                    l = new Cn(16777215),
                    u = new Cn(3355443);
  
                function h(t, e, n) {
                    d(t, n), d(e, n)
                }
  
                function d(t, e) {
                    i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(i.length / 3 - 1)
                }
                h("n1", "n2", o), h("n2", "n4", o), h("n4", "n3", o), h("n3", "n1", o), h("f1", "f2", o), h("f2", "f4", o), h("f4", "f3", o), h("f3", "f1", o), h("n1", "f1", o), h("n2", "f2", o), h("n3", "f3", o), h("n4", "f4", o), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", l), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), e.addAttribute("position", new nr(i, 3)), e.addAttribute("color", new nr(r, 3)), Va.call(this, e, n), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
            }
  
            function lu(t, e) {
                this.object = t, void 0 === e && (e = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Float32Array(24),
                    r = new Br;
                r.setIndex(new Yi(n, 1)), r.addAttribute("position", new Yi(i, 3)), Va.call(this, r, new Ga({
                    color: e
                })), this.matrixAutoUpdate = !1, this.update()
            }
  
            function uu(t, e) {
                this.type = "Box3Helper", this.box = t;
                var n = void 0 !== e ? e : 16776960,
                    i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Br;
                r.setIndex(new Yi(i, 1)), r.addAttribute("position", new nr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Va.call(this, r, new Ga({
                    color: n
                })), this.geometry.computeBoundingSphere()
            }
  
            function hu(t, e, n) {
                this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                var i = void 0 !== n ? n : 16776960,
                    r = new Br;
                r.addAttribute("position", new nr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), Ha.call(this, r, new Ga({
                    color: i
                }));
                var a = new Br;
                a.addAttribute("position", new nr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new Zr(a, new Wr({
                    color: i,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }
  
            function du(t, e, n, i, r, a) {
                Ui.call(this), void 0 === i && (i = 16776960), void 0 === n && (n = 1), void 0 === r && (r = .2 * n), void 0 === a && (a = .2 * r), void 0 === wl && ((wl = new Br).addAttribute("position", new nr([0, 0, 0, 0, 1, 0], 3)), (_l = new es(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Ha(wl, new Ga({
                    color: i
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Zr(_l, new Wr({
                    color: i
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, a)
            }
  
            function pu(t) {
                var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    n = new Br;
                n.addAttribute("position", new nr(e, 3)), n.addAttribute("color", new nr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var i = new Ga({
                    vertexColors: N
                });
                Va.call(this, n, i)
            }
            Object.assign(Sl.prototype, {
                load: function(t, e, n, i) {
                    var r = new ws(this.manager);
                    r.setResponseType("arraybuffer"), r.load(t, function(t) {
                        Tl.getContext().decodeAudioData(t, function(t) {
                            e(t)
                        })
                    }, n, i)
                }
            }), Object.assign(Al.prototype, {
                update: (Yc = new Ce, $c = new Ce, function(t) {
                    if (Bc !== this || jc !== t.focus || Gc !== t.fov || Hc !== t.aspect * this.aspect || Vc !== t.near || Wc !== t.far || Xc !== t.zoom || qc !== this.eyeSep) {
                        Bc = this, jc = t.focus, Gc = t.fov, Hc = t.aspect * this.aspect, Vc = t.near, Wc = t.far, Xc = t.zoom;
                        var e, n, i = t.projectionMatrix.clone(),
                            r = (qc = this.eyeSep / 2) * Vc / jc,
                            a = Vc * Math.tan(Le.DEG2RAD * Gc * .5) / Xc;
                        $c.elements[12] = -qc, Yc.elements[12] = qc, e = -a * Hc + r, n = a * Hc + r, i.elements[0] = 2 * Vc / (n - e), i.elements[8] = (n + e) / (n - e), this.cameraL.projectionMatrix.copy(i), e = -a * Hc - r, n = a * Hc - r, i.elements[0] = 2 * Vc / (n - e), i.elements[8] = (n + e) / (n - e), this.cameraR.projectionMatrix.copy(i)
                    }
                    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply($c), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Yc)
                })
            }), Ll.prototype = Object.create(Ui.prototype), Ll.prototype.constructor = Ll, Pl.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Pl,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(t) {
                    null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(t) {
                    this.gain.gain.value = t
                },
                updateMatrixWorld: (Zc = new Oe, Jc = new Re, Kc = new Oe, Qc = new Oe, function(t) {
                    Ui.prototype.updateMatrixWorld.call(this, t);
                    var e = this.context.listener,
                        n = this.up;
                    this.matrixWorld.decompose(Zc, Jc, Kc), Qc.set(0, 0, -1).applyQuaternion(Jc), e.positionX ? (e.positionX.setValueAtTime(Zc.x, this.context.currentTime), e.positionY.setValueAtTime(Zc.y, this.context.currentTime), e.positionZ.setValueAtTime(Zc.z, this.context.currentTime), e.forwardX.setValueAtTime(Qc.x, this.context.currentTime), e.forwardY.setValueAtTime(Qc.y, this.context.currentTime), e.forwardZ.setValueAtTime(Qc.z, this.context.currentTime), e.upX.setValueAtTime(n.x, this.context.currentTime), e.upY.setValueAtTime(n.y, this.context.currentTime), e.upZ.setValueAtTime(n.z, this.context.currentTime)) : (e.setPosition(Zc.x, Zc.y, Zc.z), e.setOrientation(Qc.x, Qc.y, Qc.z, n.x, n.y, n.z))
                })
            }), Cl.prototype = Object.assign(Object.create(Ui.prototype), {
                constructor: Cl,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                },
                setBuffer: function(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function() {
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            var t = this.context.createBufferSource();
                            return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(t) {
                    return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(t) {
                    return this.setFilters(t ? [t] : [])
                },
                setPlaybackRate: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(t) {
                    return this.gain.gain.value = t, this
                }
            }), Rl.prototype = Object.assign(Object.create(Cl.prototype), {
                constructor: Rl,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(t) {
                    this.panner.refDistance = t
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(t) {
                    this.panner.rolloffFactor = t
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(t) {
                    this.panner.distanceModel = t
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(t) {
                    this.panner.maxDistance = t
                },
                updateMatrixWorld: (tl = new Oe, function(t) {
                    Ui.prototype.updateMatrixWorld.call(this, t), tl.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(tl.x, tl.y, tl.z)
                })
            }), Object.assign(Ol.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function() {
                    for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n];
                    return t / e.length
                }
            }), Object.assign(Il.prototype, {
                accumulate: function(t, e) {
                    var n = this.buffer,
                        i = this.valueSize,
                        r = t * i + i,
                        a = this.cumulativeWeight;
                    if (0 === a) {
                        for (var o = 0; o !== i; ++o) n[r + o] = n[o];
                        a = e
                    } else {
                        var s = e / (a += e);
                        this._mixBufferRegion(n, r, 0, s, i)
                    }
                    this.cumulativeWeight = a
                },
                apply: function(t) {
                    var e = this.valueSize,
                        n = this.buffer,
                        i = t * e + e,
                        r = this.cumulativeWeight,
                        a = this.binding;
                    if (this.cumulativeWeight = 0, r < 1) {
                        var o = 3 * e;
                        this._mixBufferRegion(n, i, o, 1 - r, e)
                    }
                    for (var s = e, c = e + e; s !== c; ++s)
                        if (n[s] !== n[s + e]) {
                            a.setValue(n, i);
                            break
                        }
                },
                saveOriginalState: function() {
                    var t = this.binding,
                        e = this.buffer,
                        n = this.valueSize,
                        i = 3 * n;
                    t.getValue(e, i);
                    for (var r = n, a = i; r !== a; ++r) e[r] = e[i + r % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _select: function(t, e, n, i, r) {
                    if (i >= .5)
                        for (var a = 0; a !== r; ++a) t[e + a] = t[n + a]
                },
                _slerp: function(t, e, n, i) {
                    Re.slerpFlat(t, e, t, e, t, n, i)
                },
                _lerp: function(t, e, n, i, r) {
                    for (var a = 1 - i, o = 0; o !== r; ++o) {
                        var s = e + o;
                        t[s] = t[s] * a + t[n + o] * i
                    }
                }
            }), Object.assign(Nl.prototype, {
                getValue: function(t, e) {
                    this.bind();
                    var n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(t, e)
                },
                setValue: function(t, e) {
                    for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
                },
                bind: function() {
                    for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                },
                unbind: function() {
                    for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                }
            }), Object.assign(Dl, {
                Composite: Nl,
                create: function(t, e, n) {
                    return t && t.isAnimationObjectGroup ? new Dl.Composite(t, e, n) : new Dl(t, e, n)
                },
                sanitizeNodeName: function(t) {
                    return t.replace(/\s/g, "_").replace(/[^\w-]/g, "")
                },
                parseTrackName: (el = new RegExp("^" + /((?:[\w-]+[\/:])*)/.source + /([\w-\.]+)?/.source + /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source + /\.([\w-]+)(?:\[(.+)\])?/.source + "$"), nl = ["material", "materials", "bones"], function(t) {
                    var e = el.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    var n = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        var r = n.nodeName.substring(i + 1); - 1 !== nl.indexOf(r) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return n
                }),
                findNode: function(t, e) {
                    if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        var n = function(t) {
                            for (var n = 0; n < t.bones.length; n++) {
                                var i = t.bones[n];
                                if (i.name === e) return i
                            }
                            return null
                        }(t.skeleton);
                        if (n) return n
                    }
                    if (t.children) {
                        var i = function(t) {
                                for (var n = 0; n < t.length; n++) {
                                    var r = t[n];
                                    if (r.name === e || r.uuid === e) return r;
                                    var a = i(r.children);
                                    if (a) return a
                                }
                                return null
                            },
                            r = i(t.children);
                        if (r) return r
                    }
                    return null
                }
            }), Object.assign(Dl.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(t, e) {
                    t[e] = this.node[this.propertyName]
                }, function(t, e) {
                    for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
                }, function(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }, function(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                    }, function(t, e) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function(t, e) {
                    this.bind(), this.getValue(t, e)
                },
                setValue: function(t, e) {
                    this.bind(), this.setValue(t, e)
                },
                bind: function() {
                    var t = this.node,
                        e = this.parsedPath,
                        n = e.objectName,
                        i = e.propertyName,
                        r = e.propertyIndex;
                    if (t || (t = Dl.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                        if (n) {
                            var a = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    t = t.skeleton.bones;
                                    for (var o = 0; o < t.length; o++)
                                        if (t[o].name === a) {
                                            a = o;
                                            break
                                        }
                                    break;
                                default:
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    t = t[n]
                            }
                            if (void 0 !== a) {
                                if (void 0 === t[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                t = t[a]
                            }
                        }
                        var s = t[i];
                        if (void 0 !== s) {
                            var c = this.Versioning.None;
                            void 0 !== t.needsUpdate ? (c = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t);
                            var l = this.BindingType.Direct;
                            if (void 0 !== r) {
                                if ("morphTargetInfluences" === i) {
                                    if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (t.geometry.isBufferGeometry) {
                                        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                        for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                                            if (t.geometry.morphAttributes.position[o].name === r) {
                                                r = o;
                                                break
                                            }
                                    } else {
                                        if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                        for (o = 0; o < this.node.geometry.morphTargets.length; o++)
                                            if (t.geometry.morphTargets[o].name === r) {
                                                r = o;
                                                break
                                            }
                                    }
                                }
                                l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                            this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                        } else {
                            var u = e.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", t)
                        }
                    } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(Dl.prototype, {
                _getValue_unbound: Dl.prototype.getValue,
                _setValue_unbound: Dl.prototype.setValue
            }), Object.assign(Ul.prototype, {
                isAnimationObjectGroup: !0,
                add: function() {
                    for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, c = 0, l = arguments.length; c !== l; ++c) {
                        var u = arguments[c],
                            h = u.uuid,
                            d = i[h],
                            p = void 0;
                        if (void 0 === d) {
                            d = e++, i[h] = d, t.push(u);
                            for (var f = 0, m = s; f !== m; ++f) o[f].push(new Dl(u, r[f], a[f]))
                        } else if (d < n) {
                            p = t[d];
                            var v = --n,
                                g = t[v];
                            i[g.uuid] = d, t[d] = g, i[h] = v, t[v] = u;
                            for (f = 0, m = s; f !== m; ++f) {
                                var y = o[f],
                                    x = y[v],
                                    b = y[d];
                                y[d] = x, void 0 === b && (b = new Dl(u, r[f], a[f])), y[v] = b
                            }
                        } else t[d] !== p && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = n
                },
                remove: function() {
                    for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, a = 0, o = arguments.length; a !== o; ++a) {
                        var s = arguments[a],
                            c = s.uuid,
                            l = n[c];
                        if (void 0 !== l && l >= e) {
                            var u = e++,
                                h = t[u];
                            n[h.uuid] = l, t[l] = h, n[c] = u, t[u] = s;
                            for (var d = 0, p = r; d !== p; ++d) {
                                var f = i[d],
                                    m = f[u],
                                    v = f[l];
                                f[l] = m, f[u] = v
                            }
                        }
                    }
                    this.nCachedObjects_ = e
                },
                uncache: function() {
                    for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                        var c = arguments[o].uuid,
                            l = i[c];
                        if (void 0 !== l)
                            if (delete i[c], l < n) {
                                var u = --n,
                                    h = t[u],
                                    d = t[g = --e];
                                i[h.uuid] = l, t[l] = h, i[d.uuid] = u, t[u] = d, t.pop();
                                for (var p = 0, f = a; p !== f; ++p) {
                                    var m = (y = r[p])[u],
                                        v = y[g];
                                    y[l] = m, y[u] = v, y.pop()
                                }
                            } else {
                                var g;
                                i[(d = t[g = --e]).uuid] = l, t[l] = d, t.pop();
                                for (p = 0, f = a; p !== f; ++p) {
                                    var y;
                                    (y = r[p])[l] = y[g], y.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = n
                },
                subscribe_: function(t, e) {
                    var n = this._bindingsIndicesByPath,
                        i = n[t],
                        r = this._bindings;
                    if (void 0 !== i) return r[i];
                    var a = this._paths,
                        o = this._parsedPaths,
                        s = this._objects,
                        c = s.length,
                        l = this.nCachedObjects_,
                        u = new Array(c);
                    i = r.length, n[t] = i, a.push(t), o.push(e), r.push(u);
                    for (var h = l, d = s.length; h !== d; ++h) {
                        var p = s[h];
                        u[h] = new Dl(p, t, e)
                    }
                    return u
                },
                unsubscribe_: function(t) {
                    var e = this._bindingsIndicesByPath,
                        n = e[t];
                    if (void 0 !== n) {
                        var i = this._paths,
                            r = this._parsedPaths,
                            a = this._bindings,
                            o = a.length - 1,
                            s = a[o];
                        e[t[o]] = n, a[n] = s, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                    }
                }
            }), Object.assign(kl.prototype, {
                play: function() {
                    return this._mixer._activateAction(this), this
                },
                stop: function() {
                    return this._mixer._deactivateAction(this), this.reset()
                },
                reset: function() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                },
                isRunning: function() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function() {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function(t) {
                    return this._startTime = t, this
                },
                setLoop: function(t, e) {
                    return this.loop = t, this.repetitions = e, this
                },
                setEffectiveWeight: function(t) {
                    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                },
                getEffectiveWeight: function() {
                    return this._effectiveWeight
                },
                fadeIn: function(t) {
                    return this._scheduleFading(t, 0, 1)
                },
                fadeOut: function(t) {
                    return this._scheduleFading(t, 1, 0)
                },
                crossFadeFrom: function(t, e, n) {
                    if (t.fadeOut(e), this.fadeIn(e), n) {
                        var i = this._clip.duration,
                            r = t._clip.duration,
                            a = r / i,
                            o = i / r;
                        t.warp(1, a, e), this.warp(o, 1, e)
                    }
                    return this
                },
                crossFadeTo: function(t, e, n) {
                    return t.crossFadeFrom(this, e, n)
                },
                stopFading: function() {
                    var t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                },
                setEffectiveTimeScale: function(t) {
                    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                },
                getEffectiveTimeScale: function() {
                    return this._effectiveTimeScale
                },
                setDuration: function(t) {
                    return this.timeScale = this._clip.duration / t, this.stopWarping()
                },
                syncWith: function(t) {
                    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                },
                halt: function(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                },
                warp: function(t, e, n) {
                    var i = this._mixer,
                        r = i.time,
                        a = this._timeScaleInterpolant,
                        o = this.timeScale;
                    null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
                    var s = a.parameterPositions,
                        c = a.sampleValues;
                    return s[0] = r, s[1] = r + n, c[0] = t / o, c[1] = e / o, this
                },
                stopWarping: function() {
                    var t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                },
                getMixer: function() {
                    return this._mixer
                },
                getClip: function() {
                    return this._clip
                },
                getRoot: function() {
                    return this._localRoot || this._mixer._root
                },
                _update: function(t, e, n, i) {
                    if (this.enabled) {
                        var r = this._startTime;
                        if (null !== r) {
                            var a = (t - r) * n;
                            if (a < 0 || 0 === n) return;
                            this._startTime = null, e = n * a
                        }
                        e *= this._updateTimeScale(t);
                        var o = this._updateTime(e),
                            s = this._updateWeight(t);
                        if (s > 0)
                            for (var c = this._interpolants, l = this._propertyBindings, u = 0, h = c.length; u !== h; ++u) c[u].evaluate(o), l[u].accumulate(i, s)
                    } else this._updateWeight(t)
                },
                _updateWeight: function(t) {
                    var e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        var n = this._weightInterpolant;
                        if (null !== n) {
                            var i = n.evaluate(t)[0];
                            e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = e, e
                },
                _updateTimeScale: function(t) {
                    var e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        var n = this._timeScaleInterpolant;
                        if (null !== n) e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                    return this._effectiveTimeScale = e, e
                },
                _updateTime: function(t) {
                    var e = this.time + t;
                    if (0 === t) return e;
                    var n = this._clip.duration,
                        i = this.loop,
                        r = this._loopCount;
                    if (2200 === i) {
                        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        t: {
                            if (e >= n) e = n;
                            else {
                                if (!(e < 0)) break t;
                                e = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        var a = 2202 === i;
                        if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), e >= n || e < 0) {
                            var o = Math.floor(e / n);
                            e -= n * o, r += Math.abs(o);
                            var s = this.repetitions - r;
                            if (s < 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                            else {
                                if (0 === s) {
                                    var c = t < 0;
                                    this._setEndings(c, !c, a)
                                } else this._setEndings(!1, !1, a);
                                this._loopCount = r, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: o
                                })
                            }
                        }
                        if (a && 1 == (1 & r)) return this.time = e, n - e
                    }
                    return this.time = e, e
                },
                _setEndings: function(t, e, n) {
                    var i = this._interpolantSettings;
                    n ? (i.endingStart = fe, i.endingEnd = fe) : (i.endingStart = t ? this.zeroSlopeAtStart ? fe : pe : me, i.endingEnd = e ? this.zeroSlopeAtEnd ? fe : pe : me)
                },
                _scheduleFading: function(t, e, n) {
                    var i = this._mixer,
                        r = i.time,
                        a = this._weightInterpolant;
                    null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
                    var o = a.parameterPositions,
                        s = a.sampleValues;
                    return o[0] = r, s[0] = e, o[1] = r + t, s[1] = n, this
                }
            }), Fl.prototype = Object.assign(Object.create(e.prototype), {
                constructor: Fl,
                _bindAction: function(t, e) {
                    var n = t._localRoot || this._root,
                        i = t._clip.tracks,
                        r = i.length,
                        a = t._propertyBindings,
                        o = t._interpolants,
                        s = n.uuid,
                        c = this._bindingsByRootAndName,
                        l = c[s];
                    void 0 === l && (l = {}, c[s] = l);
                    for (var u = 0; u !== r; ++u) {
                        var h = i[u],
                            d = h.name,
                            p = l[d];
                        if (void 0 !== p) a[u] = p;
                        else {
                            if (void 0 !== (p = a[u])) {
                                null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                continue
                            }
                            var f = e && e._propertyBindings[u].binding.parsedPath;
                            ++(p = new Il(Dl.create(n, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), a[u] = p
                        }
                        o[u].resultBuffer = p.buffer
                    }
                },
                _activateAction: function(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            var e = (t._localRoot || this._root).uuid,
                                n = t._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                        }
                        for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
                            var s = r[a];
                            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                },
                _deactivateAction: function(t) {
                    if (this._isActiveAction(t)) {
                        for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                            var r = e[n];
                            0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                        }
                        this._takeBackAction(t)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var t = this;
                    this.stats = {
                        actions: {get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(t) {
                    var e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                },
                _addInactiveAction: function(t, e, n) {
                    var i = this._actions,
                        r = this._actionsByClip,
                        a = r[e];
                    if (void 0 === a) a = {
                        knownActions: [t],
                        actionByRoot: {}
                    }, t._byClipCacheIndex = 0, r[e] = a;
                    else {
                        var o = a.knownActions;
                        t._byClipCacheIndex = o.length, o.push(t)
                    }
                    t._cacheIndex = i.length, i.push(t), a.actionByRoot[n] = t
                },
                _removeInactiveAction: function(t) {
                    var e = this._actions,
                        n = e[e.length - 1],
                        i = t._cacheIndex;
                    n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                    var r = t._clip.uuid,
                        a = this._actionsByClip,
                        o = a[r],
                        s = o.knownActions,
                        c = s[s.length - 1],
                        l = t._byClipCacheIndex;
                    c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(t)
                },
                _removeInactiveBindingsForAction: function(t) {
                    for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                        var r = e[n];
                        0 == --r.referenceCount && this._removeInactiveBinding(r)
                    }
                },
                _lendAction: function(t) {
                    var e = this._actions,
                        n = t._cacheIndex,
                        i = this._nActiveActions++,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                },
                _takeBackAction: function(t) {
                    var e = this._actions,
                        n = t._cacheIndex,
                        i = --this._nActiveActions,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                },
                _addInactiveBinding: function(t, e, n) {
                    var i = this._bindingsByRootAndName,
                        r = i[e],
                        a = this._bindings;
                    void 0 === r && (r = {}, i[e] = r), r[n] = t, t._cacheIndex = a.length, a.push(t)
                },
                _removeInactiveBinding: function(t) {
                    var e = this._bindings,
                        n = t.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        a = this._bindingsByRootAndName,
                        o = a[i],
                        s = e[e.length - 1],
                        c = t._cacheIndex;
                    s._cacheIndex = c, e[c] = s, e.pop(), delete o[r];
                    t: {
                        for (var l in o) break t;
                        delete a[i]
                    }
                },
                _lendBinding: function(t) {
                    var e = this._bindings,
                        n = t._cacheIndex,
                        i = this._nActiveBindings++,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                },
                _takeBackBinding: function(t) {
                    var e = this._bindings,
                        n = t._cacheIndex,
                        i = --this._nActiveBindings,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                },
                _lendControlInterpolant: function() {
                    var t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++,
                        n = t[e];
                    return void 0 === n && ((n = new fc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n
                },
                _takeBackControlInterpolant: function(t) {
                    var e = this._controlInterpolants,
                        n = t.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = e[i];
                    t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(t, e) {
                    var n = e || this._root,
                        i = n.uuid,
                        r = "string" == typeof t ? xc.findByName(n, t) : t,
                        a = null !== r ? r.uuid : t,
                        o = this._actionsByClip[a],
                        s = null;
                    if (void 0 !== o) {
                        var c = o.actionByRoot[i];
                        if (void 0 !== c) return c;
                        s = o.knownActions[0], null === r && (r = s._clip)
                    }
                    if (null === r) return null;
                    var l = new kl(this, r, e);
                    return this._bindAction(l, s), this._addInactiveAction(l, a, i), l
                },
                existingAction: function(t, e) {
                    var n = e || this._root,
                        i = n.uuid,
                        r = "string" == typeof t ? xc.findByName(n, t) : t,
                        a = r ? r.uuid : t,
                        o = this._actionsByClip[a];
                    return void 0 !== o && o.actionByRoot[i] || null
                },
                stopAllAction: function() {
                    var t = this._actions,
                        e = this._nActiveActions,
                        n = this._bindings,
                        i = this._nActiveBindings;
                    this._nActiveActions = 0, this._nActiveBindings = 0;
                    for (var r = 0; r !== e; ++r) t[r].reset();
                    for (r = 0; r !== i; ++r) n[r].useCount = 0;
                    return this
                },
                update: function(t) {
                    t *= this.timeScale;
                    for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                        e[o]._update(i, t, r, a)
                    }
                    var s = this._bindings,
                        c = this._nActiveBindings;
                    for (o = 0; o !== c; ++o) s[o].apply(a);
                    return this
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(t) {
                    var e = this._actions,
                        n = t.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                            var c = a[o];
                            this._deactivateAction(c);
                            var l = c._cacheIndex,
                                u = e[e.length - 1];
                            c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = l, e[l] = u, e.pop(), this._removeInactiveBindingsForAction(c)
                        }
                        delete i[n]
                    }
                },
                uncacheRoot: function(t) {
                    var e = t.uuid,
                        n = this._actionsByClip;
                    for (var i in n) {
                        var r = n[i].actionByRoot[e];
                        void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                    }
                    var a = this._bindingsByRootAndName[e];
                    if (void 0 !== a)
                        for (var o in a) {
                            var s = a[o];
                            s.restoreOriginalState(), this._removeInactiveBinding(s)
                        }
                },
                uncacheAction: function(t, e) {
                    var n = this.existingAction(t, e);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }), zl.prototype.clone = function() {
                return new zl(void 0 === this.value.clone ? this.value : this.value.clone())
            }, Bl.prototype = Object.assign(Object.create(Br.prototype), {
                constructor: Bl,
                isInstancedBufferGeometry: !0,
                copy: function(t) {
                    return Br.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), Object.defineProperties(jl.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(jl.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
                }
            }), Object.defineProperty(Gl.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Gl.prototype, {
                isInterleavedBuffer: !0,
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride, n *= e.stride;
                    for (var i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                }
            }), Hl.prototype = Object.assign(Object.create(Gl.prototype), {
                constructor: Hl,
                isInstancedInterleavedBuffer: !0,
                copy: function(t) {
                    return Gl.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                }
            }), Vl.prototype = Object.assign(Object.create(Yi.prototype), {
                constructor: Vl,
                isInstancedBufferAttribute: !0,
                copy: function(t) {
                    return Yi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                }
            }), Object.assign(Wl.prototype, {
                linePrecision: 1,
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(t, e) {
                    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(t, e) {
                    var n = [];
                    return ql(t, this, n, e), n.sort(Xl), n
                },
                intersectObjects: function(t, e) {
                    var n = [];
                    if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
                    for (var i = 0, r = t.length; i < r; i++) ql(t[i], this, n, e);
                    return n.sort(Xl), n
                }
            }), Object.assign(Yl.prototype, {
                start: function() {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var e = ("undefined" == typeof performance ? Date : performance).now();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }), Object.assign($l.prototype, {
                set: function(t, e, n) {
                    return this.radius = t, this.phi = e, this.theta = n, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                },
                makeSafe: function() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                },
                setFromVector3: function(t) {
                    return this.radius = t.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(Le.clamp(t.y / this.radius, -1, 1))), this
                }
            }), Object.assign(Zl.prototype, {
                set: function(t, e, n) {
                    return this.radius = t, this.theta = e, this.y = n, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                },
                setFromVector3: function(t) {
                    return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this
                }
            }), Jl.prototype = Object.create(Ui.prototype), Jl.prototype.constructor = Jl, Jl.prototype.isImmediateRenderObject = !0, Kl.prototype = Object.create(Va.prototype), Kl.prototype.constructor = Kl, Kl.prototype.update = (il = new Oe, rl = new Oe, al = new Ie, function() {
                var t = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), al.getNormalMatrix(this.object.matrixWorld);
                var e = this.object.matrixWorld,
                    n = this.geometry.attributes.position,
                    i = this.object.geometry;
                if (i && i.isGeometry)
                    for (var r = i.vertices, a = i.faces, o = 0, s = 0, c = a.length; s < c; s++)
                        for (var l = a[s], u = 0, h = l.vertexNormals.length; u < h; u++) {
                            var d = r[l[t[u]]],
                                p = l.vertexNormals[u];
                            il.copy(d).applyMatrix4(e), rl.copy(p).applyMatrix3(al).normalize().multiplyScalar(this.size).add(il), n.setXYZ(o, il.x, il.y, il.z), o += 1, n.setXYZ(o, rl.x, rl.y, rl.z), o += 1
                        } else if (i && i.isBufferGeometry) {
                            var f = i.attributes.position,
                                m = i.attributes.normal;
                            for (o = 0, u = 0, h = f.count; u < h; u++) il.set(f.getX(u), f.getY(u), f.getZ(u)).applyMatrix4(e), rl.set(m.getX(u), m.getY(u), m.getZ(u)), rl.applyMatrix3(al).normalize().multiplyScalar(this.size).add(il), n.setXYZ(o, il.x, il.y, il.z), o += 1, n.setXYZ(o, rl.x, rl.y, rl.z), o += 1
                        }
                n.needsUpdate = !0
            }), Ql.prototype = Object.create(Ui.prototype), Ql.prototype.constructor = Ql, Ql.prototype.dispose = function() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, Ql.prototype.update = (ol = new Oe, sl = new Oe, function() {
                this.light.updateMatrixWorld();
                var t = this.light.distance ? this.light.distance : 1e3,
                    e = t * Math.tan(this.light.angle);
                this.cone.scale.set(e, e, t), ol.setFromMatrixPosition(this.light.matrixWorld), sl.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(sl.sub(ol)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }), tu.prototype = Object.create(Va.prototype), tu.prototype.constructor = tu, tu.prototype.updateMatrixWorld = (cl = new Oe, ll = new Ce, ul = new Ce, function(t) {
                var e = this.bones,
                    n = this.geometry,
                    i = n.getAttribute("position");
                ul.getInverse(this.root.matrixWorld);
                for (var r = 0, a = 0; r < e.length; r++) {
                    var o = e[r];
                    o.parent && o.parent.isBone && (ll.multiplyMatrices(ul, o.matrixWorld), cl.setFromMatrixPosition(ll), i.setXYZ(a, cl.x, cl.y, cl.z), ll.multiplyMatrices(ul, o.parent.matrixWorld), cl.setFromMatrixPosition(ll), i.setXYZ(a + 1, cl.x, cl.y, cl.z), a += 2)
                }
                n.getAttribute("position").needsUpdate = !0, Ui.prototype.updateMatrixWorld.call(this, t)
            }), eu.prototype = Object.create(Zr.prototype), eu.prototype.constructor = eu, eu.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, eu.prototype.update = function() {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }, nu.prototype = Object.create(Ui.prototype), nu.prototype.constructor = nu, nu.prototype.dispose = function() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, nu.prototype.update = function() {
                var t = .5 * this.light.width,
                    e = .5 * this.light.height,
                    n = this.line.geometry.attributes.position,
                    i = n.array;
                i[0] = t, i[1] = -e, i[2] = 0, i[3] = t, i[4] = e, i[5] = 0, i[6] = -t, i[7] = e, i[8] = 0, i[9] = -t, i[10] = -e, i[11] = 0, i[12] = t, i[13] = -e, i[14] = 0, n.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
            }, iu.prototype = Object.create(Ui.prototype), iu.prototype.constructor = iu, iu.prototype.dispose = function() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, iu.prototype.update = (hl = new Oe, dl = new Cn, pl = new Cn, function() {
                var t = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var e = t.geometry.getAttribute("color");
                    dl.copy(this.light.color), pl.copy(this.light.groundColor);
                    for (var n = 0, i = e.count; n < i; n++) {
                        var r = n < i / 2 ? dl : pl;
                        e.setXYZ(n, r.r, r.g, r.b)
                    }
                    e.needsUpdate = !0
                }
                t.lookAt(hl.setFromMatrixPosition(this.light.matrixWorld).negate())
            }), ru.prototype = Object.create(Va.prototype), ru.prototype.constructor = ru, au.prototype = Object.create(Va.prototype), au.prototype.constructor = au, ou.prototype = Object.create(Va.prototype), ou.prototype.constructor = ou, ou.prototype.update = (fl = new Oe, ml = new Oe, vl = new Ie, function() {
                this.object.updateMatrixWorld(!0), vl.getNormalMatrix(this.object.matrixWorld);
                for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, n = this.object.geometry, i = n.vertices, r = n.faces, a = 0, o = 0, s = r.length; o < s; o++) {
                    var c = r[o],
                        l = c.normal;
                    fl.copy(i[c.a]).add(i[c.b]).add(i[c.c]).divideScalar(3).applyMatrix4(t), ml.copy(l).applyMatrix3(vl).normalize().multiplyScalar(this.size).add(fl), e.setXYZ(a, fl.x, fl.y, fl.z), a += 1, e.setXYZ(a, ml.x, ml.y, ml.z), a += 1
                }
                e.needsUpdate = !0
            }), su.prototype = Object.create(Ui.prototype), su.prototype.constructor = su, su.prototype.dispose = function() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, su.prototype.update = (gl = new Oe, yl = new Oe, xl = new Oe, function() {
                gl.setFromMatrixPosition(this.light.matrixWorld), yl.setFromMatrixPosition(this.light.target.matrixWorld), xl.subVectors(yl, gl), this.lightPlane.lookAt(xl), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(xl), this.targetLine.scale.z = xl.length()
            }), cu.prototype = Object.create(Va.prototype), cu.prototype.constructor = cu, cu.prototype.update = function() {
                var t, e, n = new Oe,
                    i = new ki;
  
                function r(r, a, o, s) {
                    n.set(a, o, s).unproject(i);
                    var c = e[r];
                    if (void 0 !== c)
                        for (var l = t.getAttribute("position"), u = 0, h = c.length; u < h; u++) l.setXYZ(c[u], n.x, n.y, n.z)
                }
                return function() {
                    t = this.geometry, e = this.pointMap;
                    i.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                }
            }(), lu.prototype = Object.create(Va.prototype), lu.prototype.constructor = lu, lu.prototype.update = (bl = new ci, function(t) {
                if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && bl.setFromObject(this.object), !bl.isEmpty()) {
                    var e = bl.min,
                        n = bl.max,
                        i = this.geometry.attributes.position,
                        r = i.array;
                    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }), lu.prototype.setFromObject = function(t) {
                return this.object = t, this.update(), this
            }, uu.prototype = Object.create(Va.prototype), uu.prototype.constructor = uu, uu.prototype.updateMatrixWorld = function(t) {
                var e = this.box;
                e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Ui.prototype.updateMatrixWorld.call(this, t))
            }, hu.prototype = Object.create(Ha.prototype), hu.prototype.constructor = hu, hu.prototype.updateMatrixWorld = function(t) {
                var e = -this.plane.constant;
                Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.lookAt(this.plane.normal), Ui.prototype.updateMatrixWorld.call(this, t)
            }, du.prototype = Object.create(Ui.prototype), du.prototype.constructor = du, du.prototype.setDirection = (El = new Oe, function(t) {
                t.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (El.set(t.z, 0, -t.x).normalize(), Ml = Math.acos(t.y), this.quaternion.setFromAxisAngle(El, Ml))
            }), du.prototype.setLength = function(t, e, n) {
                void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
            }, du.prototype.setColor = function(t) {
                this.line.material.color.copy(t), this.cone.material.color.copy(t)
            }, pu.prototype = Object.create(Va.prototype), pu.prototype.constructor = pu;
            var fu = {
                createMultiMaterialObject: function(t, e) {
                    for (var n = new Ya, i = 0, r = e.length; i < r; i++) n.add(new Zr(t, e[i]));
                    return n
                },
                detach: function(t, e, n) {
                    t.applyMatrix(e.matrixWorld), e.remove(t), n.add(t)
                },
                attach: function(t, e, n) {
                    t.applyMatrix((new Ce).getInverse(n.matrixWorld)), e.remove(t), n.add(t)
                }
            };
            var mu;
  
            function vu(t) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Ds.call(this, t), this.type = "catmullrom", this.closed = !0
            }
  
            function gu(t) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Ds.call(this, t), this.type = "catmullrom"
            }
  
            function yu(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Ds.call(this, t), this.type = "catmullrom"
            }
            As.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(As.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Object.assign(qs.prototype, {
                createPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var e = new qi, n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.vertices.push(new Oe(r.x, r.y, r.z || 0))
                    }
                    return e
                }
            }), Object.assign(Ys.prototype, {
                fromPoints: function(t) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }
            }), vu.prototype = Object.create(Ds.prototype), gu.prototype = Object.create(Ds.prototype), yu.prototype = Object.create(Ds.prototype), Object.assign(yu.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), ru.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, tu.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(Ac.prototype, {
                extractUrlBase: function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Pc.extractUrlBase(t)
                }
            }), Object.assign(kn.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign(ci.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Yr.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Object.assign(Le, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Le.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Le.ceilPowerOfTwo(t)
                }
            }), Object.assign(Ie.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(Ce.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                getPosition: function() {
                    return void 0 === mu && (mu = new Oe), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), mu.setFromMatrixColumn(this, 3)
                },
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(t, e, n, i, r, a) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, a)
                }
            }), ui.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, Re.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, Object.assign(qr.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }
            }), Object.assign($s.prototype, {
                extractAllPoints: function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                },
                extrude: function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Bo(this, t)
                },
                makeGeometry: function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Zo(this, t)
                }
            }), Object.assign(Pe.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Oe.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Fe.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), qi.prototype.computeTangents = function() {
                console.warn("THREE.Geometry: .computeTangents() has been removed.")
            }, Object.assign(Ui.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                }
            }), Object.defineProperties(Ui.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(Fa.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(za.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Object.defineProperty(As.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), Aa.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(Zs.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(Yi.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                }
            }), Object.assign(Br.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                },
                addDrawCall: function(t, e, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(Br.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.defineProperties(zl.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(ai.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new Cn
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                    }
                }
            }), Object.defineProperties(hs.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(Xr.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), Object.assign(Ra.prototype, {
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }
            }), Object.defineProperties(Ra.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        return this.shadowMap.cullFace
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = t
                    }
                }
            }), Object.defineProperties(di.prototype, {
                cullFace: {
                    get: function() {
                        return this.renderReverseSided ? T : E
                    },
                    set: function(t) {
                        var e = t !== E;
                        console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."), this.renderReverseSided = e
                    }
                }
            }), Object.defineProperties(ze.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.assign(Pa.prototype, {
                getStandingMatrix: function() {
                    console.warn("THREE.WebVRManager: .getStandingMatrix() has been removed.")
                }
            }), Object.defineProperties(Pa.prototype, {
                standing: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                }
            }), Cl.prototype.load = function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var e = this;
                return (new Sl).load(t, function(t) {
                    e.setBuffer(t)
                }), this
            }, Ol.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Ll.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            };
            var xu = {
                    merge: function(t, e, n) {
                        var i;
                        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, n)
                    },
                    center: function(t) {
                        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
                    }
                },
                bu = {
                    crossOrigin: void 0,
                    loadTexture: function(t, e, n, i) {
                        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                        var r = new Ss;
                        r.setCrossOrigin(this.crossOrigin);
                        var a = r.load(t, n, void 0, i);
                        return e && (a.mapping = e), a
                    },
                    loadTextureCube: function(t, e, n, i) {
                        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                        var r = new Ts;
                        r.setCrossOrigin(this.crossOrigin);
                        var a = r.load(t, n, void 0, i);
                        return e && (a.mapping = e), a
                    },
                    loadCompressedTexture: function() {
                        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                    },
                    loadCompressedTextureCube: function() {
                        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                    }
                };
            t.WebGLRenderTargetCube = Be, t.WebGLRenderTarget = ze, t.WebGLRenderer = Ra, t.ShaderLib = Un, t.UniformsLib = In, t.UniformsUtils = Nn, t.ShaderChunk = Dn, t.FogExp2 = Oa, t.Fog = Ia, t.Scene = Na, t.LensFlare = Da, t.Sprite = ka, t.LOD = Fa, t.SkinnedMesh = ja, t.Skeleton = za, t.Bone = Ba, t.Mesh = Zr, t.LineSegments = Va, t.LineLoop = Wa, t.Line = Ha, t.Points = qa, t.Group = Ya, t.VideoTexture = $a, t.DataTexture = je, t.CompressedTexture = Za, t.CubeTexture = Ge, t.CanvasTexture = zn, t.DepthTexture = Ja, t.Texture = ke, t.CompressedTextureLoader = _s, t.DataTextureLoader = Ms, t.CubeTextureLoader = Ts, t.TextureLoader = Ss, t.ObjectLoader = Rc, t.MaterialLoader = bc, t.BufferGeometryLoader = wc, t.DefaultLoadingManager = xs, t.LoadingManager = ys, t.JSONLoader = Cc, t.ImageLoader = Es, t.ImageBitmapLoader = Uc, t.FontLoader = zc, t.FileLoader = ws, t.Loader = Ac, t.LoaderUtils = Pc, t.Cache = gs, t.AudioLoader = Sl, t.SpotLightShadow = Qs, t.SpotLight = tc, t.PointLight = ec, t.RectAreaLight = ac, t.HemisphereLight = Js, t.DirectionalLightShadow = nc, t.DirectionalLight = ic, t.AmbientLight = rc, t.LightShadow = Ks, t.Light = Zs, t.StereoCamera = Al, t.PerspectiveCamera = Aa, t.OrthographicCamera = Fi, t.CubeCamera = Ll, t.ArrayCamera = La, t.Camera = ki, t.AudioListener = Pl, t.PositionalAudio = Rl, t.AudioContext = Tl, t.AudioAnalyser = Ol, t.Audio = Cl, t.VectorKeyframeTrack = yc, t.StringKeyframeTrack = oc, t.QuaternionKeyframeTrack = uc, t.NumberKeyframeTrack = dc, t.ColorKeyframeTrack = hc, t.BooleanKeyframeTrack = sc, t.PropertyMixer = Il, t.PropertyBinding = Dl, t.KeyframeTrack = gc, t.AnimationUtils = vc, t.AnimationObjectGroup = Ul, t.AnimationMixer = Fl, t.AnimationClip = xc, t.Uniform = zl, t.InstancedBufferGeometry = Bl, t.BufferGeometry = Br, t.Geometry = qi, t.InterleavedBufferAttribute = jl, t.InstancedInterleavedBuffer = Hl, t.InterleavedBuffer = Gl, t.InstancedBufferAttribute = Vl, t.Face3 = zi, t.Object3D = Ui, t.Raycaster = Wl, t.Layers = mi, t.EventDispatcher = e, t.Clock = Yl, t.QuaternionLinearInterpolant = lc, t.LinearInterpolant = fc, t.DiscreteInterpolant = mc, t.CubicInterpolant = pc, t.Interpolant = cc, t.Triangle = $r, t.Math = Le, t.Spherical = $l, t.Cylindrical = Zl, t.Plane = ui, t.Frustum = hi, t.Sphere = li, t.Ray = qr, t.Matrix4 = Ce, t.Matrix3 = Ie, t.Box3 = ci, t.Box2 = kn, t.Line3 = Yr, t.Euler = fi, t.Vector4 = Fe, t.Vector3 = Oe, t.Vector2 = Pe, t.Quaternion = Re, t.Color = Cn, t.ImmediateRenderObject = Jl, t.VertexNormalsHelper = Kl, t.SpotLightHelper = Ql, t.SkeletonHelper = tu, t.PointLightHelper = eu, t.RectAreaLightHelper = nu, t.HemisphereLightHelper = iu, t.GridHelper = ru, t.PolarGridHelper = au, t.FaceNormalsHelper = ou, t.DirectionalLightHelper = su, t.CameraHelper = cu, t.BoxHelper = lu, t.Box3Helper = uu, t.PlaneHelper = hu, t.ArrowHelper = du, t.AxesHelper = pu, t.Shape = $s, t.Path = Ys, t.ShapePath = kc, t.Font = Fc, t.CurvePath = qs, t.Curve = As, t.ShapeUtils = zo, t.SceneUtils = fu, t.WebGLUtils = Ca, t.WireframeGeometry = Ka, t.ParametricGeometry = Qa, t.ParametricBufferGeometry = to, t.TetrahedronGeometry = io, t.TetrahedronBufferGeometry = ro, t.OctahedronGeometry = ao, t.OctahedronBufferGeometry = oo, t.IcosahedronGeometry = so, t.IcosahedronBufferGeometry = co, t.DodecahedronGeometry = lo, t.DodecahedronBufferGeometry = uo, t.PolyhedronGeometry = eo, t.PolyhedronBufferGeometry = no, t.TubeGeometry = ho, t.TubeBufferGeometry = po, t.TorusKnotGeometry = fo, t.TorusKnotBufferGeometry = mo, t.TorusGeometry = vo, t.TorusBufferGeometry = go, t.TextGeometry = Go, t.TextBufferGeometry = Ho, t.SphereGeometry = Vo, t.SphereBufferGeometry = Wo, t.RingGeometry = Xo, t.RingBufferGeometry = qo, t.PlaneGeometry = Hr, t.PlaneBufferGeometry = Vr, t.LatheGeometry = Yo, t.LatheBufferGeometry = $o, t.ShapeGeometry = Zo, t.ShapeBufferGeometry = Jo, t.ExtrudeGeometry = Bo, t.ExtrudeBufferGeometry = jo, t.EdgesGeometry = Qo, t.ConeGeometry = ns, t.ConeBufferGeometry = is, t.CylinderGeometry = ts, t.CylinderBufferGeometry = es, t.CircleGeometry = rs, t.CircleBufferGeometry = as, t.BoxGeometry = jr, t.BoxBufferGeometry = Gr, t.ShadowMaterial = ss, t.SpriteMaterial = Ua, t.RawShaderMaterial = cs, t.ShaderMaterial = Xr, t.PointsMaterial = Xa, t.MeshPhysicalMaterial = us, t.MeshStandardMaterial = ls, t.MeshPhongMaterial = hs, t.MeshToonMaterial = ds, t.MeshNormalMaterial = ps, t.MeshLambertMaterial = fs, t.MeshDepthMaterial = oi, t.MeshDistanceMaterial = si, t.MeshBasicMaterial = Wr, t.LineDashedMaterial = ms, t.LineBasicMaterial = Ga, t.Material = ai, t.Float64BufferAttribute = ir, t.Float32BufferAttribute = nr, t.Uint32BufferAttribute = er, t.Int32BufferAttribute = tr, t.Uint16BufferAttribute = Qi, t.Int16BufferAttribute = Ki, t.Uint8ClampedBufferAttribute = Ji, t.Uint8BufferAttribute = Zi, t.Int8BufferAttribute = $i, t.BufferAttribute = Yi, t.ArcCurve = Ps, t.CatmullRomCurve3 = Ds, t.CubicBezierCurve = zs, t.CubicBezierCurve3 = Bs, t.EllipseCurve = Ls, t.LineCurve = js, t.LineCurve3 = Gs, t.QuadraticBezierCurve = Hs, t.QuadraticBezierCurve3 = Vs, t.SplineCurve = Ws, t.REVISION = _, t.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            }, t.CullFaceNone = M, t.CullFaceBack = E, t.CullFaceFront = T, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = S, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = A, t.PCFSoftShadowMap = L, t.FrontSide = P, t.BackSide = C, t.DoubleSide = R, t.FlatShading = 1, t.SmoothShading = 2, t.NoColors = O, t.FaceColors = I, t.VertexColors = N, t.NoBlending = D, t.NormalBlending = U, t.AdditiveBlending = k, t.SubtractiveBlending = F, t.MultiplyBlending = z, t.CustomBlending = B, t.AddEquation = j, t.SubtractEquation = G, t.ReverseSubtractEquation = H, t.MinEquation = V, t.MaxEquation = W, t.ZeroFactor = X, t.OneFactor = q, t.SrcColorFactor = Y, t.OneMinusSrcColorFactor = $, t.SrcAlphaFactor = Z, t.OneMinusSrcAlphaFactor = J, t.DstAlphaFactor = K, t.OneMinusDstAlphaFactor = Q, t.DstColorFactor = tt, t.OneMinusDstColorFactor = et, t.SrcAlphaSaturateFactor = nt, t.NeverDepth = it, t.AlwaysDepth = rt, t.LessDepth = at, t.LessEqualDepth = ot, t.EqualDepth = st, t.GreaterEqualDepth = ct, t.GreaterDepth = lt, t.NotEqualDepth = ut, t.MultiplyOperation = ht, t.MixOperation = dt, t.AddOperation = pt, t.NoToneMapping = ft, t.LinearToneMapping = mt, t.ReinhardToneMapping = vt, t.Uncharted2ToneMapping = gt, t.CineonToneMapping = yt, t.UVMapping = 300, t.CubeReflectionMapping = xt, t.CubeRefractionMapping = bt, t.EquirectangularReflectionMapping = wt, t.EquirectangularRefractionMapping = _t, t.SphericalReflectionMapping = Mt, t.CubeUVReflectionMapping = Et, t.CubeUVRefractionMapping = Tt, t.RepeatWrapping = St, t.ClampToEdgeWrapping = At, t.MirroredRepeatWrapping = Lt, t.NearestFilter = Pt, t.NearestMipMapNearestFilter = Ct, t.NearestMipMapLinearFilter = Rt, t.LinearFilter = Ot, t.LinearMipMapNearestFilter = It, t.LinearMipMapLinearFilter = Nt, t.UnsignedByteType = Dt, t.ByteType = Ut, t.ShortType = kt, t.UnsignedShortType = Ft, t.IntType = zt, t.UnsignedIntType = Bt, t.FloatType = jt, t.HalfFloatType = Gt, t.UnsignedShort4444Type = Ht, t.UnsignedShort5551Type = Vt, t.UnsignedShort565Type = Wt, t.UnsignedInt248Type = Xt, t.AlphaFormat = qt, t.RGBFormat = Yt, t.RGBAFormat = $t, t.LuminanceFormat = Zt, t.LuminanceAlphaFormat = Jt, t.RGBEFormat = Kt, t.DepthFormat = Qt, t.DepthStencilFormat = te, t.RGB_S3TC_DXT1_Format = ee, t.RGBA_S3TC_DXT1_Format = ne, t.RGBA_S3TC_DXT3_Format = ie, t.RGBA_S3TC_DXT5_Format = re, t.RGB_PVRTC_4BPPV1_Format = ae, t.RGB_PVRTC_2BPPV1_Format = oe, t.RGBA_PVRTC_4BPPV1_Format = se, t.RGBA_PVRTC_2BPPV1_Format = ce, t.RGB_ETC1_Format = le, t.LoopOnce = 2200, t.LoopRepeat = ue, t.LoopPingPong = 2202, t.InterpolateDiscrete = he, t.InterpolateLinear = de, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = pe, t.ZeroSlopeEnding = fe, t.WrapAroundEnding = me, t.TrianglesDrawMode = ve, t.TriangleStripDrawMode = ge, t.TriangleFanDrawMode = ye, t.LinearEncoding = xe, t.sRGBEncoding = be, t.GammaEncoding = we, t.RGBEEncoding = _e, t.LogLuvEncoding = 3003, t.RGBM7Encoding = Me, t.RGBM16Encoding = Ee, t.RGBDEncoding = Te, t.BasicDepthPacking = Se, t.RGBADepthPacking = Ae, t.CubeGeometry = jr, t.Face4 = function(t, e, n, i, r, a, o) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new zi(t, e, n, r, a, o)
            }, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = function(t) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
            }, t.MultiMaterial = function(t) {
                return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                    return t.slice()
                }, t
            }, t.PointCloud = function(t, e) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new qa(t, e)
            }, t.Particle = function(t) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new ka(t)
            }, t.ParticleSystem = function(t, e) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new qa(t, e)
            }, t.PointCloudMaterial = function(t) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Xa(t)
            }, t.ParticleBasicMaterial = function(t) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Xa(t)
            }, t.ParticleSystemMaterial = function(t) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Xa(t)
            }, t.Vertex = function(t, e, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Oe(t, e, n)
            }, t.DynamicBufferAttribute = function(t, e) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new Yi(t, e).setDynamic(!0)
            }, t.Int8Attribute = function(t, e) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new $i(t, e)
            }, t.Uint8Attribute = function(t, e) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Zi(t, e)
            }, t.Uint8ClampedAttribute = function(t, e) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Ji(t, e)
            }, t.Int16Attribute = function(t, e) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ki(t, e)
            }, t.Uint16Attribute = function(t, e) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Qi(t, e)
            }, t.Int32Attribute = function(t, e) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new tr(t, e)
            }, t.Uint32Attribute = function(t, e) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new er(t, e)
            }, t.Float32Attribute = function(t, e) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new nr(t, e)
            }, t.Float64Attribute = function(t, e) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ir(t, e)
            }, t.ClosedSplineCurve3 = vu, t.SplineCurve3 = gu, t.Spline = yu, t.AxisHelper = function(t) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new pu(t)
            }, t.BoundingBoxHelper = function(t, e) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new lu(t, e)
            }, t.EdgesHelper = function(t, e) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Va(new Qo(t.geometry), new Ga({
                    color: void 0 !== e ? e : 16777215
                }))
            }, t.WireframeHelper = function(t, e) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Va(new Ka(t.geometry), new Ga({
                    color: void 0 !== e ? e : 16777215
                }))
            }, t.XHRLoader = function(t) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new ws(t)
            }, t.BinaryTextureLoader = function(t) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ms(t)
            }, t.GeometryUtils = xu, t.ImageUtils = bu, t.Projector = function() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
                }, this.unprojectVector = function(t, e) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
                }, this.pickingRay = function() {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }, t.CanvasRenderer = function() {
                console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
            }, Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }, "object" == typeof n && void 0 !== e ? r(n) : "function" == typeof define && define.amd ? define(["exports"], r) : r(i.THREE = {})
    }, {}],
    11: [function(t, e, n) {
        ! function() {
            ! function(t, i) {
                "use strict";
                "function" == typeof define && define.amd ? define([], i) : "object" == typeof n ? e.exports = i() : t.viewportUnitsBuggyfill = i()
            }(this, function() {
                "use strict";
                var t, e, n, i, r, a = !1,
                    o = window.navigator.userAgent,
                    s = /([+-]?[0-9.]+)(vh|vw|vmin|vmax)/g,
                    c = /(https?:)?\/\//,
                    l = [].forEach,
                    u = /MSIE [0-9]\./i.test(o),
                    h = /MSIE [0-8]\./i.test(o),
                    d = o.indexOf("Opera Mini") > -1,
                    p = /(iPhone|iPod|iPad).+AppleWebKit/i.test(o) && ((r = o.match(/OS (\d)/)) && r.length > 1 && parseInt(r[1]) < 10),
                    f = o.indexOf(" Android ") > -1 && o.indexOf("Version/") > -1 && parseFloat((o.match("Android ([0-9.]+)") || [])[1]) <= 4.4;
                u || (u = !!navigator.userAgent.match(/MSIE 10\.|Trident.*rv[ :]*1[01]\.| Edge\/1\d\./));
                try {
                    new m("test")
                } catch (t) {
                    var m = function(t, e) {
                        var n;
                        return e = e || {
                            bubbles: !1,
                            cancelable: !1,
                            detail: void 0
                        }, (n = document.createEvent("CustomEvent")).initCustomEvent(t, e.bubbles, e.cancelable, e.detail), n
                    };
                    m.prototype = window.Event.prototype, window.CustomEvent = m
                }
  
                function v() {
                    a && (g(), setTimeout(function() {
                        i.textContent = x(), i.parentNode.appendChild(i), window.dispatchEvent(new m("viewport-units-buggyfill-style"))
                    }, 1))
                }
  
                function g() {
                    return n = [], l.call(document.styleSheets, function(t) {
                        var e = function(t) {
                            try {
                                if (!t.cssRules) return
                            } catch (t) {
                                if ("SecurityError" !== t.name) throw t;
                                return
                            }
                            for (var e = [], n = 0; n < t.cssRules.length; n++) {
                                var i = t.cssRules[n];
                                e.push(i)
                            }
                            return e
                        }(t);
                        e && "patched-viewport" !== t.ownerNode.id && "ignore" !== t.ownerNode.getAttribute("data-viewport-units-buggyfill") && (t.media && t.media.mediaText && window.matchMedia && !window.matchMedia(t.media.mediaText).matches || l.call(e, y))
                    }), n
                }
  
                function y(e) {
                    if (7 === e.type) {
                        var i;
                        try {
                            i = e.cssText
                        } catch (t) {
                            return
                        }
                        return s.lastIndex = 0, void(s.test(i) && !c.test(i) && (n.push([e, null, i]), t.hacks && t.hacks.findDeclarations(n, e, null, i)))
                    }
                    if (e.style) l.call(e.style, function(i) {
                        var r = e.style.getPropertyValue(i);
                        e.style.getPropertyPriority(i) && (r += " !important"), s.lastIndex = 0, s.test(r) && (n.push([e, i, r]), t.hacks && t.hacks.findDeclarations(n, e, i, r))
                    });
                    else {
                        if (!e.cssRules) return;
                        l.call(e.cssRules, function(t) {
                            y(t)
                        })
                    }
                }
  
                function x() {
                    var i, r;
                    i = window.innerHeight, r = window.innerWidth, e = {
                        vh: i,
                        vw: r,
                        vmax: Math.max(r, i),
                        vmin: Math.min(r, i)
                    };
                    var a, o, c = [],
                        l = [];
                    return n.forEach(function(e) {
                        var n = function(e, n, i) {
                                var r, a = [];
                                r = i.replace(s, b), t.hacks && (r = t.hacks.overwriteDeclaration(e, n, r));
                                n && (a.push(e.selectorText), r = n + ": " + r + ";");
                                var o = e.parentRule;
                                for (; o;) o.media ? a.unshift("@media " + o.media.mediaText) : o.conditionText && a.unshift("@supports " + o.conditionText), o = o.parentRule;
                                return {
                                    selector: a,
                                    content: r
                                }
                            }.apply(null, e),
                            i = n.selector.length ? n.selector.join(" {\n") + " {\n" : "",
                            r = new Array(n.selector.length + 1).join("\n}");
                        if (!i || i !== a) return l.length && (c.push(a + l.join("\n") + o), l.length = 0), void(i ? (a = i, o = r, l.push(n.content)) : (c.push(n.content), a = null, o = null));
                        i && !a && (a = i, o = r), l.push(n.content)
                    }), l.length && c.push(a + l.join("\n") + o), d && c.push("* { content: normal !important; }"), c.join("\n\n")
                }
  
                function b(t, n, i) {
                    var r = e[i];
                    return parseFloat(n) / 100 * r + "px"
                }
  
                function w(t) {
                    return t.slice(0, t.indexOf("/", t.indexOf("://") + 3))
                }
                return {
                    version: "0.6.1",
                    findProperties: g,
                    getCss: x,
                    init: function(e) {
                        if (!a) {
                            if (!0 === e && (e = {
                                    force: !0
                                }), (t = e || {}).isMobileSafari = p, t.isBadStockAndroid = f, !t.ignoreVmax || t.force || h || (u = !1), h || !t.force && !p && !u && !f && !d && (!t.hacks || !t.hacks.required(t))) return window.console && h && console.info("viewport-units-buggyfill requires a proper CSSOM and basic viewport unit support, which are not available in IE8 and below"), {
                                init: function() {}
                            };
                            var n, r, o;
                            window.dispatchEvent(new m("viewport-units-buggyfill-init")), t.hacks && t.hacks.initialize(t), a = !0, (i = document.createElement("style")).id = "patched-viewport", document[t.appendToBody ? "body" : "head"].appendChild(i), n = function() {
                                var e, n, i, r = (e = v, n = t.refreshDebounceWait || 100, function() {
                                    var t = this,
                                        r = arguments;
                                    clearTimeout(i), i = setTimeout(function() {
                                        e.apply(t, r)
                                    }, n)
                                });
                                window.addEventListener("orientationchange", r, !0), window.addEventListener("pageshow", r, !0), (t.force || u || function() {
                                    try {
                                        return window.self !== window.top
                                    } catch (t) {
                                        return !0
                                    }
                                }()) && (window.addEventListener("resize", r, !0), t._listeningToResize = !0), t.hacks && t.hacks.initializeEvents(t, v, r), v()
                            }, r = 0, o = function() {
                                --r || n()
                            }, l.call(document.styleSheets, function(t) {
                                var e, n;
                                t.href && w(t.href) !== w(location.href) && "ignore" !== t.ownerNode.getAttribute("data-viewport-units-buggyfill") && (r++, e = t.ownerNode, n = o, function(t, e, n) {
                                    var i = new XMLHttpRequest;
                                    if ("withCredentials" in i) i.open("GET", t, !0);
                                    else {
                                        if ("undefined" == typeof XDomainRequest) throw new Error("cross-domain XHR not supported");
                                        (i = new XDomainRequest).open("GET", t)
                                    }
                                    i.onload = e, i.onerror = n, i.send()
                                }(e.href, function() {
                                    var t = document.createElement("style");
                                    t.media = e.media, t.setAttribute("data-href", e.href), t.textContent = this.responseText, e.parentNode.replaceChild(t, e), n()
                                }, n))
                            }), r || n()
                        }
                    },
                    refresh: v
                }
            })
        }()
    }, {}],
    12: [function(t, e, n) {
        (function(t) {
            var i, r;
            i = this, r = function() {
                "use strict";
  
                function e(t) {
                    return null == t
                }
  
                function n(t) {
                    return null != t
                }
  
                function i(t) {
                    return !0 === t
                }
  
                function r(t) {
                    return "string" == typeof t || "number" == typeof t || "symbol" == typeof t || "boolean" == typeof t
                }
  
                function a(t) {
                    return null !== t && "object" == typeof t
                }
  
                function o(t) {
                    return "[object Object]" === mn.call(t)
                }
  
                function s(t) {
                    var e = parseFloat(String(t));
                    return e >= 0 && Math.floor(e) === e && isFinite(t)
                }
  
                function c(t) {
                    return null == t ? "" : "object" == typeof t ? JSON.stringify(t, null, 2) : String(t)
                }
  
                function l(t) {
                    var e = parseFloat(t);
                    return isNaN(e) ? t : e
                }
  
                function u(t, e) {
                    for (var n = Object.create(null), i = t.split(","), r = 0; r < i.length; r++) n[i[r]] = !0;
                    return e ? function(t) {
                        return n[t.toLowerCase()]
                    } : function(t) {
                        return n[t]
                    }
                }
  
                function h(t, e) {
                    if (t.length) {
                        var n = t.indexOf(e);
                        if (n > -1) return t.splice(n, 1)
                    }
                }
  
                function d(t, e) {
                    return yn.call(t, e)
                }
  
                function p(t) {
                    var e = Object.create(null);
                    return function(n) {
                        return e[n] || (e[n] = t(n))
                    }
                }
  
                function f(t, e) {
                    function n(n) {
                        var i = arguments.length;
                        return i ? i > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e)
                    }
                    return n._length = t.length, n
                }
  
                function m(t, e) {
                    e = e || 0;
                    for (var n = t.length - e, i = new Array(n); n--;) i[n] = t[n + e];
                    return i
                }
  
                function v(t, e) {
                    for (var n in e) t[n] = e[n];
                    return t
                }
  
                function g(t) {
                    for (var e = {}, n = 0; n < t.length; n++) t[n] && v(e, t[n]);
                    return e
                }
  
                function y(t, e, n) {}
  
                function x(t, e) {
                    if (t === e) return !0;
                    var n = a(t),
                        i = a(e);
                    if (!n || !i) return !n && !i && String(t) === String(e);
                    try {
                        var r = Array.isArray(t),
                            o = Array.isArray(e);
                        if (r && o) return t.length === e.length && t.every(function(t, n) {
                            return x(t, e[n])
                        });
                        if (r || o) return !1;
                        var s = Object.keys(t),
                            c = Object.keys(e);
                        return s.length === c.length && s.every(function(n) {
                            return x(t[n], e[n])
                        })
                    } catch (t) {
                        return !1
                    }
                }
  
                function b(t, e) {
                    for (var n = 0; n < t.length; n++)
                        if (x(t[n], e)) return n;
                    return -1
                }
  
                function w(t) {
                    var e = !1;
                    return function() {
                        e || (e = !0, t.apply(this, arguments))
                    }
                }
  
                function _(t, e, n, i) {
                    Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !!i,
                        writable: !0,
                        configurable: !0
                    })
                }
  
                function M(t) {
                    return "function" == typeof t && /native code/.test(t.toString())
                }
  
                function E(t) {
                    return new Qn(void 0, void 0, void 0, String(t))
                }
  
                function T(t, e) {
                    var n = t.componentOptions,
                        i = new Qn(t.tag, t.data, t.children, t.text, t.elm, t.context, n, t.asyncFactory);
                    return i.ns = t.ns, i.isStatic = t.isStatic, i.key = t.key, i.isComment = t.isComment, i.fnContext = t.fnContext, i.fnOptions = t.fnOptions, i.fnScopeId = t.fnScopeId, i.isCloned = !0, e && (t.children && (i.children = S(t.children, !0)), n && n.children && (n.children = S(n.children, !0))), i
                }
  
                function S(t, e) {
                    for (var n = t.length, i = new Array(n), r = 0; r < n; r++) i[r] = T(t[r], e);
                    return i
                }
  
                function A(t, e) {
                    var n;
                    if (a(t) && !(t instanceof Qn)) return d(t, "__ob__") && t.__ob__ instanceof oi ? n = t.__ob__ : ai.shouldConvert && !Xn() && (Array.isArray(t) || o(t)) && Object.isExtensible(t) && !t._isVue && (n = new oi(t)), e && n && n.vmCount++, n
                }
  
                function L(t, e, n, i, r) {
                    var a = new Jn,
                        o = Object.getOwnPropertyDescriptor(t, e);
                    if (!o || !1 !== o.configurable) {
                        var s = o && o.get,
                            c = o && o.set,
                            l = !r && A(n);
                        Object.defineProperty(t, e, {
                            enumerable: !0,
                            configurable: !0,
                            get: function() {
                                var e = s ? s.call(t) : n;
                                return Jn.target && (a.depend(), l && (l.dep.depend(), Array.isArray(e) && function t(e) {
                                    for (var n = void 0, i = 0, r = e.length; i < r; i++)(n = e[i]) && n.__ob__ && n.__ob__.dep.depend(), Array.isArray(n) && t(n)
                                }(e))), e
                            },
                            set: function(e) {
                                var i = s ? s.call(t) : n;
                                e === i || e != e && i != i || (c ? c.call(t, e) : n = e, l = !r && A(e), a.notify())
                            }
                        })
                    }
                }
  
                function P(t, e, n) {
                    if (Array.isArray(t) && s(e)) return t.length = Math.max(t.length, e), t.splice(e, 1, n), n;
                    if (e in t && !(e in Object.prototype)) return t[e] = n, n;
                    var i = t.__ob__;
                    return t._isVue || i && i.vmCount ? n : i ? (L(i.value, e, n), i.dep.notify(), n) : (t[e] = n, n)
                }
  
                function C(t, e) {
                    if (Array.isArray(t) && s(e)) t.splice(e, 1);
                    else {
                        var n = t.__ob__;
                        t._isVue || n && n.vmCount || d(t, e) && (delete t[e], n && n.dep.notify())
                    }
                }
  
                function R(t, e) {
                    if (!e) return t;
                    for (var n, i, r, a = Object.keys(e), s = 0; s < a.length; s++) i = t[n = a[s]], r = e[n], d(t, n) ? o(i) && o(r) && R(i, r) : P(t, n, r);
                    return t
                }
  
                function O(t, e, n) {
                    return n ? function() {
                        var i = "function" == typeof e ? e.call(n, n) : e,
                            r = "function" == typeof t ? t.call(n, n) : t;
                        return i ? R(i, r) : r
                    } : e ? t ? function() {
                        return R("function" == typeof e ? e.call(this, this) : e, "function" == typeof t ? t.call(this, this) : t)
                    } : e : t
                }
  
                function I(t, e) {
                    return e ? t ? t.concat(e) : Array.isArray(e) ? e : [e] : t
                }
  
                function N(t, e, n, i) {
                    var r = Object.create(t || null);
                    return e ? v(r, e) : r
                }
  
                function D(t, e, n) {
                    function i(i) {
                        var r = si[i] || ui;
                        l[i] = r(t[i], e[i], n, i)
                    }
                    "function" == typeof e && (e = e.options),
                        function(t, e) {
                            var n = t.props;
                            if (n) {
                                var i, r, a = {};
                                if (Array.isArray(n))
                                    for (i = n.length; i--;) "string" == typeof(r = n[i]) && (a[bn(r)] = {
                                        type: null
                                    });
                                else if (o(n))
                                    for (var s in n) r = n[s], a[bn(s)] = o(r) ? r : {
                                        type: r
                                    };
                                t.props = a
                            }
                        }(e),
                        function(t, e) {
                            var n = t.inject;
                            if (n) {
                                var i = t.inject = {};
                                if (Array.isArray(n))
                                    for (var r = 0; r < n.length; r++) i[n[r]] = {
                                        from: n[r]
                                    };
                                else if (o(n))
                                    for (var a in n) {
                                        var s = n[a];
                                        i[a] = o(s) ? v({
                                            from: a
                                        }, s) : {
                                            from: s
                                        }
                                    }
                            }
                        }(e),
                        function(t) {
                            var n = e.directives;
                            if (n)
                                for (var i in n) {
                                    var r = n[i];
                                    "function" == typeof r && (n[i] = {
                                        bind: r,
                                        update: r
                                    })
                                }
                        }();
                    var r = e.extends;
                    if (r && (t = D(t, r, n)), e.mixins)
                        for (var a = 0, s = e.mixins.length; a < s; a++) t = D(t, e.mixins[a], n);
                    var c, l = {};
                    for (c in t) i(c);
                    for (c in e) d(t, c) || i(c);
                    return l
                }
  
                function U(t, e, n, i) {
                    if ("string" == typeof n) {
                        var r = t[e];
                        if (d(r, n)) return r[n];
                        var a = bn(n);
                        if (d(r, a)) return r[a];
                        var o = wn(a);
                        return d(r, o) ? r[o] : r[n] || r[a] || r[o]
                    }
                }
  
                function k(t, e, n, i) {
                    var r = e[t],
                        a = !d(n, t),
                        o = n[t];
                    if (z(Boolean, r.type) && (a && !d(r, "default") ? o = !1 : z(String, r.type) || "" !== o && o !== Mn(t) || (o = !0)), void 0 === o) {
                        o = function(t, e, n) {
                            if (d(e, "default")) {
                                var i = e.default;
                                return t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n] ? t._props[n] : "function" == typeof i && "Function" !== F(e.type) ? i.call(t) : i
                            }
                        }(i, r, t);
                        var s = ai.shouldConvert;
                        ai.shouldConvert = !0, A(o), ai.shouldConvert = s
                    }
                    return o
                }
  
                function F(t) {
                    var e = t && t.toString().match(/^\s*function (\w+)/);
                    return e ? e[1] : ""
                }
  
                function z(t, e) {
                    if (!Array.isArray(e)) return F(e) === F(t);
                    for (var n = 0, i = e.length; n < i; n++)
                        if (F(e[n]) === F(t)) return !0;
                    return !1
                }
  
                function B(t, e, n) {
                    if (e)
                        for (var i = e; i = i.$parent;) {
                            var r = i.$options.errorCaptured;
                            if (r)
                                for (var a = 0; a < r.length; a++) try {
                                    if (!1 === r[a].call(i, t, e, n)) return
                                } catch (t) {
                                    j(t, i, "errorCaptured hook")
                                }
                        }
                    j(t, e, n)
                }
  
                function j(t, e, n) {
                    if (Pn.errorHandler) try {
                        return Pn.errorHandler.call(null, t, e, n)
                    } catch (t) {
                        G(t, null, "config.errorHandler")
                    }
                    G(t, e, n)
                }
  
                function G(t, e, n) {
                    if (!On && !In || "undefined" == typeof console) throw t;
                    console.error(t)
                }
  
                function H() {
                    di = !1;
                    var t = hi.slice(0);
                    hi.length = 0;
                    for (var e = 0; e < t.length; e++) t[e]()
                }
  
                function V(t, e) {
                    var n;
                    if (hi.push(function() {
                            if (t) try {
                                t.call(e)
                            } catch (t) {
                                B(t, e, "nextTick")
                            } else n && n(e)
                        }), di || (di = !0, pi ? li() : ci()), !t && "undefined" != typeof Promise) return new Promise(function(t) {
                        n = t
                    })
                }
  
                function W(t) {
                    (function t(e, n) {
                        var i, r, o = Array.isArray(e);
                        if ((o || a(e)) && !Object.isFrozen(e)) {
                            if (e.__ob__) {
                                var s = e.__ob__.dep.id;
                                if (n.has(s)) return;
                                n.add(s)
                            }
                            if (o)
                                for (i = e.length; i--;) t(e[i], n);
                            else
                                for (i = (r = Object.keys(e)).length; i--;) t(e[r[i]], n)
                        }
                    })(t, yi), yi.clear()
                }
  
                function X(t) {
                    function e() {
                        var t = arguments,
                            n = e.fns;
                        if (!Array.isArray(n)) return n.apply(null, arguments);
                        for (var i = n.slice(), r = 0; r < i.length; r++) i[r].apply(null, t)
                    }
                    return e.fns = t, e
                }
  
                function q(t, n, i, r, a) {
                    var o, s, c, l;
                    for (o in t) s = t[o], c = n[o], l = xi(o), e(s) || (e(c) ? (e(s.fns) && (s = t[o] = X(s)), i(l.name, s, l.once, l.capture, l.passive, l.params)) : s !== c && (c.fns = s, t[o] = c));
                    for (o in n) e(t[o]) && r((l = xi(o)).name, n[o], l.capture)
                }
  
                function Y(t, r, a) {
                    function o() {
                        a.apply(this, arguments), h(s.fns, o)
                    }
                    t instanceof Qn && (t = t.data.hook || (t.data.hook = {}));
                    var s, c = t[r];
                    e(c) ? s = X([o]) : n(c.fns) && i(c.merged) ? (s = c).fns.push(o) : s = X([c, o]), s.merged = !0, t[r] = s
                }
  
                function $(t, e, i, r, a) {
                    if (n(e)) {
                        if (d(e, i)) return t[i] = e[i], a || delete e[i], !0;
                        if (d(e, r)) return t[i] = e[r], a || delete e[r], !0
                    }
                    return !1
                }
  
                function Z(t) {
                    return n(t) && n(t.text) && !1 === t.isComment
                }
  
                function J(t, e) {
                    return (t.__esModule || Yn && "Module" === t[Symbol.toStringTag]) && (t = t.default), a(t) ? e.extend(t) : t
                }
  
                function K(t) {
                    return t.isComment && t.asyncFactory
                }
  
                function Q(t) {
                    if (Array.isArray(t))
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e];
                            if (n(i) && (n(i.componentOptions) || K(i))) return i
                        }
                }
  
                function tt(t, e, n) {
                    n ? gi.$once(t, e) : gi.$on(t, e)
                }
  
                function et(t, e) {
                    gi.$off(t, e)
                }
  
                function nt(t, e, n) {
                    gi = t, q(e, n || {}, tt, et), gi = void 0
                }
  
                function it(t, e) {
                    var n = {};
                    if (!t) return n;
                    for (var i = 0, r = t.length; i < r; i++) {
                        var a = t[i],
                            o = a.data;
                        if (o && o.attrs && o.attrs.slot && delete o.attrs.slot, a.context !== e && a.fnContext !== e || !o || null == o.slot)(n.default || (n.default = [])).push(a);
                        else {
                            var s = o.slot,
                                c = n[s] || (n[s] = []);
                            "template" === a.tag ? c.push.apply(c, a.children || []) : c.push(a)
                        }
                    }
                    for (var l in n) n[l].every(rt) && delete n[l];
                    return n
                }
  
                function rt(t) {
                    return t.isComment && !t.asyncFactory || " " === t.text
                }
  
                function at(t, e) {
                    e = e || {};
                    for (var n = 0; n < t.length; n++) Array.isArray(t[n]) ? at(t[n], e) : e[t[n].key] = t[n].fn;
                    return e
                }
  
                function ot(t) {
                    for (; t && (t = t.$parent);)
                        if (t._inactive) return !0;
                    return !1
                }
  
                function st(t, e) {
                    if (e) {
                        if (t._directInactive = !1, ot(t)) return
                    } else if (t._directInactive) return;
                    if (t._inactive || null === t._inactive) {
                        t._inactive = !1;
                        for (var n = 0; n < t.$children.length; n++) st(t.$children[n]);
                        ct(t, "activated")
                    }
                }
  
                function ct(t, e) {
                    var n = t.$options[e];
                    if (n)
                        for (var i = 0, r = n.length; i < r; i++) try {
                            n[i].call(t)
                        } catch (n) {
                            B(n, t, e + " hook")
                        }
                    t._hasHookEvent && t.$emit("hook:" + e)
                }
  
                function lt() {
                    var t, e;
                    for (Ti = !0, wi.sort(function(t, e) {
                            return t.id - e.id
                        }), Si = 0; Si < wi.length; Si++) e = (t = wi[Si]).id, Mi[e] = null, t.run();
                    var n = _i.slice(),
                        i = wi.slice();
                    Si = wi.length = _i.length = 0, Mi = {}, Ei = Ti = !1,
                        function(t) {
                            for (var e = 0; e < t.length; e++) t[e]._inactive = !0, st(t[e], !0)
                        }(n),
                        function(t) {
                            for (var e = t.length; e--;) {
                                var n = t[e],
                                    i = n.vm;
                                i._watcher === n && i._isMounted && ct(i, "updated")
                            }
                        }(i), qn && Pn.devtools && qn.emit("flush")
                }
  
                function ut(t, e, n) {
                    Pi.get = function() {
                        return this[e][n]
                    }, Pi.set = function(t) {
                        this[e][n] = t
                    }, Object.defineProperty(t, n, Pi)
                }
  
                function ht(t, e, n) {
                    var i = !Xn();
                    "function" == typeof n ? (Pi.get = i ? dt(e) : n, Pi.set = y) : (Pi.get = n.get ? i && !1 !== n.cache ? dt(e) : n.get : y, Pi.set = n.set ? n.set : y), Object.defineProperty(t, e, Pi)
                }
  
                function dt(t) {
                    return function() {
                        var e = this._computedWatchers && this._computedWatchers[t];
                        if (e) return e.dirty && e.evaluate(), Jn.target && e.depend(), e.value
                    }
                }
  
                function pt(t, e, n, i) {
                    return o(n) && (i = n, n = n.handler), "string" == typeof n && (n = t[n]), t.$watch(e, n, i)
                }
  
                function ft(t, e) {
                    if (t) {
                        for (var n = Object.create(null), i = Yn ? Reflect.ownKeys(t).filter(function(e) {
                                return Object.getOwnPropertyDescriptor(t, e).enumerable
                            }) : Object.keys(t), r = 0; r < i.length; r++) {
                            for (var a = i[r], o = t[a].from, s = e; s;) {
                                if (s._provided && o in s._provided) {
                                    n[a] = s._provided[o];
                                    break
                                }
                                s = s.$parent
                            }
                            if (!s && "default" in t[a]) {
                                var c = t[a].default;
                                n[a] = "function" == typeof c ? c.call(e) : c
                            }
                        }
                        return n
                    }
                }
  
                function mt(t, e) {
                    var i, r, o, s, c;
                    if (Array.isArray(t) || "string" == typeof t)
                        for (i = new Array(t.length), r = 0, o = t.length; r < o; r++) i[r] = e(t[r], r);
                    else if ("number" == typeof t)
                        for (i = new Array(t), r = 0; r < t; r++) i[r] = e(r + 1, r);
                    else if (a(t))
                        for (s = Object.keys(t), i = new Array(s.length), r = 0, o = s.length; r < o; r++) c = s[r], i[r] = e(t[c], c, r);
                    return n(i) && (i._isVList = !0), i
                }
  
                function vt(t, e, n, i) {
                    var r, a = this.$scopedSlots[t];
                    if (a) n = n || {}, i && (n = v(v({}, i), n)), r = a(n) || e;
                    else {
                        var o = this.$slots[t];
                        o && (o._rendered = !0), r = o || e
                    }
                    var s = n && n.slot;
                    return s ? this.$createElement("template", {
                        slot: s
                    }, r) : r
                }
  
                function gt(t) {
                    return U(this.$options, "filters", t) || Tn
                }
  
                function yt(t, e, n, i) {
                    var r = Pn.keyCodes[e] || n;
                    return r ? Array.isArray(r) ? -1 === r.indexOf(t) : r !== t : i ? Mn(i) !== e : void 0
                }
  
                function xt(t, e, n, i, r) {
                    if (n && a(n)) {
                        Array.isArray(n) && (n = g(n));
                        var o, s = function(a) {
                            if ("class" === a || "style" === a || gn(a)) o = t;
                            else {
                                var s = t.attrs && t.attrs.type;
                                o = i || Pn.mustUseProp(e, s, a) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {})
                            }
                            a in o || (o[a] = n[a], !r) || ((t.on || (t.on = {}))["update:" + a] = function(t) {
                                n[a] = t
                            })
                        };
                        for (var c in n) s(c)
                    }
                    return t
                }
  
                function bt(t, e) {
                    var n = this._staticTrees || (this._staticTrees = []),
                        i = n[t];
                    return i && !e ? Array.isArray(i) ? S(i) : T(i) : (_t(i = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, null, this), "__static__" + t, !1), i)
                }
  
                function wt(t, e, n) {
                    return _t(t, "__once__" + e + (n ? "_" + n : ""), !0), t
                }
  
                function _t(t, e, n) {
                    if (Array.isArray(t))
                        for (var i = 0; i < t.length; i++) t[i] && "string" != typeof t[i] && Mt(t[i], e + "_" + i, n);
                    else Mt(t, e, n)
                }
  
                function Mt(t, e, n) {
                    t.isStatic = !0, t.key = e, t.isOnce = n
                }
  
                function Et(t, e) {
                    if (e && o(e)) {
                        var n = t.on = t.on ? v({}, t.on) : {};
                        for (var i in e) {
                            var r = n[i],
                                a = e[i];
                            n[i] = r ? [].concat(r, a) : a
                        }
                    }
                    return t
                }
  
                function Tt(t) {
                    t._o = wt, t._n = l, t._s = c, t._l = mt, t._t = vt, t._q = x, t._i = b, t._m = bt, t._f = gt, t._k = yt, t._b = xt, t._v = E, t._e = ei, t._u = at, t._g = Et
                }
  
                function St(t, e, n, r, a) {
                    var o = a.options;
                    this.data = t, this.props = e, this.children = n, this.parent = r, this.listeners = t.on || fn, this.injections = ft(o.inject, r), this.slots = function() {
                        return it(n, r)
                    };
                    var s = Object.create(r),
                        c = i(o._compiled),
                        l = !c;
                    c && (this.$options = o, this.$slots = this.slots(), this.$scopedSlots = t.scopedSlots || fn), o._scopeId ? this._c = function(t, e, n, i) {
                        var a = Pt(s, t, e, n, i, l);
                        return a && (a.fnScopeId = o._scopeId, a.fnContext = r), a
                    } : this._c = function(t, e, n, i) {
                        return Pt(s, t, e, n, i, l)
                    }
                }
  
                function At(t, e) {
                    for (var n in e) t[bn(n)] = e[n]
                }
  
                function Lt(t, r, o, s, c) {
                    if (!e(t)) {
                        var l = o.$options._base;
                        if (a(t) && (t = l.extend(t)), "function" == typeof t) {
                            var u;
                            if (e(t.cid) && void 0 === (t = function(t, r, o) {
                                    if (i(t.error) && n(t.errorComp)) return t.errorComp;
                                    if (n(t.resolved)) return t.resolved;
                                    if (i(t.loading) && n(t.loadingComp)) return t.loadingComp;
                                    if (!n(t.contexts)) {
                                        var s = t.contexts = [o],
                                            c = !0,
                                            l = function() {
                                                for (var t = 0, e = s.length; t < e; t++) s[t].$forceUpdate()
                                            },
                                            u = w(function(e) {
                                                t.resolved = J(e, r), c || l()
                                            }),
                                            h = w(function(e) {
                                                n(t.errorComp) && (t.error = !0, l())
                                            }),
                                            d = t(u, h);
                                        return a(d) && ("function" == typeof d.then ? e(t.resolved) && d.then(u, h) : n(d.component) && "function" == typeof d.component.then && (d.component.then(u, h), n(d.error) && (t.errorComp = J(d.error, r)), n(d.loading) && (t.loadingComp = J(d.loading, r), 0 === d.delay ? t.loading = !0 : setTimeout(function() {
                                            e(t.resolved) && e(t.error) && (t.loading = !0, l())
                                        }, d.delay || 200)), n(d.timeout) && setTimeout(function() {
                                            e(t.resolved) && h(null)
                                        }, d.timeout))), c = !1, t.loading ? t.loadingComp : t.resolved
                                    }
                                    t.contexts.push(o)
                                }(u = t, l, o))) return m = u, v = r, g = o, y = s, x = c, (b = ei()).asyncFactory = m, b.asyncMeta = {
                                data: v,
                                context: g,
                                children: y,
                                tag: x
                            }, b;
                            r = r || {}, Ct(t), n(r.model) && function(t, e) {
                                var i = t.model && t.model.prop || "value",
                                    r = t.model && t.model.event || "input";
                                (e.props || (e.props = {}))[i] = e.model.value;
                                var a = e.on || (e.on = {});
                                n(a[r]) ? a[r] = [e.model.callback].concat(a[r]) : a[r] = e.model.callback
                            }(t.options, r);
                            var h = function(i, r, a) {
                                var o = t.options.props;
                                if (!e(o)) {
                                    var s = {},
                                        c = i.attrs,
                                        l = i.props;
                                    if (n(c) || n(l))
                                        for (var u in o) {
                                            var h = Mn(u);
                                            $(s, l, u, h, !0) || $(s, c, u, h, !1)
                                        }
                                    return s
                                }
                            }(r);
                            if (i(t.options.functional)) return function(t, e, i, r, a) {
                                var o = t.options,
                                    s = {},
                                    c = o.props;
                                if (n(c))
                                    for (var l in c) s[l] = k(l, c, e || fn);
                                else n(i.attrs) && At(s, i.attrs), n(i.props) && At(s, i.props);
                                var u = new St(i, s, a, r, t),
                                    h = o.render.call(null, u._c, u);
                                return h instanceof Qn && (h.fnContext = r, h.fnOptions = o, i.slot && ((h.data || (h.data = {})).slot = i.slot)), h
                            }(t, h, r, o, s);
                            var d = r.on;
                            if (r.on = r.nativeOn, i(t.options.abstract)) {
                                var p = r.slot;
                                r = {}, p && (r.slot = p)
                            }! function(t) {
                                t.hook || (t.hook = {});
                                for (var e = 0; e < zi.length; e++) {
                                    var n = zi[e],
                                        i = t.hook[n],
                                        r = Fi[n];
                                    t.hook[n] = i ? function(t, e) {
                                        return function(n, i, r, a) {
                                            t(n, i, r, a), e(n, i, r, a)
                                        }
                                    }(r, i) : r
                                }
                            }(r);
                            var f = t.options.name || c;
                            return new Qn("vue-component-" + t.cid + (f ? "-" + f : ""), r, void 0, void 0, void 0, o, {
                                Ctor: t,
                                propsData: h,
                                listeners: d,
                                tag: c,
                                children: s
                            }, u)
                        }
                    }
                    var m, v, g, y, x, b
                }
  
                function Pt(t, a, o, s, c, l) {
                    return (Array.isArray(o) || r(o)) && (c = s, s = o, o = void 0), i(l) && (c = ji),
                        function(t, a, o, s, c) {
                            if (n(o) && n(o.__ob__)) return ei();
                            if (n(o) && n(o.is) && (a = o.is), !a) return ei();
                            var l, u, h, d;
                            (Array.isArray(s) && "function" == typeof s[0] && ((o = o || {}).scopedSlots = {
                                default: s[0]
                            }, s.length = 0), c === ji ? s = r(l = s) ? [E(l)] : Array.isArray(l) ? function t(a, o) {
                                var s, c, l, u, h = [];
                                for (s = 0; s < a.length; s++) e(c = a[s]) || "boolean" == typeof c || (u = h[l = h.length - 1], Array.isArray(c) ? c.length > 0 && (Z((c = t(c, (o || "") + "_" + s))[0]) && Z(u) && (h[l] = E(u.text + c[0].text), c.shift()), h.push.apply(h, c)) : r(c) ? Z(u) ? h[l] = E(u.text + c) : "" !== c && h.push(E(c)) : Z(c) && Z(u) ? h[l] = E(u.text + c.text) : (i(a._isVList) && n(c.tag) && e(c.key) && n(o) && (c.key = "__vlist" + o + "_" + s + "__"), h.push(c)));
                                return h
                            }(l) : void 0 : c === Bi && (s = function(t) {
                                for (var e = 0; e < t.length; e++)
                                    if (Array.isArray(t[e])) return Array.prototype.concat.apply([], t);
                                return t
                            }(s)), "string" == typeof a) ? (h = t.$vnode && t.$vnode.ns || Pn.getTagNamespace(a), u = Pn.isReservedTag(a) ? new Qn(Pn.parsePlatformTagName(a), o, s, void 0, void 0, t) : n(d = U(t.$options, "components", a)) ? Lt(d, o, t, s, a) : new Qn(a, o, s, void 0, void 0, t)) : u = Lt(a, o, t, s);
                            return n(u) ? (h && function t(r, a, o) {
                                if (r.ns = a, "foreignObject" === r.tag && (a = void 0, o = !0), n(r.children))
                                    for (var s = 0, c = r.children.length; s < c; s++) {
                                        var l = r.children[s];
                                        n(l.tag) && (e(l.ns) || i(o)) && t(l, a, o)
                                    }
                            }(u, h), u) : ei()
                        }(t, a, o, s, c)
                }
  
                function Ct(t) {
                    var e = t.options;
                    if (t.super) {
                        var n = Ct(t.super);
                        if (n !== t.superOptions) {
                            t.superOptions = n;
                            var i = function(t) {
                                var e, n = t.options,
                                    i = t.extendOptions,
                                    r = t.sealedOptions;
                                for (var a in n) n[a] !== r[a] && (e || (e = {}), e[a] = function(t, e, n) {
                                    if (Array.isArray(t)) {
                                        var i = [];
                                        n = Array.isArray(n) ? n : [n], e = Array.isArray(e) ? e : [e];
                                        for (var r = 0; r < t.length; r++)(e.indexOf(t[r]) >= 0 || n.indexOf(t[r]) < 0) && i.push(t[r]);
                                        return i
                                    }
                                    return t
                                }(n[a], i[a], r[a]));
                                return e
                            }(t);
                            i && v(t.extendOptions, i), (e = t.options = D(n, t.extendOptions)).name && (e.components[e.name] = t)
                        }
                    }
                    return e
                }
  
                function Rt(t) {
                    this._init(t)
                }
  
                function Ot(t) {
                    return t && (t.Ctor.options.name || t.tag)
                }
  
                function It(t, e) {
                    return Array.isArray(t) ? t.indexOf(e) > -1 : "string" == typeof t ? t.split(",").indexOf(e) > -1 : (n = t, !("[object RegExp]" !== mn.call(n)) && t.test(e));
                    var n
                }
  
                function Nt(t, e) {
                    var n = t.cache,
                        i = t.keys,
                        r = t._vnode;
                    for (var a in n) {
                        var o = n[a];
                        if (o) {
                            var s = Ot(o.componentOptions);
                            s && !e(s) && Dt(n, a, i, r)
                        }
                    }
                }
  
                function Dt(t, e, n, i) {
                    var r = t[e];
                    !r || i && r.tag === i.tag || r.componentInstance.$destroy(), t[e] = null, h(n, e)
                }
  
                function Ut(t, e) {
                    return {
                        staticClass: kt(t.staticClass, e.staticClass),
                        class: n(t.class) ? [t.class, e.class] : e.class
                    }
                }
  
                function kt(t, e) {
                    return t ? e ? t + " " + e : t : e || ""
                }
  
                function Ft(t) {
                    return Array.isArray(t) ? function(t) {
                        for (var e, i = "", r = 0, a = t.length; r < a; r++) n(e = Ft(t[r])) && "" !== e && (i && (i += " "), i += e);
                        return i
                    }(t) : a(t) ? function(t) {
                        var e = "";
                        for (var n in t) t[n] && (e && (e += " "), e += n);
                        return e
                    }(t) : "string" == typeof t ? t : ""
                }
  
                function zt(t) {
                    return pr(t) ? "svg" : "math" === t ? "math" : void 0
                }
  
                function Bt(t) {
                    return "string" == typeof t ? document.querySelector(t) || document.createElement("div") : t
                }
  
                function jt(t, e) {
                    var n = t.data.ref;
                    if (n) {
                        var i = t.context,
                            r = t.componentInstance || t.elm,
                            a = i.$refs;
                        e ? Array.isArray(a[n]) ? h(a[n], r) : a[n] === r && (a[n] = void 0) : t.data.refInFor ? Array.isArray(a[n]) ? a[n].indexOf(r) < 0 && a[n].push(r) : a[n] = [r] : a[n] = r
                    }
                }
  
                function Gt(t, r) {
                    return t.key === r.key && (t.tag === r.tag && t.isComment === r.isComment && n(t.data) === n(r.data) && function(t, e) {
                        if ("input" !== t.tag) return !0;
                        var i, r = n(i = t.data) && n(i = i.attrs) && i.type,
                            a = n(i = e.data) && n(i = i.attrs) && i.type;
                        return r === a || vr(r) && vr(a)
                    }(t, r) || i(t.isAsyncPlaceholder) && t.asyncFactory === r.asyncFactory && e(r.asyncFactory.error))
                }
  
                function Ht(t, e, i) {
                    var r, a, o = {};
                    for (r = e; r <= i; ++r) n(a = t[r].key) && (o[a] = r);
                    return o
                }
  
                function Vt(t, e) {
                    (t.data.directives || e.data.directives) && function(t, e) {
                        var n, i, r, a = t === xr,
                            o = e === xr,
                            s = Wt(t.data.directives, t.context),
                            c = Wt(e.data.directives, e.context),
                            l = [],
                            u = [];
                        for (n in c) i = s[n], r = c[n], i ? (r.oldValue = i.value, Xt(r, "update", e, t), r.def && r.def.componentUpdated && u.push(r)) : (Xt(r, "bind", e, t), r.def && r.def.inserted && l.push(r));
                        if (l.length) {
                            var h = function() {
                                for (var n = 0; n < l.length; n++) Xt(l[n], "inserted", e, t)
                            };
                            a ? Y(e, "insert", h) : h()
                        }
                        if (u.length && Y(e, "postpatch", function() {
                                for (var n = 0; n < u.length; n++) Xt(u[n], "componentUpdated", e, t)
                            }), !a)
                            for (n in s) c[n] || Xt(s[n], "unbind", t, t, o)
                    }(t, e)
                }
  
                function Wt(t, e) {
                    var n, i, r, a = Object.create(null);
                    if (!t) return a;
                    for (n = 0; n < t.length; n++)(i = t[n]).modifiers || (i.modifiers = _r), a[(r = i, r.rawName || r.name + "." + Object.keys(r.modifiers || {}).join("."))] = i, i.def = U(e.$options, "directives", i.name);
                    return a
                }
  
                function Xt(t, e, n, i, r) {
                    var a = t.def && t.def[e];
                    if (a) try {
                        a(n.elm, t, n, i, r)
                    } catch (i) {
                        B(i, n.context, "directive " + t.name + " " + e + " hook")
                    }
                }
  
                function qt(t, i) {
                    var r = i.componentOptions;
                    if (!(n(r) && !1 === r.Ctor.options.inheritAttrs || e(t.data.attrs) && e(i.data.attrs))) {
                        var a, o, s = i.elm,
                            c = t.data.attrs || {},
                            l = i.data.attrs || {};
                        for (a in n(l.__ob__) && (l = i.data.attrs = v({}, l)), l) o = l[a], c[a] !== o && Yt(s, a, o);
                        for (a in (Un || Fn) && l.value !== c.value && Yt(s, "value", l.value), c) e(l[a]) && (cr(a) ? s.removeAttributeNS(sr, lr(a)) : ar(a) || s.removeAttribute(a))
                    }
                }
  
                function Yt(t, e, n) {
                    if (or(e)) ur(n) ? t.removeAttribute(e) : (n = "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e, t.setAttribute(e, n));
                    else if (ar(e)) t.setAttribute(e, ur(n) || "false" === n ? "false" : "true");
                    else if (cr(e)) ur(n) ? t.removeAttributeNS(sr, lr(e)) : t.setAttributeNS(sr, e, n);
                    else if (ur(n)) t.removeAttribute(e);
                    else {
                        if (Un && !kn && "TEXTAREA" === t.tagName && "placeholder" === e && !t.__ieph) {
                            var i = function(e) {
                                e.stopImmediatePropagation(), t.removeEventListener("input", i)
                            };
                            t.addEventListener("input", i), t.__ieph = !0
                        }
                        t.setAttribute(e, n)
                    }
                }
  
                function $t(t, i) {
                    var r = i.elm,
                        a = i.data,
                        o = t.data;
                    if (!(e(a.staticClass) && e(a.class) && (e(o) || e(o.staticClass) && e(o.class)))) {
                        var s = function(t) {
                                for (var e = t.data, i = t, r = t; n(r.componentInstance);)(r = r.componentInstance._vnode) && r.data && (e = Ut(r.data, e));
                                for (; n(i = i.parent);) i && i.data && (e = Ut(e, i.data));
                                return a = e.staticClass, o = e.class, n(a) || n(o) ? kt(a, Ft(o)) : "";
                                var a, o
                            }(i),
                            c = r._transitionClasses;
                        n(c) && (s = kt(s, Ft(c))), s !== r._prevClass && (r.setAttribute("class", s), r._prevClass = s)
                    }
                }
  
                function Zt(t) {
                    function e() {
                        (o || (o = [])).push(t.slice(g, r).trim()), g = r + 1
                    }
                    var n, i, r, a, o, s, c, l, u = !1,
                        h = !1,
                        d = !1,
                        p = !1,
                        f = 0,
                        m = 0,
                        v = 0,
                        g = 0;
                    for (r = 0; r < t.length; r++)
                        if (i = n, n = t.charCodeAt(r), u) 39 === n && 92 !== i && (u = !1);
                        else if (h) 34 === n && 92 !== i && (h = !1);
                    else if (d) 96 === n && 92 !== i && (d = !1);
                    else if (p) 47 === n && 92 !== i && (p = !1);
                    else if (124 !== n || 124 === t.charCodeAt(r + 1) || 124 === t.charCodeAt(r - 1) || f || m || v) {
                        switch (n) {
                            case 34:
                                h = !0;
                                break;
                            case 39:
                                u = !0;
                                break;
                            case 96:
                                d = !0;
                                break;
                            case 40:
                                v++;
                                break;
                            case 41:
                                v--;
                                break;
                            case 91:
                                m++;
                                break;
                            case 93:
                                m--;
                                break;
                            case 123:
                                f++;
                                break;
                            case 125:
                                f--
                        }
                        if (47 === n) {
                            for (var y = r - 1, x = void 0; y >= 0 && " " === (x = t.charAt(y)); y--);
                            x && Sr.test(x) || (p = !0)
                        }
                    } else void 0 === a ? (g = r + 1, a = t.slice(0, r).trim()) : e();
                    if (void 0 === a ? a = t.slice(0, r).trim() : 0 !== g && e(), o)
                        for (r = 0; r < o.length; r++) s = a, c = o[r], void 0, a = (l = c.indexOf("(")) < 0 ? '_f("' + c + '")(' + s + ")" : '_f("' + c.slice(0, l) + '")(' + s + "," + c.slice(l + 1);
                    return a
                }
  
                function Jt(t) {
                    console.error("[Vue compiler]: " + t)
                }
  
                function Kt(t, e) {
                    return t ? t.map(function(t) {
                        return t[e]
                    }).filter(function(t) {
                        return t
                    }) : []
                }
  
                function Qt(t, e, n) {
                    (t.props || (t.props = [])).push({
                        name: e,
                        value: n
                    }), t.plain = !1
                }
  
                function te(t, e, n) {
                    (t.attrs || (t.attrs = [])).push({
                        name: e,
                        value: n
                    }), t.plain = !1
                }
  
                function ee(t, e, n) {
                    t.attrsMap[e] = n, t.attrsList.push({
                        name: e,
                        value: n
                    })
                }
  
                function ne(t, e, n, i, r, a) {
                    var o;
                    (i = i || fn).capture && (delete i.capture, e = "!" + e), i.once && (delete i.once, e = "~" + e), i.passive && (delete i.passive, e = "&" + e), "click" === e && (i.right ? (e = "contextmenu", delete i.right) : i.middle && (e = "mouseup")), i.native ? (delete i.native, o = t.nativeEvents || (t.nativeEvents = {})) : o = t.events || (t.events = {});
                    var s = {
                        value: n
                    };
                    i !== fn && (s.modifiers = i);
                    var c = o[e];
                    Array.isArray(c) ? r ? c.unshift(s) : c.push(s) : o[e] = c ? r ? [s, c] : [c, s] : s, t.plain = !1
                }
  
                function ie(t, e, n) {
                    var i = re(t, ":" + e) || re(t, "v-bind:" + e);
                    if (null != i) return Zt(i);
                    if (!1 !== n) {
                        var r = re(t, e);
                        if (null != r) return JSON.stringify(r)
                    }
                }
  
                function re(t, e, n) {
                    var i;
                    if (null != (i = t.attrsMap[e]))
                        for (var r = t.attrsList, a = 0, o = r.length; a < o; a++)
                            if (r[a].name === e) {
                                r.splice(a, 1);
                                break
                            }
                    return n && delete t.attrsMap[e], i
                }
  
                function ae(t, e, n) {
                    var i = n || {},
                        r = "$$v";
                    i.trim && (r = "(typeof $$v === 'string'? $$v.trim(): $$v)"), i.number && (r = "_n(" + r + ")");
                    var a = oe(e, r);
                    t.model = {
                        value: "(" + e + ")",
                        expression: '"' + e + '"',
                        callback: "function ($$v) {" + a + "}"
                    }
                }
  
                function oe(t, e) {
                    var n = function(t) {
                        if (Yi = t.length, t.indexOf("[") < 0 || t.lastIndexOf("]") < Yi - 1) return (Ji = t.lastIndexOf(".")) > -1 ? {
                            exp: t.slice(0, Ji),
                            key: '"' + t.slice(Ji + 1) + '"'
                        } : {
                            exp: t,
                            key: null
                        };
                        for ($i = t, Ji = Ki = Qi = 0; !ce();) le(Zi = se()) ? ue(Zi) : 91 === Zi && function(t) {
                            var e = 1;
                            for (Ki = Ji; !ce();)
                                if (le(t = se())) ue(t);
                                else if (91 === t && e++, 93 === t && e--, 0 === e) {
                                Qi = Ji;
                                break
                            }
                        }(Zi);
                        return {
                            exp: t.slice(0, Ki),
                            key: t.slice(Ki + 1, Qi)
                        }
                    }(t);
                    return null === n.key ? t + "=" + e : "$set(" + n.exp + ", " + n.key + ", " + e + ")"
                }
  
                function se() {
                    return $i.charCodeAt(++Ji)
                }
  
                function ce() {
                    return Ji >= Yi
                }
  
                function le(t) {
                    return 34 === t || 39 === t
                }
  
                function ue(t) {
                    for (var e = t; !ce() && (t = se()) !== e;);
                }
  
                function he(t, e, n, i, r) {
                    var a, o, s, c, l;
                    e = (l = e)._withTask || (l._withTask = function() {
                        pi = !0;
                        var t = l.apply(null, arguments);
                        return pi = !1, t
                    }), n && (a = e, o = t, s = i, c = tr, e = function t() {
                        null !== a.apply(null, arguments) && de(o, t, s, c)
                    }), tr.addEventListener(t, e, Gn ? {
                        capture: i,
                        passive: r
                    } : i)
                }
  
                function de(t, e, n, i) {
                    (i || tr).removeEventListener(t, e._withTask || e, n)
                }
  
                function pe(t, i) {
                    if (!e(t.data.on) || !e(i.data.on)) {
                        var r = i.data.on || {},
                            a = t.data.on || {};
                        tr = i.elm,
                            function(t) {
                                if (n(t[Ar])) {
                                    var e = Un ? "change" : "input";
                                    t[e] = [].concat(t[Ar], t[e] || []), delete t[Ar]
                                }
                                n(t[Lr]) && (t.change = [].concat(t[Lr], t.change || []), delete t[Lr])
                            }(r), q(r, a, he, de, i.context), tr = void 0
                    }
                }
  
                function fe(t, i) {
                    if (!e(t.data.domProps) || !e(i.data.domProps)) {
                        var r, a, o = i.elm,
                            s = t.data.domProps || {},
                            c = i.data.domProps || {};
                        for (r in n(c.__ob__) && (c = i.data.domProps = v({}, c)), s) e(c[r]) && (o[r] = "");
                        for (r in c) {
                            if (a = c[r], "textContent" === r || "innerHTML" === r) {
                                if (i.children && (i.children.length = 0), a === s[r]) continue;
                                1 === o.childNodes.length && o.removeChild(o.childNodes[0])
                            }
                            if ("value" === r) {
                                o._value = a;
                                var u = e(a) ? "" : String(a);
                                d = u, !(h = o).composing && ("OPTION" === h.tagName || function(t, e) {
                                    var n = !0;
                                    try {
                                        n = document.activeElement !== t
                                    } catch (t) {}
                                    return n && t.value !== e
                                }(h, d) || function(t, e) {
                                    var i = t.value,
                                        r = t._vModifiers;
                                    if (n(r)) {
                                        if (r.lazy) return !1;
                                        if (r.number) return l(i) !== l(e);
                                        if (r.trim) return i.trim() !== e.trim()
                                    }
                                    return i !== e
                                }(h, d)) && (o.value = u)
                            } else o[r] = a
                        }
                    }
                    var h, d
                }
  
                function me(t) {
                    var e = ve(t.style);
                    return t.staticStyle ? v(t.staticStyle, e) : e
                }
  
                function ve(t) {
                    return Array.isArray(t) ? g(t) : "string" == typeof t ? Rr(t) : t
                }
  
                function ge(t, i) {
                    var r = i.data,
                        a = t.data;
                    if (!(e(r.staticStyle) && e(r.style) && e(a.staticStyle) && e(a.style))) {
                        var o, s, c = i.elm,
                            l = a.staticStyle,
                            u = a.normalizedStyle || a.style || {},
                            h = l || u,
                            d = ve(i.data.style) || {};
                        i.data.normalizedStyle = n(d.__ob__) ? v({}, d) : d;
                        var p = function(t, e) {
                            for (var n, i = {}, r = t; r.componentInstance;)(r = r.componentInstance._vnode) && r.data && (n = me(r.data)) && v(i, n);
                            (n = me(t.data)) && v(i, n);
                            for (var a = t; a = a.parent;) a.data && (n = me(a.data)) && v(i, n);
                            return i
                        }(i);
                        for (s in h) e(p[s]) && Nr(c, s, "");
                        for (s in p)(o = p[s]) !== h[s] && Nr(c, s, null == o ? "" : o)
                    }
                }
  
                function ye(t, e) {
                    if (e && (e = e.trim()))
                        if (t.classList) e.indexOf(" ") > -1 ? e.split(/\s+/).forEach(function(e) {
                            return t.classList.add(e)
                        }) : t.classList.add(e);
                        else {
                            var n = " " + (t.getAttribute("class") || "") + " ";
                            n.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (n + e).trim())
                        }
                }
  
                function xe(t, e) {
                    if (e && (e = e.trim()))
                        if (t.classList) e.indexOf(" ") > -1 ? e.split(/\s+/).forEach(function(e) {
                            return t.classList.remove(e)
                        }) : t.classList.remove(e), t.classList.length || t.removeAttribute("class");
                        else {
                            for (var n = " " + (t.getAttribute("class") || "") + " ", i = " " + e + " "; n.indexOf(i) >= 0;) n = n.replace(i, " ");
                            (n = n.trim()) ? t.setAttribute("class", n): t.removeAttribute("class")
                        }
                }
  
                function be(t) {
                    if (t) {
                        if ("object" == typeof t) {
                            var e = {};
                            return !1 !== t.css && v(e, Fr(t.name || "v")), v(e, t), e
                        }
                        return "string" == typeof t ? Fr(t) : void 0
                    }
                }
  
                function we(t) {
                    Xr(function() {
                        Xr(t)
                    })
                }
  
                function _e(t, e) {
                    var n = t._transitionClasses || (t._transitionClasses = []);
                    n.indexOf(e) < 0 && (n.push(e), ye(t, e))
                }
  
                function Me(t, e) {
                    t._transitionClasses && h(t._transitionClasses, e), xe(t, e)
                }
  
                function Ee(t, e, n) {
                    var i = Te(t, e),
                        r = i.type,
                        a = i.timeout,
                        o = i.propCount;
                    if (!r) return n();
                    var s = r === Br ? Hr : Wr,
                        c = 0,
                        l = function() {
                            t.removeEventListener(s, u), n()
                        },
                        u = function(e) {
                            e.target === t && ++c >= o && l()
                        };
                    setTimeout(function() {
                        c < o && l()
                    }, a + 1), t.addEventListener(s, u)
                }
  
                function Te(t, e) {
                    var n, i = window.getComputedStyle(t),
                        r = i[Gr + "Delay"].split(", "),
                        a = i[Gr + "Duration"].split(", "),
                        o = Se(r, a),
                        s = i[Vr + "Delay"].split(", "),
                        c = i[Vr + "Duration"].split(", "),
                        l = Se(s, c),
                        u = 0,
                        h = 0;
                    return e === Br ? o > 0 && (n = Br, u = o, h = a.length) : e === jr ? l > 0 && (n = jr, u = l, h = c.length) : h = (n = (u = Math.max(o, l)) > 0 ? o > l ? Br : jr : null) ? n === Br ? a.length : c.length : 0, {
                        type: n,
                        timeout: u,
                        propCount: h,
                        hasTransform: n === Br && qr.test(i[Gr + "Property"])
                    }
                }
  
                function Se(t, e) {
                    for (; t.length < e.length;) t = t.concat(t);
                    return Math.max.apply(null, e.map(function(e, n) {
                        return Ae(e) + Ae(t[n])
                    }))
                }
  
                function Ae(t) {
                    return 1e3 * Number(t.slice(0, -1))
                }
  
                function Le(t, i) {
                    var r = t.elm;
                    n(r._leaveCb) && (r._leaveCb.cancelled = !0, r._leaveCb());
                    var o = be(t.data.transition);
                    if (!e(o) && !n(r._enterCb) && 1 === r.nodeType) {
                        for (var s = o.css, c = o.type, u = o.enterClass, h = o.enterToClass, d = o.enterActiveClass, p = o.appearClass, f = o.appearToClass, m = o.appearActiveClass, v = o.beforeEnter, g = o.enter, y = o.afterEnter, x = o.enterCancelled, b = o.beforeAppear, _ = o.appear, M = o.afterAppear, E = o.appearCancelled, T = o.duration, S = bi, A = bi.$vnode; A && A.parent;) S = (A = A.parent).context;
                        var L = !S._isMounted || !t.isRootInsert;
                        if (!L || _ || "" === _) {
                            var P = L && p ? p : u,
                                C = L && m ? m : d,
                                R = L && f ? f : h,
                                O = L && b || v,
                                I = L && "function" == typeof _ ? _ : g,
                                N = L && M || y,
                                D = L && E || x,
                                U = l(a(T) ? T.enter : T),
                                k = !1 !== s && !kn,
                                F = Re(I),
                                z = r._enterCb = w(function() {
                                    k && (Me(r, R), Me(r, C)), z.cancelled ? (k && Me(r, P), D && D(r)) : N && N(r), r._enterCb = null
                                });
                            t.data.show || Y(t, "insert", function() {
                                var e = r.parentNode,
                                    n = e && e._pending && e._pending[t.key];
                                n && n.tag === t.tag && n.elm._leaveCb && n.elm._leaveCb(), I && I(r, z)
                            }), O && O(r), k && (_e(r, P), _e(r, C), we(function() {
                                _e(r, R), Me(r, P), z.cancelled || F || (Ce(U) ? setTimeout(z, U) : Ee(r, c, z))
                            })), t.data.show && (i && i(), I && I(r, z)), k || F || z()
                        }
                    }
                }
  
                function Pe(t, i) {
                    function r() {
                        E.cancelled || (t.data.show || ((o.parentNode._pending || (o.parentNode._pending = {}))[t.key] = t), f && f(o), b && (_e(o, h), _e(o, p), we(function() {
                            _e(o, d), Me(o, h), E.cancelled || _ || (Ce(M) ? setTimeout(E, M) : Ee(o, u, E))
                        })), m && m(o, E), b || _ || E())
                    }
                    var o = t.elm;
                    n(o._enterCb) && (o._enterCb.cancelled = !0, o._enterCb());
                    var s = be(t.data.transition);
                    if (e(s) || 1 !== o.nodeType) return i();
                    if (!n(o._leaveCb)) {
                        var c = s.css,
                            u = s.type,
                            h = s.leaveClass,
                            d = s.leaveToClass,
                            p = s.leaveActiveClass,
                            f = s.beforeLeave,
                            m = s.leave,
                            v = s.afterLeave,
                            g = s.leaveCancelled,
                            y = s.delayLeave,
                            x = s.duration,
                            b = !1 !== c && !kn,
                            _ = Re(m),
                            M = l(a(x) ? x.leave : x),
                            E = o._leaveCb = w(function() {
                                o.parentNode && o.parentNode._pending && (o.parentNode._pending[t.key] = null), b && (Me(o, d), Me(o, p)), E.cancelled ? (b && Me(o, h), g && g(o)) : (i(), v && v(o)), o._leaveCb = null
                            });
                        y ? y(r) : r()
                    }
                }
  
                function Ce(t) {
                    return "number" == typeof t && !isNaN(t)
                }
  
                function Re(t) {
                    if (e(t)) return !1;
                    var i = t.fns;
                    return n(i) ? Re(Array.isArray(i) ? i[0] : i) : (t._length || t.length) > 1
                }
  
                function Oe(t, e) {
                    !0 !== e.data.show && Le(e)
                }
  
                function Ie(t, e, n) {
                    Ne(t, e, n), (Un || Fn) && setTimeout(function() {
                        Ne(t, e, n)
                    }, 0)
                }
  
                function Ne(t, e, n) {
                    var i = e.value,
                        r = t.multiple;
                    if (!r || Array.isArray(i)) {
                        for (var a, o, s = 0, c = t.options.length; s < c; s++)
                            if (o = t.options[s], r) a = b(i, Ue(o)) > -1, o.selected !== a && (o.selected = a);
                            else if (x(Ue(o), i)) return void(t.selectedIndex !== s && (t.selectedIndex = s));
                        r || (t.selectedIndex = -1)
                    }
                }
  
                function De(t, e) {
                    return e.every(function(e) {
                        return !x(e, t)
                    })
                }
  
                function Ue(t) {
                    return "_value" in t ? t._value : t.value
                }
  
                function ke(t) {
                    t.target.composing = !0
                }
  
                function Fe(t) {
                    t.target.composing && (t.target.composing = !1, ze(t.target, "input"))
                }
  
                function ze(t, e) {
                    var n = document.createEvent("HTMLEvents");
                    n.initEvent(e, !0, !0), t.dispatchEvent(n)
                }
  
                function Be(t) {
                    return !t.componentInstance || t.data && t.data.transition ? t : Be(t.componentInstance._vnode)
                }
  
                function je(t) {
                    var e = t && t.componentOptions;
                    return e && e.Ctor.options.abstract ? je(Q(e.children)) : t
                }
  
                function Ge(t) {
                    var e = {},
                        n = t.$options;
                    for (var i in n.propsData) e[i] = t[i];
                    var r = n._parentListeners;
                    for (var a in r) e[bn(a)] = r[a];
                    return e
                }
  
                function He(t, e) {
                    if (/\d-keep-alive$/.test(e.tag)) return t("keep-alive", {
                        props: e.componentOptions.propsData
                    })
                }
  
                function Ve(t) {
                    t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb()
                }
  
                function We(t) {
                    t.data.newPos = t.elm.getBoundingClientRect()
                }
  
                function Xe(t) {
                    var e = t.data.pos,
                        n = t.data.newPos,
                        i = e.left - n.left,
                        r = e.top - n.top;
                    if (i || r) {
                        t.data.moved = !0;
                        var a = t.elm.style;
                        a.transform = a.WebkitTransform = "translate(" + i + "px," + r + "px)", a.transitionDuration = "0s"
                    }
                }
  
                function qe(t, e, n) {
                    return {
                        type: 1,
                        tag: t,
                        attrsList: e,
                        attrsMap: function(t) {
                            for (var e = {}, n = 0, i = t.length; n < i; n++) e[t[n].name] = t[n].value;
                            return e
                        }(e),
                        parent: n,
                        children: []
                    }
                }
  
                function Ye(t, e) {
                    var n, i, r, a, o, s;
                    (s = ie(o = t, "key")) && (o.key = s), t.plain = !t.key && !t.attrsList.length, (a = ie(r = t, "ref")) && (r.ref = a, r.refInFor = function(t) {
                            for (var e = r; e;) {
                                if (void 0 !== e.for) return !0;
                                e = e.parent
                            }
                            return !1
                        }()),
                        function(t) {
                            if ("slot" === t.tag) t.slotName = ie(t, "name");
                            else {
                                var e;
                                "template" === t.tag ? (e = re(t, "scope"), t.slotScope = e || re(t, "slot-scope")) : (e = re(t, "slot-scope")) && (t.slotScope = e);
                                var n = ie(t, "slot");
                                n && (t.slotTarget = '""' === n ? '"default"' : n, "template" === t.tag || t.slotScope || te(t, "slot", n))
                            }
                        }(t), (i = ie(n = t, "is")) && (n.component = i), null != re(n, "inline-template") && (n.inlineTemplate = !0);
                    for (var c = 0; c < _a.length; c++) t = _a[c](t, e) || t;
                    ! function(t) {
                        var e, n, i, r, a, o, s, c, l, u, h, d, p, f = t.attrsList;
                        for (e = 0, n = f.length; e < n; e++)
                            if (i = r = f[e].name, a = f[e].value, Ba.test(i))
                                if (t.hasBindings = !0, (o = function(t) {
                                        var e = i.match(Xa);
                                        if (e) {
                                            var n = {};
                                            return e.forEach(function(t) {
                                                n[t.slice(1)] = !0
                                            }), n
                                        }
                                    }()) && (i = i.replace(Xa, "")), Wa.test(i)) i = i.replace(Wa, ""), a = Zt(a), s = !1, o && (o.prop && (s = !0, "innerHtml" === (i = bn(i)) && (i = "innerHTML")), o.camel && (i = bn(i)), o.sync && ne(t, "update:" + bn(i), oe(a, "$event"))), s || !t.component && Sa(t.tag, t.attrsMap.type, i) ? Qt(t, i, a) : te(t, i, a);
                                else if (za.test(i)) ne(t, i = i.replace(za, ""), a, o, !1);
                        else {
                            var m = (i = i.replace(Ba, "")).match(Va),
                                v = m && m[1];
                            v && (i = i.slice(0, -(v.length + 1))), l = i, u = r, h = a, d = v, p = o, ((c = t).directives || (c.directives = [])).push({
                                name: l,
                                rawName: u,
                                value: h,
                                arg: d,
                                modifiers: p
                            }), c.plain = !1
                        } else te(t, i, JSON.stringify(a)), !t.component && "muted" === i && Sa(t.tag, t.attrsMap.type, i) && Qt(t, i, "true")
                    }(t)
                }
  
                function $e(t) {
                    var e;
                    if (e = re(t, "v-for")) {
                        var n = function(t) {
                            var n = e.match(ja);
                            if (n) {
                                var i = {};
                                i.for = n[2].trim();
                                var r = n[1].trim().replace(Ha, ""),
                                    a = r.match(Ga);
                                return a ? (i.alias = r.replace(Ga, ""), i.iterator1 = a[1].trim(), a[2] && (i.iterator2 = a[2].trim())) : i.alias = r, i
                            }
                        }();
                        n && v(t, n)
                    }
                }
  
                function Ze(t, e) {
                    t.ifConditions || (t.ifConditions = []), t.ifConditions.push(e)
                }
  
                function Je(t) {
                    return qe(t.tag, t.attrsList.slice(), t.parent)
                }
  
                function Ke(t, e, n) {
                    var i = e ? "nativeOn:{" : "on:{";
                    for (var r in t) i += '"' + r + '":' + Qe(r, t[r]) + ",";
                    return i.slice(0, -1) + "}"
                }
  
                function Qe(t, e) {
                    if (!e) return "function(){}";
                    if (Array.isArray(e)) return "[" + e.map(function(e) {
                        return Qe(t, e)
                    }).join(",") + "]";
                    var n = to.test(e.value),
                        i = Qa.test(e.value);
                    if (e.modifiers) {
                        var r = "",
                            a = "",
                            o = [];
                        for (var s in e.modifiers)
                            if (io[s]) a += io[s], eo[s] && o.push(s);
                            else if ("exact" === s) {
                            var c = e.modifiers;
                            a += no(["ctrl", "shift", "alt", "meta"].filter(function(t) {
                                return !c[t]
                            }).map(function(t) {
                                return "$event." + t + "Key"
                            }).join("||"))
                        } else o.push(s);
                        return o.length && (r += "if(!('button' in $event)&&" + o.map(tn).join("&&") + ")return null;"), a && (r += a), "function($event){" + r + (n ? e.value + "($event)" : i ? "(" + e.value + ")($event)" : e.value) + "}"
                    }
                    return n || i ? e.value : "function($event){" + e.value + "}"
                }
  
                function tn(t) {
                    var e = parseInt(t, 10);
                    if (e) return "$event.keyCode!==" + e;
                    var n = eo[t];
                    return "_k($event.keyCode," + JSON.stringify(t) + "," + JSON.stringify(n) + ",$event.key)"
                }
  
                function en(t, e) {
                    var n = new ao(e);
                    return {
                        render: "with(this){return " + (t ? nn(t, n) : '_c("div")') + "}",
                        staticRenderFns: n.staticRenderFns
                    }
                }
  
                function nn(t, e) {
                    if (t.staticRoot && !t.staticProcessed) return rn(t, e);
                    if (t.once && !t.onceProcessed) return an(t, e);
                    if (t.for && !t.forProcessed) return i = e, r = (n = t).for, a = n.alias, o = n.iterator1 ? "," + n.iterator1 : "", s = n.iterator2 ? "," + n.iterator2 : "", n.forProcessed = !0, "_l((" + r + "),function(" + a + o + s + "){return " + nn(n, i) + "})";
                    var n, i, r, a, o, s, c, l, u, h, d, p, f, m, v, g, y;
                    if (t.if && !t.ifProcessed) return on(t, e);
                    if ("template" !== t.tag || t.slotTarget) {
                        if ("slot" === t.tag) return p = e, f = (d = t).slotName || '"default"', m = cn(d, p), v = "_t(" + f + (m ? "," + m : ""), g = d.attrs && "{" + d.attrs.map(function(t) {
                            return bn(t.name) + ":" + t.value
                        }).join(",") + "}", y = d.attrsMap["v-bind"], !g && !y || m || (v += ",null"), g && (v += "," + g), y && (v += (g ? "" : ",null") + "," + y), v + ")";
                        var x;
                        if (t.component) c = t.component, u = e, h = (l = t).inlineTemplate ? null : cn(l, u, !0), x = "_c(" + c + "," + sn(l, u) + (h ? "," + h : "") + ")";
                        else {
                            var b = t.plain ? void 0 : sn(t, e),
                                w = t.inlineTemplate ? null : cn(t, e, !0);
                            x = "_c('" + t.tag + "'" + (b ? "," + b : "") + (w ? "," + w : "") + ")"
                        }
                        for (var _ = 0; _ < e.transforms.length; _++) x = e.transforms[_](t, x);
                        return x
                    }
                    return cn(t, e) || "void 0"
                }
  
                function rn(t, e) {
                    return t.staticProcessed = !0, e.staticRenderFns.push("with(this){return " + nn(t, e) + "}"), "_m(" + (e.staticRenderFns.length - 1) + (t.staticInFor ? ",true" : "") + ")"
                }
  
                function an(t, e) {
                    if (t.onceProcessed = !0, t.if && !t.ifProcessed) return on(t, e);
                    if (t.staticInFor) {
                        for (var n = "", i = t.parent; i;) {
                            if (i.for) {
                                n = i.key;
                                break
                            }
                            i = i.parent
                        }
                        return n ? "_o(" + nn(t, e) + "," + e.onceId++ + "," + n + ")" : nn(t, e)
                    }
                    return rn(t, e)
                }
  
                function on(t, e, n, i) {
                    return t.ifProcessed = !0,
                        function t(e, n, i, r) {
                            function a(t) {
                                return i ? i(t, n) : t.once ? an(t, n) : nn(t, n)
                            }
                            if (!e.length) return r || "_e()";
                            var o = e.shift();
                            return o.exp ? "(" + o.exp + ")?" + a(o.block) + ":" + t(e, n, i, r) : "" + a(o.block)
                        }(t.ifConditions.slice(), e, n, i)
                }
  
                function sn(t, e) {
                    var n, i, r = "{",
                        a = function(t, e) {
                            var n = t.directives;
                            if (n) {
                                var i, r, a, o, s = "directives:[",
                                    c = !1;
                                for (i = 0, r = n.length; i < r; i++) {
                                    a = n[i], o = !0;
                                    var l = e.directives[a.name];
                                    l && (o = !!l(t, a, e.warn)), o && (c = !0, s += '{name:"' + a.name + '",rawName:"' + a.rawName + '"' + (a.value ? ",value:(" + a.value + "),expression:" + JSON.stringify(a.value) : "") + (a.arg ? ',arg:"' + a.arg + '"' : "") + (a.modifiers ? ",modifiers:" + JSON.stringify(a.modifiers) : "") + "},")
                                }
                                return c ? s.slice(0, -1) + "]" : void 0
                            }
                        }(t, e);
                    a && (r += a + ","), t.key && (r += "key:" + t.key + ","), t.ref && (r += "ref:" + t.ref + ","), t.refInFor && (r += "refInFor:true,"), t.pre && (r += "pre:true,"), t.component && (r += 'tag:"' + t.tag + '",');
                    for (var o = 0; o < e.dataGenFns.length; o++) r += e.dataGenFns[o](t);
                    if (t.attrs && (r += "attrs:{" + un(t.attrs) + "},"), t.props && (r += "domProps:{" + un(t.props) + "},"), t.events && (r += Ke(t.events, !1, e.warn) + ","), t.nativeEvents && (r += Ke(t.nativeEvents, !0, e.warn) + ","), t.slotTarget && !t.slotScope && (r += "slot:" + t.slotTarget + ","), t.scopedSlots && (r += (n = t.scopedSlots, i = e, "scopedSlots:_u([" + Object.keys(n).map(function(t) {
                            return function t(e, n, i) {
                                return n.for && !n.forProcessed ? (r = e, o = i, s = (a = n).for, c = a.alias, l = a.iterator1 ? "," + a.iterator1 : "", u = a.iterator2 ? "," + a.iterator2 : "", a.forProcessed = !0, "_l((" + s + "),function(" + c + l + u + "){return " + t(r, a, o) + "})") : "{key:" + e + ",fn:function(" + String(n.slotScope) + "){return " + ("template" === n.tag ? n.if ? n.if+"?" + (cn(n, i) || "undefined") + ":undefined" : cn(n, i) || "undefined" : nn(n, i)) + "}}";
                                var r, a, o, s, c, l, u
                            }(t, n[t], i)
                        }).join(",") + "]),")), t.model && (r += "model:{value:" + t.model.value + ",callback:" + t.model.callback + ",expression:" + t.model.expression + "},"), t.inlineTemplate) {
                        var s = function(e, n) {
                            var i = t.children[0];
                            if (1 === i.type) {
                                var r = en(i, n.options);
                                return "inlineTemplate:{render:function(){" + r.render + "},staticRenderFns:[" + r.staticRenderFns.map(function(t) {
                                    return "function(){" + t + "}"
                                }).join(",") + "]}"
                            }
                        }(0, e);
                        s && (r += s + ",")
                    }
                    return r = r.replace(/,$/, "") + "}", t.wrapData && (r = t.wrapData(r)), t.wrapListeners && (r = t.wrapListeners(r)), r
                }
  
                function cn(t, e, n, i, r) {
                    var a = t.children;
                    if (a.length) {
                        var o = a[0];
                        if (1 === a.length && o.for && "template" !== o.tag && "slot" !== o.tag) return (i || nn)(o, e);
                        var s = n ? function(t, e) {
                                for (var n = 0, i = 0; i < t.length; i++) {
                                    var r = t[i];
                                    if (1 === r.type) {
                                        if (ln(r) || r.ifConditions && r.ifConditions.some(function(t) {
                                                return ln(t.block)
                                            })) {
                                            n = 2;
                                            break
                                        }(e(r) || r.ifConditions && r.ifConditions.some(function(t) {
                                            return e(t.block)
                                        })) && (n = 1)
                                    }
                                }
                                return n
                            }(a, e.maybeComponent) : 0,
                            c = r || function(t, e) {
                                return 1 === t.type ? nn(t, e) : 3 === t.type && t.isComment ? (i = t, "_e(" + JSON.stringify(i.text) + ")") : "_v(" + (2 === (n = t).type ? n.expression : hn(JSON.stringify(n.text))) + ")";
                                var n, i
                            };
                        return "[" + a.map(function(t) {
                            return c(t, e)
                        }).join(",") + "]" + (s ? "," + s : "")
                    }
                }
  
                function ln(t) {
                    return void 0 !== t.for || "template" === t.tag || "slot" === t.tag
                }
  
                function un(t) {
                    for (var e = "", n = 0; n < t.length; n++) {
                        var i = t[n];
                        e += '"' + i.name + '":' + hn(i.value) + ","
                    }
                    return e.slice(0, -1)
                }
  
                function hn(t) {
                    return t.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")
                }
  
                function dn(t, e) {
                    try {
                        return new Function(t)
                    } catch (n) {
                        return e.push({
                            err: n,
                            code: t
                        }), y
                    }
                }
  
                function pn(t) {
                    return (Ca = Ca || document.createElement("div")).innerHTML = t ? '<a href="\n"/>' : '<div a="\n"/>', Ca.innerHTML.indexOf("&#10;") > 0
                }
                var fn = Object.freeze({}),
                    mn = Object.prototype.toString,
                    vn = u("slot,component", !0),
                    gn = u("key,ref,slot,slot-scope,is"),
                    yn = Object.prototype.hasOwnProperty,
                    xn = /-(\w)/g,
                    bn = p(function(t) {
                        return t.replace(xn, function(t, e) {
                            return e ? e.toUpperCase() : ""
                        })
                    }),
                    wn = p(function(t) {
                        return t.charAt(0).toUpperCase() + t.slice(1)
                    }),
                    _n = /\B([A-Z])/g,
                    Mn = p(function(t) {
                        return t.replace(_n, "-$1").toLowerCase()
                    }),
                    En = function(t, e, n) {
                        return !1
                    },
                    Tn = function(t) {
                        return t
                    },
                    Sn = "data-server-rendered",
                    An = ["component", "directive", "filter"],
                    Ln = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured"],
                    Pn = {
                        optionMergeStrategies: Object.create(null),
                        silent: !1,
                        productionTip: !1,
                        devtools: !1,
                        performance: !1,
                        errorHandler: null,
                        warnHandler: null,
                        ignoredElements: [],
                        keyCodes: Object.create(null),
                        isReservedTag: En,
                        isReservedAttr: En,
                        isUnknownElement: En,
                        getTagNamespace: y,
                        parsePlatformTagName: Tn,
                        mustUseProp: En,
                        _lifecycleHooks: Ln
                    },
                    Cn = /[^\w.$]/,
                    Rn = "__proto__" in {},
                    On = "undefined" != typeof window,
                    In = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform,
                    Nn = In && WXEnvironment.platform.toLowerCase(),
                    Dn = On && window.navigator.userAgent.toLowerCase(),
                    Un = Dn && /msie|trident/.test(Dn),
                    kn = Dn && Dn.indexOf("msie 9.0") > 0,
                    Fn = Dn && Dn.indexOf("edge/") > 0,
                    zn = Dn && Dn.indexOf("android") > 0 || "android" === Nn,
                    Bn = Dn && /iphone|ipad|ipod|ios/.test(Dn) || "ios" === Nn,
                    jn = (Dn && /chrome\/\d+/.test(Dn), {}.watch),
                    Gn = !1;
                if (On) try {
                    var Hn = {};
                    Object.defineProperty(Hn, "passive", {
                        get: function() {
                            Gn = !0
                        }
                    }), window.addEventListener("test-passive", null, Hn)
                } catch (e) {}
                var Vn, Wn, Xn = function() {
                        return void 0 === Vn && (Vn = !On && void 0 !== t && "server" === t.process.env.VUE_ENV), Vn
                    },
                    qn = On && window.__VUE_DEVTOOLS_GLOBAL_HOOK__,
                    Yn = "undefined" != typeof Symbol && M(Symbol) && "undefined" != typeof Reflect && M(Reflect.ownKeys);
                Wn = "undefined" != typeof Set && M(Set) ? Set : function() {
                    function t() {
                        this.set = Object.create(null)
                    }
                    return t.prototype.has = function(t) {
                        return !0 === this.set[t]
                    }, t.prototype.add = function(t) {
                        this.set[t] = !0
                    }, t.prototype.clear = function() {
                        this.set = Object.create(null)
                    }, t
                }();
                var $n = y,
                    Zn = 0,
                    Jn = function() {
                        this.id = Zn++, this.subs = []
                    };
                Jn.prototype.addSub = function(t) {
                    this.subs.push(t)
                }, Jn.prototype.removeSub = function(t) {
                    h(this.subs, t)
                }, Jn.prototype.depend = function() {
                    Jn.target && Jn.target.addDep(this)
                }, Jn.prototype.notify = function() {
                    for (var t = this.subs.slice(), e = 0, n = t.length; e < n; e++) t[e].update()
                }, Jn.target = null;
                var Kn = [],
                    Qn = function(t, e, n, i, r, a, o, s) {
                        this.tag = t, this.data = e, this.children = n, this.text = i, this.elm = r, this.ns = void 0, this.context = a, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e && e.key, this.componentOptions = o, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1
                    },
                    ti = {
                        child: {
                            configurable: !0
                        }
                    };
                ti.child.get = function() {
                    return this.componentInstance
                }, Object.defineProperties(Qn.prototype, ti);
                var ei = function(t) {
                        void 0 === t && (t = "");
                        var e = new Qn;
                        return e.text = t, e.isComment = !0, e
                    },
                    ni = Array.prototype,
                    ii = Object.create(ni);
                ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function(t) {
                    var e = ni[t];
                    _(ii, t, function() {
                        for (var n = [], i = arguments.length; i--;) n[i] = arguments[i];
                        var r, a = e.apply(this, n),
                            o = this.__ob__;
                        switch (t) {
                            case "push":
                            case "unshift":
                                r = n;
                                break;
                            case "splice":
                                r = n.slice(2)
                        }
                        return r && o.observeArray(r), o.dep.notify(), a
                    })
                });
                var ri = Object.getOwnPropertyNames(ii),
                    ai = {
                        shouldConvert: !0
                    },
                    oi = function(t) {
                        this.value = t, this.dep = new Jn, this.vmCount = 0, _(t, "__ob__", this), Array.isArray(t) ? ((Rn ? function(t, e, n) {
                            t.__proto__ = e
                        } : function(t, e, n) {
                            for (var i = 0, r = n.length; i < r; i++) {
                                var a = n[i];
                                _(t, a, e[a])
                            }
                        })(t, ii, ri), this.observeArray(t)) : this.walk(t)
                    };
                oi.prototype.walk = function(t) {
                    for (var e = Object.keys(t), n = 0; n < e.length; n++) L(t, e[n], t[e[n]])
                }, oi.prototype.observeArray = function(t) {
                    for (var e = 0, n = t.length; e < n; e++) A(t[e])
                };
                var si = Pn.optionMergeStrategies;
                si.data = function(t, e, n) {
                    return n ? O(t, e, n) : e && "function" != typeof e ? t : O(t, e)
                }, Ln.forEach(function(t) {
                    si[t] = I
                }), An.forEach(function(t) {
                    si[t + "s"] = N
                }), si.watch = function(t, e, n, i) {
                    if (t === jn && (t = void 0), e === jn && (e = void 0), !e) return Object.create(t || null);
                    if (!t) return e;
                    var r = {};
                    for (var a in v(r, t), e) {
                        var o = r[a],
                            s = e[a];
                        o && !Array.isArray(o) && (o = [o]), r[a] = o ? o.concat(s) : Array.isArray(s) ? s : [s]
                    }
                    return r
                }, si.props = si.methods = si.inject = si.computed = function(t, e, n, i) {
                    if (!t) return e;
                    var r = Object.create(null);
                    return v(r, t), e && v(r, e), r
                }, si.provide = O;
                var ci, li, ui = function(t, e) {
                        return void 0 === e ? t : e
                    },
                    hi = [],
                    di = !1,
                    pi = !1;
                if ("undefined" != typeof setImmediate && M(setImmediate)) li = function() {
                    setImmediate(H)
                };
                else if ("undefined" == typeof MessageChannel || !M(MessageChannel) && "[object MessageChannelConstructor]" !== MessageChannel.toString()) li = function() {
                    setTimeout(H, 0)
                };
                else {
                    var fi = new MessageChannel,
                        mi = fi.port2;
                    fi.port1.onmessage = H, li = function() {
                        mi.postMessage(1)
                    }
                }
                if ("undefined" != typeof Promise && M(Promise)) {
                    var vi = Promise.resolve();
                    ci = function() {
                        vi.then(H), Bn && setTimeout(y)
                    }
                } else ci = li;
                var gi, yi = new Wn,
                    xi = p(function(t) {
                        var e = "&" === t.charAt(0),
                            n = "~" === (t = e ? t.slice(1) : t).charAt(0),
                            i = "!" === (t = n ? t.slice(1) : t).charAt(0);
                        return {
                            name: t = i ? t.slice(1) : t,
                            once: n,
                            capture: i,
                            passive: e
                        }
                    }),
                    bi = null,
                    wi = [],
                    _i = [],
                    Mi = {},
                    Ei = !1,
                    Ti = !1,
                    Si = 0,
                    Ai = 0,
                    Li = function(t, e, n, i, r) {
                        this.vm = t, r && (t._watcher = this), t._watchers.push(this), i ? (this.deep = !!i.deep, this.user = !!i.user, this.lazy = !!i.lazy, this.sync = !!i.sync) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++Ai, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new Wn, this.newDepIds = new Wn, this.expression = "", "function" == typeof e ? this.getter = e : (this.getter = function(t) {
                            if (!Cn.test(t)) {
                                var e = t.split(".");
                                return function(t) {
                                    for (var n = 0; n < e.length; n++) {
                                        if (!t) return;
                                        t = t[e[n]]
                                    }
                                    return t
                                }
                            }
                        }(e), this.getter || (this.getter = function() {})), this.value = this.lazy ? void 0 : this.get()
                    };
                Li.prototype.get = function() {
                    var t;
                    t = this, Jn.target && Kn.push(Jn.target), Jn.target = t;
                    var e, n = this.vm;
                    try {
                        e = this.getter.call(n, n)
                    } catch (e) {
                        if (!this.user) throw e;
                        B(e, n, 'getter for watcher "' + this.expression + '"')
                    } finally {
                        this.deep && W(e), Jn.target = Kn.pop(), this.cleanupDeps()
                    }
                    return e
                }, Li.prototype.addDep = function(t) {
                    var e = t.id;
                    this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(this))
                }, Li.prototype.cleanupDeps = function() {
                    for (var t = this.deps.length; t--;) {
                        var e = this.deps[t];
                        this.newDepIds.has(e.id) || e.removeSub(this)
                    }
                    var n = this.depIds;
                    this.depIds = this.newDepIds, this.newDepIds = n, this.newDepIds.clear(), n = this.deps, this.deps = this.newDeps, this.newDeps = n, this.newDeps.length = 0
                }, Li.prototype.update = function() {
                    this.lazy ? this.dirty = !0 : this.sync ? this.run() : function(t) {
                        var e = t.id;
                        if (null == Mi[e]) {
                            if (Mi[e] = !0, Ti) {
                                for (var n = wi.length - 1; n > Si && wi[n].id > t.id;) n--;
                                wi.splice(n + 1, 0, t)
                            } else wi.push(t);
                            Ei || (Ei = !0, V(lt))
                        }
                    }(this)
                }, Li.prototype.run = function() {
                    if (this.active) {
                        var t = this.get();
                        if (t !== this.value || a(t) || this.deep) {
                            var e = this.value;
                            if (this.value = t, this.user) try {
                                this.cb.call(this.vm, t, e)
                            } catch (t) {
                                B(t, this.vm, 'callback for watcher "' + this.expression + '"')
                            } else this.cb.call(this.vm, t, e)
                        }
                    }
                }, Li.prototype.evaluate = function() {
                    this.value = this.get(), this.dirty = !1
                }, Li.prototype.depend = function() {
                    for (var t = this.deps.length; t--;) this.deps[t].depend()
                }, Li.prototype.teardown = function() {
                    if (this.active) {
                        this.vm._isBeingDestroyed || h(this.vm._watchers, this);
                        for (var t = this.deps.length; t--;) this.deps[t].removeSub(this);
                        this.active = !1
                    }
                };
                var Pi = {
                        enumerable: !0,
                        configurable: !0,
                        get: y,
                        set: y
                    },
                    Ci = {
                        lazy: !0
                    };
                Tt(St.prototype);
                var Ri, Oi, Ii, Ni, Di, Ui, ki, Fi = {
                        init: function(t, e, i, r) {
                            if (!t.componentInstance || t.componentInstance._isDestroyed)(t.componentInstance = (o = t, s = {
                                _isComponent: !0,
                                parent: bi,
                                _parentVnode: o,
                                _parentElm: i || null,
                                _refElm: r || null
                            }, c = o.data.inlineTemplate, n(c) && (s.render = c.render, s.staticRenderFns = c.staticRenderFns), new o.componentOptions.Ctor(s))).$mount(e ? t.elm : void 0, e);
                            else if (t.data.keepAlive) {
                                var a = t;
                                Fi.prepatch(a, a)
                            }
                            var o, s, c
                        },
                        prepatch: function(t, e) {
                            var n = e.componentOptions;
                            ! function(t, e, n, i, r) {
                                var a = !!(r || t.$options._renderChildren || i.data.scopedSlots || t.$scopedSlots !== fn);
                                if (t.$options._parentVnode = i, t.$vnode = i, t._vnode && (t._vnode.parent = i), t.$options._renderChildren = r, t.$attrs = i.data && i.data.attrs || fn, t.$listeners = n || fn, e && t.$options.props) {
                                    ai.shouldConvert = !1;
                                    for (var o = t._props, s = t.$options._propKeys || [], c = 0; c < s.length; c++) {
                                        var l = s[c];
                                        o[l] = k(l, t.$options.props, e, t)
                                    }
                                    ai.shouldConvert = !0, t.$options.propsData = e
                                }
                                if (n) {
                                    var u = t.$options._parentListeners;
                                    t.$options._parentListeners = n, nt(t, n, u)
                                }
                                a && (t.$slots = it(r, i.context), t.$forceUpdate())
                            }(e.componentInstance = t.componentInstance, n.propsData, n.listeners, e, n.children)
                        },
                        insert: function(t) {
                            var e, n = t.context,
                                i = t.componentInstance;
                            i._isMounted || (i._isMounted = !0, ct(i, "mounted")), t.data.keepAlive && (n._isMounted ? ((e = i)._inactive = !1, _i.push(e)) : st(i, !0))
                        },
                        destroy: function(t) {
                            var e = t.componentInstance;
                            e._isDestroyed || (t.data.keepAlive ? function t(e, n) {
                                if (!(n && (e._directInactive = !0, ot(e)) || e._inactive)) {
                                    e._inactive = !0;
                                    for (var i = 0; i < e.$children.length; i++) t(e.$children[i]);
                                    ct(e, "deactivated")
                                }
                            }(e, !0) : e.$destroy())
                        }
                    },
                    zi = Object.keys(Fi),
                    Bi = 1,
                    ji = 2,
                    Gi = 0;
                Rt.prototype._init = function(t) {
                    var e, n, i, r;
                    this._uid = Gi++, this._isVue = !0, t && t._isComponent ? function(t, e) {
                            var n = t.$options = Object.create(t.constructor.options),
                                i = e._parentVnode;
                            n.parent = e.parent, n._parentVnode = i, n._parentElm = e._parentElm, n._refElm = e._refElm;
                            var r = i.componentOptions;
                            n.propsData = r.propsData, n._parentListeners = r.listeners, n._renderChildren = r.children, n._componentTag = r.tag, e.render && (n.render = e.render, n.staticRenderFns = e.staticRenderFns)
                        }(this, t) : this.$options = D(Ct(this.constructor), t || {}, this), this._renderProxy = this, this._self = this,
                        function(t) {
                            var e = t.$options,
                                n = e.parent;
                            if (n && !e.abstract) {
                                for (; n.$options.abstract && n.$parent;) n = n.$parent;
                                n.$children.push(t)
                            }
                            t.$parent = n, t.$root = n ? n.$root : t, t.$children = [], t.$refs = {}, t._watcher = null, t._inactive = null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !1
                        }(this),
                        function(t) {
                            t._events = Object.create(null), t._hasHookEvent = !1;
                            var e = t.$options._parentListeners;
                            e && nt(t, e)
                        }(this),
                        function(t) {
                            t._vnode = null, t._staticTrees = null;
                            var e = t.$options,
                                n = t.$vnode = e._parentVnode,
                                i = n && n.context;
                            t.$slots = it(e._renderChildren, i), t.$scopedSlots = fn, t._c = function(e, n, i, r) {
                                return Pt(t, e, n, i, r, !1)
                            }, t.$createElement = function(e, n, i, r) {
                                return Pt(t, e, n, i, r, !0)
                            };
                            var r = n && n.data;
                            L(t, "$attrs", r && r.attrs || fn, 0, !0), L(t, "$listeners", e._parentListeners || fn, 0, !0)
                        }(this), ct(this, "beforeCreate"), (r = ft((i = this).$options.inject, i)) && (ai.shouldConvert = !1, Object.keys(r).forEach(function(t) {
                            L(i, t, r[t])
                        }), ai.shouldConvert = !0),
                        function(t) {
                            t._watchers = [];
                            var e = t.$options;
                            e.props && function(t, e) {
                                var n = t.$options.propsData || {},
                                    i = t._props = {},
                                    r = t.$options._propKeys = [],
                                    a = !t.$parent;
                                ai.shouldConvert = a;
                                var o = function(a) {
                                    r.push(a);
                                    var o = k(a, e, n, t);
                                    L(i, a, o), a in t || ut(t, "_props", a)
                                };
                                for (var s in e) o(s);
                                ai.shouldConvert = !0
                            }(t, e.props), e.methods && function(t, e) {
                                for (var n in t.$options.props, e) t[n] = null == e[n] ? y : f(e[n], t)
                            }(t, e.methods), e.data ? function(t) {
                                var e = t.$options.data;
                                o(e = t._data = "function" == typeof e ? function(t, e) {
                                    try {
                                        return t.call(e, e)
                                    } catch (t) {
                                        return B(t, e, "data()"), {}
                                    }
                                }(e, t) : e || {}) || (e = {});
                                for (var n, i = Object.keys(e), r = t.$options.props, a = (t.$options.methods, i.length); a--;) {
                                    var s = i[a];
                                    r && d(r, s) || 36 === (n = (s + "").charCodeAt(0)) || 95 === n || ut(t, "_data", s)
                                }
                                A(e, !0)
                            }(t) : A(t._data = {}, !0), e.computed && function(t, e) {
                                var n = t._computedWatchers = Object.create(null),
                                    i = Xn();
                                for (var r in e) {
                                    var a = e[r],
                                        o = "function" == typeof a ? a : a.get;
                                    i || (n[r] = new Li(t, o || y, y, Ci)), r in t || ht(t, r, a)
                                }
                            }(t, e.computed), e.watch && e.watch !== jn && function(t, e) {
                                for (var n in e) {
                                    var i = e[n];
                                    if (Array.isArray(i))
                                        for (var r = 0; r < i.length; r++) pt(t, n, i[r]);
                                    else pt(t, n, i)
                                }
                            }(t, e.watch)
                        }(this), (n = (e = this).$options.provide) && (e._provided = "function" == typeof n ? n.call(e) : n), ct(this, "created"), this.$options.el && this.$mount(this.$options.el)
                }, Di = Rt, Ui = {
                    get: function() {
                        return this._data
                    }
                }, ki = {
                    get: function() {
                        return this._props
                    }
                }, Object.defineProperty(Di.prototype, "$data", Ui), Object.defineProperty(Di.prototype, "$props", ki), Di.prototype.$set = P, Di.prototype.$delete = C, Di.prototype.$watch = function(t, e, n) {
                    if (o(e)) return pt(this, t, e, n);
                    (n = n || {}).user = !0;
                    var i = new Li(this, t, e, n);
                    return n.immediate && e.call(this, i.value),
                        function() {
                            i.teardown()
                        }
                }, Ni = /^hook:/, (Ii = Rt).prototype.$on = function(t, e) {
                    if (Array.isArray(t))
                        for (var n = 0, i = t.length; n < i; n++) this.$on(t[n], e);
                    else(this._events[t] || (this._events[t] = [])).push(e), Ni.test(t) && (this._hasHookEvent = !0);
                    return this
                }, Ii.prototype.$once = function(t, e) {
                    function n() {
                        i.$off(t, n), e.apply(i, arguments)
                    }
                    var i = this;
                    return n.fn = e, i.$on(t, n), i
                }, Ii.prototype.$off = function(t, e) {
                    if (!arguments.length) return this._events = Object.create(null), this;
                    if (Array.isArray(t)) {
                        for (var n = 0, i = t.length; n < i; n++) this.$off(t[n], e);
                        return this
                    }
                    var r = this._events[t];
                    if (!r) return this;
                    if (!e) return this._events[t] = null, this;
                    if (e)
                        for (var a, o = r.length; o--;)
                            if ((a = r[o]) === e || a.fn === e) {
                                r.splice(o, 1);
                                break
                            }
                    return this
                }, Ii.prototype.$emit = function(t) {
                    var e = this,
                        n = e._events[t];
                    if (n) {
                        n = n.length > 1 ? m(n) : n;
                        for (var i = m(arguments, 1), r = 0, a = n.length; r < a; r++) try {
                            n[r].apply(e, i)
                        } catch (n) {
                            B(n, e, 'event handler for "' + t + '"')
                        }
                    }
                    return e
                }, (Oi = Rt).prototype._update = function(t, e) {
                    this._isMounted && ct(this, "beforeUpdate");
                    var n = this.$el,
                        i = this._vnode,
                        r = bi;
                    bi = this, this._vnode = t, i ? this.$el = this.__patch__(i, t) : (this.$el = this.__patch__(this.$el, t, e, !1, this.$options._parentElm, this.$options._refElm), this.$options._parentElm = this.$options._refElm = null), bi = r, n && (n.__vue__ = null), this.$el && (this.$el.__vue__ = this), this.$vnode && this.$parent && this.$vnode === this.$parent._vnode && (this.$parent.$el = this.$el)
                }, Oi.prototype.$forceUpdate = function() {
                    this._watcher && this._watcher.update()
                }, Oi.prototype.$destroy = function() {
                    if (!this._isBeingDestroyed) {
                        ct(this, "beforeDestroy"), this._isBeingDestroyed = !0;
                        var t = this.$parent;
                        !t || t._isBeingDestroyed || this.$options.abstract || h(t.$children, this), this._watcher && this._watcher.teardown();
                        for (var e = this._watchers.length; e--;) this._watchers[e].teardown();
                        this._data.__ob__ && this._data.__ob__.vmCount--, this._isDestroyed = !0, this.__patch__(this._vnode, null), ct(this, "destroyed"), this.$off(), this.$el && (this.$el.__vue__ = null), this.$vnode && (this.$vnode.parent = null)
                    }
                }, Tt((Ri = Rt).prototype), Ri.prototype.$nextTick = function(t) {
                    return V(t, this)
                }, Ri.prototype._render = function() {
                    var t, e = this,
                        n = e.$options,
                        i = n.render,
                        r = n._parentVnode;
                    if (e._isMounted)
                        for (var a in e.$slots) {
                            var o = e.$slots[a];
                            (o._rendered || o[0] && o[0].elm) && (e.$slots[a] = S(o, !0))
                        }
                    e.$scopedSlots = r && r.data.scopedSlots || fn, e.$vnode = r;
                    try {
                        t = i.call(e._renderProxy, e.$createElement)
                    } catch (n) {
                        B(n, e, "render"), t = e._vnode
                    }
                    return t instanceof Qn || (t = ei()), t.parent = r, t
                };
                var Hi, Vi, Wi, Xi = [String, RegExp, Array],
                    qi = {
                        KeepAlive: {
                            name: "keep-alive",
                            abstract: !0,
                            props: {
                                include: Xi,
                                exclude: Xi,
                                max: [String, Number]
                            },
                            created: function() {
                                this.cache = Object.create(null), this.keys = []
                            },
                            destroyed: function() {
                                for (var t in this.cache) Dt(this.cache, t, this.keys)
                            },
                            watch: {
                                include: function(t) {
                                    Nt(this, function(e) {
                                        return It(t, e)
                                    })
                                },
                                exclude: function(t) {
                                    Nt(this, function(e) {
                                        return !It(t, e)
                                    })
                                }
                            },
                            render: function() {
                                var t = this.$slots.default,
                                    e = Q(t),
                                    n = e && e.componentOptions;
                                if (n) {
                                    var i = Ot(n),
                                        r = this.include,
                                        a = this.exclude;
                                    if (r && (!i || !It(r, i)) || a && i && It(a, i)) return e;
                                    var o = this.cache,
                                        s = this.keys,
                                        c = null == e.key ? n.Ctor.cid + (n.tag ? "::" + n.tag : "") : e.key;
                                    o[c] ? (e.componentInstance = o[c].componentInstance, h(s, c), s.push(c)) : (o[c] = e, s.push(c), this.max && s.length > parseInt(this.max) && Dt(o, s[0], s, this._vnode)), e.data.keepAlive = !0
                                }
                                return e || t && t[0]
                            }
                        }
                    };
                Hi = Rt, (Wi = {}).get = function() {
                        return Pn
                    }, Object.defineProperty(Hi, "config", Wi), Hi.util = {
                        warn: $n,
                        extend: v,
                        mergeOptions: D,
                        defineReactive: L
                    }, Hi.set = P, Hi.delete = C, Hi.nextTick = V, Hi.options = Object.create(null), An.forEach(function(t) {
                        Hi.options[t + "s"] = Object.create(null)
                    }), Hi.options._base = Hi, v(Hi.options.components, qi), Hi.use = function(t) {
                        var e = this._installedPlugins || (this._installedPlugins = []);
                        if (e.indexOf(t) > -1) return this;
                        var n = m(arguments, 1);
                        return n.unshift(this), "function" == typeof t.install ? t.install.apply(t, n) : "function" == typeof t && t.apply(null, n), e.push(t), this
                    }, Hi.mixin = function(t) {
                        return this.options = D(this.options, t), this
                    },
                    function(t) {
                        t.cid = 0;
                        var e = 1;
                        t.extend = function(t) {
                            t = t || {};
                            var n = this,
                                i = n.cid,
                                r = t._Ctor || (t._Ctor = {});
                            if (r[i]) return r[i];
                            var a = t.name || n.options.name,
                                o = function(t) {
                                    this._init(t)
                                };
                            return (o.prototype = Object.create(n.prototype)).constructor = o, o.cid = e++, o.options = D(n.options, t), o.super = n, o.options.props && function(t) {
                                var e = t.options.props;
                                for (var n in e) ut(t.prototype, "_props", n)
                            }(o), o.options.computed && function(t) {
                                var e = t.options.computed;
                                for (var n in e) ht(t.prototype, n, e[n])
                            }(o), o.extend = n.extend, o.mixin = n.mixin, o.use = n.use, An.forEach(function(t) {
                                o[t] = n[t]
                            }), a && (o.options.components[a] = o), o.superOptions = n.options, o.extendOptions = t, o.sealedOptions = v({}, o.options), r[i] = o, o
                        }
                    }(Hi), Vi = Hi, An.forEach(function(t) {
                        Vi[t] = function(e, n) {
                            return n ? ("component" === t && o(n) && (n.name = n.name || e, n = this.options._base.extend(n)), "directive" === t && "function" == typeof n && (n = {
                                bind: n,
                                update: n
                            }), this.options[t + "s"][e] = n, n) : this.options[t + "s"][e]
                        }
                    }), Object.defineProperty(Rt.prototype, "$isServer", {
                        get: Xn
                    }), Object.defineProperty(Rt.prototype, "$ssrContext", {
                        get: function() {
                            return this.$vnode && this.$vnode.ssrContext
                        }
                    }), Rt.version = "2.5.13";
                var Yi, $i, Zi, Ji, Ki, Qi, tr, er, nr = u("style,class"),
                    ir = u("input,textarea,option,select,progress"),
                    rr = function(t, e, n) {
                        return "value" === n && ir(t) && "button" !== e || "selected" === n && "option" === t || "checked" === n && "input" === t || "muted" === n && "video" === t
                    },
                    ar = u("contenteditable,draggable,spellcheck"),
                    or = u("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),
                    sr = "http://www.w3.org/1999/xlink",
                    cr = function(t) {
                        return ":" === t.charAt(5) && "xlink" === t.slice(0, 5)
                    },
                    lr = function(t) {
                        return cr(t) ? t.slice(6, t.length) : ""
                    },
                    ur = function(t) {
                        return null == t || !1 === t
                    },
                    hr = {
                        svg: "http://www.w3.org/2000/svg",
                        math: "http://www.w3.org/1998/Math/MathML"
                    },
                    dr = u("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),
                    pr = u("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0),
                    fr = function(t) {
                        return dr(t) || pr(t)
                    },
                    mr = Object.create(null),
                    vr = u("text,number,password,search,email,tel,url"),
                    gr = Object.freeze({
                        createElement: function(t, e) {
                            var n = document.createElement(t);
                            return "select" !== t ? n : (e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute("multiple", "multiple"), n)
                        },
                        createElementNS: function(t, e) {
                            return document.createElementNS(hr[t], e)
                        },
                        createTextNode: function(t) {
                            return document.createTextNode(t)
                        },
                        createComment: function(t) {
                            return document.createComment(t)
                        },
                        insertBefore: function(t, e, n) {
                            t.insertBefore(e, n)
                        },
                        removeChild: function(t, e) {
                            t.removeChild(e)
                        },
                        appendChild: function(t, e) {
                            t.appendChild(e)
                        },
                        parentNode: function(t) {
                            return t.parentNode
                        },
                        nextSibling: function(t) {
                            return t.nextSibling
                        },
                        tagName: function(t) {
                            return t.tagName
                        },
                        setTextContent: function(t, e) {
                            t.textContent = e
                        },
                        setAttribute: function(t, e, n) {
                            t.setAttribute(e, n)
                        }
                    }),
                    yr = {
                        create: function(t, e) {
                            jt(e)
                        },
                        update: function(t, e) {
                            t.data.ref !== e.data.ref && (jt(t, !0), jt(e))
                        },
                        destroy: function(t) {
                            jt(t, !0)
                        }
                    },
                    xr = new Qn("", {}, []),
                    br = ["create", "activate", "update", "remove", "destroy"],
                    wr = {
                        create: Vt,
                        update: Vt,
                        destroy: function(t) {
                            Vt(t, xr)
                        }
                    },
                    _r = Object.create(null),
                    Mr = [yr, wr],
                    Er = {
                        create: qt,
                        update: qt
                    },
                    Tr = {
                        create: $t,
                        update: $t
                    },
                    Sr = /[\w).+\-_$\]]/,
                    Ar = "__r",
                    Lr = "__c",
                    Pr = {
                        create: pe,
                        update: pe
                    },
                    Cr = {
                        create: fe,
                        update: fe
                    },
                    Rr = p(function(t) {
                        var e = {},
                            n = /:(.+)/;
                        return t.split(/;(?![^(]*\))/g).forEach(function(t) {
                            if (t) {
                                var i = t.split(n);
                                i.length > 1 && (e[i[0].trim()] = i[1].trim())
                            }
                        }), e
                    }),
                    Or = /^--/,
                    Ir = /\s*!important$/,
                    Nr = function(t, e, n) {
                        if (Or.test(e)) t.style.setProperty(e, n);
                        else if (Ir.test(n)) t.style.setProperty(e, n.replace(Ir, ""), "important");
                        else {
                            var i = Ur(e);
                            if (Array.isArray(n))
                                for (var r = 0, a = n.length; r < a; r++) t.style[i] = n[r];
                            else t.style[i] = n
                        }
                    },
                    Dr = ["Webkit", "Moz", "ms"],
                    Ur = p(function(t) {
                        if (er = er || document.createElement("div").style, "filter" !== (t = bn(t)) && t in er) return t;
                        for (var e = t.charAt(0).toUpperCase() + t.slice(1), n = 0; n < Dr.length; n++) {
                            var i = Dr[n] + e;
                            if (i in er) return i
                        }
                    }),
                    kr = {
                        create: ge,
                        update: ge
                    },
                    Fr = p(function(t) {
                        return {
                            enterClass: t + "-enter",
                            enterToClass: t + "-enter-to",
                            enterActiveClass: t + "-enter-active",
                            leaveClass: t + "-leave",
                            leaveToClass: t + "-leave-to",
                            leaveActiveClass: t + "-leave-active"
                        }
                    }),
                    zr = On && !kn,
                    Br = "transition",
                    jr = "animation",
                    Gr = "transition",
                    Hr = "transitionend",
                    Vr = "animation",
                    Wr = "animationend";
                zr && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (Gr = "WebkitTransition", Hr = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Vr = "WebkitAnimation", Wr = "webkitAnimationEnd"));
                var Xr = On ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(t) {
                        return t()
                    },
                    qr = /\b(transform|all)(,|$)/,
                    Yr = function(t) {
                        function a(t) {
                            var e = T.parentNode(t);
                            n(e) && T.removeChild(e, t)
                        }
  
                        function o(t, e, r, a, o) {
                            if (t.isRootInsert = !o, ! function(t, e, r, a) {
                                    var o = t.data;
                                    if (n(o)) {
                                        var l = n(t.componentInstance) && o.keepAlive;
                                        if (n(o = o.hook) && n(o = o.init) && o(t, !1, r, a), n(t.componentInstance)) return s(t, e), i(l) && function(t, e, i, r) {
                                            for (var a, o = t; o.componentInstance;)
                                                if (n(a = (o = o.componentInstance._vnode).data) && n(a = a.transition)) {
                                                    for (a = 0; a < M.activate.length; ++a) M.activate[a](xr, o);
                                                    e.push(o);
                                                    break
                                                }
                                            c(i, t.elm, r)
                                        }(t, e, r, a), !0
                                    }
                                }(t, e, r, a)) {
                                var u = t.data,
                                    h = t.children,
                                    f = t.tag;
                                n(f) ? (t.elm = t.ns ? T.createElementNS(t.ns, f) : T.createElement(f, t), p(t), l(t, h, e), n(u) && d(t, e), c(r, t.elm, a)) : i(t.isComment) ? (t.elm = T.createComment(t.text), c(r, t.elm, a)) : (t.elm = T.createTextNode(t.text), c(r, t.elm, a))
                            }
                        }
  
                        function s(t, e) {
                            n(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert), t.data.pendingInsert = null), t.elm = t.componentInstance.$el, h(t) ? (d(t, e), p(t)) : (jt(t), e.push(t))
                        }
  
                        function c(t, e, i) {
                            n(t) && (n(i) ? i.parentNode === t && T.insertBefore(t, e, i) : T.appendChild(t, e))
                        }
  
                        function l(t, e, n) {
                            if (Array.isArray(e))
                                for (var i = 0; i < e.length; ++i) o(e[i], n, t.elm, null, !0);
                            else r(t.text) && T.appendChild(t.elm, T.createTextNode(String(t.text)))
                        }
  
                        function h(t) {
                            for (; t.componentInstance;) t = t.componentInstance._vnode;
                            return n(t.tag)
                        }
  
                        function d(t, e) {
                            for (var i = 0; i < M.create.length; ++i) M.create[i](xr, t);
                            n(w = t.data.hook) && (n(w.create) && w.create(xr, t), n(w.insert) && e.push(t))
                        }
  
                        function p(t) {
                            var e;
                            if (n(e = t.fnScopeId)) T.setAttribute(t.elm, e, "");
                            else
                                for (var i = t; i;) n(e = i.context) && n(e = e.$options._scopeId) && T.setAttribute(t.elm, e, ""), i = i.parent;
                            n(e = bi) && e !== t.context && e !== t.fnContext && n(e = e.$options._scopeId) && T.setAttribute(t.elm, e, "")
                        }
  
                        function f(t, e, n, i, r, a) {
                            for (; i <= r; ++i) o(n[i], a, t, e)
                        }
  
                        function m(t) {
                            var e, i, r = t.data;
                            if (n(r))
                                for (n(e = r.hook) && n(e = e.destroy) && e(t), e = 0; e < M.destroy.length; ++e) M.destroy[e](t);
                            if (n(e = t.children))
                                for (i = 0; i < t.children.length; ++i) m(t.children[i])
                        }
  
                        function v(t, e, i, r) {
                            for (; i <= r; ++i) {
                                var o = e[i];
                                n(o) && (n(o.tag) ? (g(o), m(o)) : a(o.elm))
                            }
                        }
  
                        function g(t, e) {
                            if (n(e) || n(t.data)) {
                                var i, r = M.remove.length + 1;
                                for (n(e) ? e.listeners += r : e = function(t, e) {
                                        function n() {
                                            0 == --n.listeners && a(t)
                                        }
                                        return n.listeners = e, n
                                    }(t.elm, r), n(i = t.componentInstance) && n(i = i._vnode) && n(i.data) && g(i, e), i = 0; i < M.remove.length; ++i) M.remove[i](t, e);
                                n(i = t.data.hook) && n(i = i.remove) ? i(t, e) : e()
                            } else a(t.elm)
                        }
  
                        function y(t, r, a, s) {
                            if (t !== r) {
                                var c = r.elm = t.elm;
                                if (i(t.isAsyncPlaceholder)) n(r.asyncFactory.resolved) ? b(t.elm, r, a) : r.isAsyncPlaceholder = !0;
                                else if (i(r.isStatic) && i(t.isStatic) && r.key === t.key && (i(r.isCloned) || i(r.isOnce))) r.componentInstance = t.componentInstance;
                                else {
                                    var l, u = r.data;
                                    n(u) && n(l = u.hook) && n(l = l.prepatch) && l(t, r);
                                    var d = t.children,
                                        p = r.children;
                                    if (n(u) && h(r)) {
                                        for (l = 0; l < M.update.length; ++l) M.update[l](t, r);
                                        n(l = u.hook) && n(l = l.update) && l(t, r)
                                    }
                                    e(r.text) ? n(d) && n(p) ? d !== p && function(t, i, r, a, s) {
                                        for (var c, l, u, h = 0, d = 0, p = i.length - 1, m = i[0], g = i[p], x = r.length - 1, b = r[0], w = r[x], _ = !s; h <= p && d <= x;) e(m) ? m = i[++h] : e(g) ? g = i[--p] : Gt(m, b) ? (y(m, b, a), m = i[++h], b = r[++d]) : Gt(g, w) ? (y(g, w, a), g = i[--p], w = r[--x]) : Gt(m, w) ? (y(m, w, a), _ && T.insertBefore(t, m.elm, T.nextSibling(g.elm)), m = i[++h], w = r[--x]) : Gt(g, b) ? (y(g, b, a), _ && T.insertBefore(t, g.elm, m.elm), g = i[--p], b = r[++d]) : (e(c) && (c = Ht(i, h, p)), e(l = n(b.key) ? c[b.key] : function(t, e, i, r) {
                                            for (var a = h; a < r; a++) {
                                                var o = e[a];
                                                if (n(o) && Gt(t, o)) return a
                                            }
                                        }(b, i, 0, p)) ? o(b, a, t, m.elm) : Gt(u = i[l], b) ? (y(u, b, a), i[l] = void 0, _ && T.insertBefore(t, u.elm, m.elm)) : o(b, a, t, m.elm), b = r[++d]);
                                        h > p ? f(t, e(r[x + 1]) ? null : r[x + 1].elm, r, d, x, a) : d > x && v(0, i, h, p)
                                    }(c, d, p, a, s) : n(p) ? (n(t.text) && T.setTextContent(c, ""), f(c, null, p, 0, p.length - 1, a)) : n(d) ? v(0, d, 0, d.length - 1) : n(t.text) && T.setTextContent(c, "") : t.text !== r.text && T.setTextContent(c, r.text), n(u) && n(l = u.hook) && n(l = l.postpatch) && l(t, r)
                                }
                            }
                        }
  
                        function x(t, e, r) {
                            if (i(r) && n(t.parent)) t.parent.data.pendingInsert = e;
                            else
                                for (var a = 0; a < e.length; ++a) e[a].data.hook.insert(e[a])
                        }
  
                        function b(t, e, r, a) {
                            var o, c = e.tag,
                                u = e.data,
                                h = e.children;
                            if (a = a || u && u.pre, e.elm = t, i(e.isComment) && n(e.asyncFactory)) return e.isAsyncPlaceholder = !0, !0;
                            if (n(u) && (n(o = u.hook) && n(o = o.init) && o(e, !0), n(o = e.componentInstance))) return s(e, r), !0;
                            if (n(c)) {
                                if (n(h))
                                    if (t.hasChildNodes())
                                        if (n(o = u) && n(o = o.domProps) && n(o = o.innerHTML)) {
                                            if (o !== t.innerHTML) return !1
                                        } else {
                                            for (var p = !0, f = t.firstChild, m = 0; m < h.length; m++) {
                                                if (!f || !b(f, h[m], r, a)) {
                                                    p = !1;
                                                    break
                                                }
                                                f = f.nextSibling
                                            }
                                            if (!p || f) return !1
                                        } else l(e, h, r);
                                if (n(u)) {
                                    var v = !1;
                                    for (var g in u)
                                        if (!S(g)) {
                                            v = !0, d(e, r);
                                            break
                                        }!v && u.class && W(u.class)
                                }
                            } else t.data !== e.text && (t.data = e.text);
                            return !0
                        }
                        var w, _, M = {},
                            E = t.modules,
                            T = t.nodeOps;
                        for (w = 0; w < br.length; ++w)
                            for (M[br[w]] = [], _ = 0; _ < E.length; ++_) n(E[_][br[w]]) && M[br[w]].push(E[_][br[w]]);
                        var S = u("attrs,class,staticClass,staticStyle,key");
                        return function(t, r, a, s, c, l) {
                            if (!e(r)) {
                                var u = !1,
                                    d = [];
                                if (e(t)) u = !0, o(r, d, c, l);
                                else {
                                    var p = n(t.nodeType);
                                    if (!p && Gt(t, r)) y(t, r, d, s);
                                    else {
                                        if (p) {
                                            if (1 === t.nodeType && t.hasAttribute(Sn) && (t.removeAttribute(Sn), a = !0), i(a) && b(t, r, d)) return x(r, d, !0), t;
                                            P = t, t = new Qn(T.tagName(P).toLowerCase(), {}, [], void 0, P)
                                        }
                                        var f = t.elm,
                                            g = T.parentNode(f);
                                        if (o(r, d, f._leaveCb ? null : g, T.nextSibling(f)), n(r.parent))
                                            for (var w = r.parent, _ = h(r); w;) {
                                                for (var E = 0; E < M.destroy.length; ++E) M.destroy[E](w);
                                                if (w.elm = r.elm, _) {
                                                    for (var S = 0; S < M.create.length; ++S) M.create[S](xr, w);
                                                    var A = w.data.hook.insert;
                                                    if (A.merged)
                                                        for (var L = 1; L < A.fns.length; L++) A.fns[L]()
                                                } else jt(w);
                                                w = w.parent
                                            }
                                        n(g) ? v(0, [t], 0, 0) : n(t.tag) && m(t)
                                    }
                                }
                                return x(r, d, u), r.elm
                            }
                            var P;
                            n(t) && m(t)
                        }
                    }({
                        nodeOps: gr,
                        modules: [Er, Tr, Pr, Cr, kr, On ? {
                            create: Oe,
                            activate: Oe,
                            remove: function(t, e) {
                                !0 !== t.data.show ? Pe(t, e) : e()
                            }
                        } : {}].concat(Mr)
                    });
                kn && document.addEventListener("selectionchange", function() {
                    var t = document.activeElement;
                    t && t.vmodel && ze(t, "input")
                });
                var $r = {
                        inserted: function(t, e, n, i) {
                            "select" === n.tag ? (i.elm && !i.elm._vOptions ? Y(n, "postpatch", function() {
                                $r.componentUpdated(t, e, n)
                            }) : Ie(t, e, n.context), t._vOptions = [].map.call(t.options, Ue)) : ("textarea" === n.tag || vr(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener("change", Fe), zn || (t.addEventListener("compositionstart", ke), t.addEventListener("compositionend", Fe)), kn && (t.vmodel = !0)))
                        },
                        componentUpdated: function(t, e, n) {
                            if ("select" === n.tag) {
                                Ie(t, e, n.context);
                                var i = t._vOptions,
                                    r = t._vOptions = [].map.call(t.options, Ue);
                                r.some(function(t, e) {
                                    return !x(t, i[e])
                                }) && (t.multiple ? e.value.some(function(t) {
                                    return De(t, r)
                                }) : e.value !== e.oldValue && De(e.value, r)) && ze(t, "change")
                            }
                        }
                    },
                    Zr = {
                        model: $r,
                        show: {
                            bind: function(t, e, n) {
                                var i = e.value,
                                    r = (n = Be(n)).data && n.data.transition,
                                    a = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display;
                                i && r ? (n.data.show = !0, Le(n, function() {
                                    t.style.display = a
                                })) : t.style.display = i ? a : "none"
                            },
                            update: function(t, e, n) {
                                var i = e.value;
                                i !== e.oldValue && ((n = Be(n)).data && n.data.transition ? (n.data.show = !0, i ? Le(n, function() {
                                    t.style.display = t.__vOriginalDisplay
                                }) : Pe(n, function() {
                                    t.style.display = "none"
                                })) : t.style.display = i ? t.__vOriginalDisplay : "none")
                            },
                            unbind: function(t, e, n, i, r) {
                                r || (t.style.display = t.__vOriginalDisplay)
                            }
                        }
                    },
                    Jr = {
                        name: String,
                        appear: Boolean,
                        css: Boolean,
                        mode: String,
                        type: String,
                        enterClass: String,
                        leaveClass: String,
                        enterToClass: String,
                        leaveToClass: String,
                        enterActiveClass: String,
                        leaveActiveClass: String,
                        appearClass: String,
                        appearActiveClass: String,
                        appearToClass: String,
                        duration: [Number, String, Object]
                    },
                    Kr = {
                        name: "transition",
                        props: Jr,
                        abstract: !0,
                        render: function(t) {
                            var e, n, i = this,
                                a = this.$slots.default;
                            if (a && (a = a.filter(function(t) {
                                    return t.tag || K(t)
                                })).length) {
                                var o = this.mode,
                                    s = a[0];
                                if (function(t) {
                                        for (; t = t.parent;)
                                            if (t.data.transition) return !0
                                    }(this.$vnode)) return s;
                                var c = je(s);
                                if (!c) return s;
                                if (this._leaving) return He(t, s);
                                var l = "__transition-" + this._uid + "-";
                                c.key = null == c.key ? c.isComment ? l + "comment" : l + c.tag : r(c.key) ? 0 === String(c.key).indexOf(l) ? c.key : l + c.key : c.key;
                                var u = (c.data || (c.data = {})).transition = Ge(this),
                                    h = this._vnode,
                                    d = je(h);
                                if (c.data.directives && c.data.directives.some(function(t) {
                                        return "show" === t.name
                                    }) && (c.data.show = !0), d && d.data && (e = c, (n = d).key !== e.key || n.tag !== e.tag) && !K(d) && (!d.componentInstance || !d.componentInstance._vnode.isComment)) {
                                    var p = d.data.transition = v({}, u);
                                    if ("out-in" === o) return this._leaving = !0, Y(p, "afterLeave", function() {
                                        i._leaving = !1, i.$forceUpdate()
                                    }), He(t, s);
                                    if ("in-out" === o) {
                                        if (K(c)) return h;
                                        var f, m = function() {
                                            f()
                                        };
                                        Y(u, "afterEnter", m), Y(u, "enterCancelled", m), Y(p, "delayLeave", function(t) {
                                            f = t
                                        })
                                    }
                                }
                                return s
                            }
                        }
                    },
                    Qr = v({
                        tag: String,
                        moveClass: String
                    }, Jr);
                delete Qr.mode;
                var ta = {
                    Transition: Kr,
                    TransitionGroup: {
                        props: Qr,
                        render: function(t) {
                            for (var e = this.tag || this.$vnode.data.tag || "span", n = Object.create(null), i = this.prevChildren = this.children, r = this.$slots.default || [], a = this.children = [], o = Ge(this), s = 0; s < r.length; s++) {
                                var c = r[s];
                                c.tag && null != c.key && 0 !== String(c.key).indexOf("__vlist") && (a.push(c), n[c.key] = c, (c.data || (c.data = {})).transition = o)
                            }
                            if (i) {
                                for (var l = [], u = [], h = 0; h < i.length; h++) {
                                    var d = i[h];
                                    d.data.transition = o, d.data.pos = d.elm.getBoundingClientRect(), n[d.key] ? l.push(d) : u.push(d)
                                }
                                this.kept = t(e, null, l), this.removed = u
                            }
                            return t(e, null, a)
                        },
                        beforeUpdate: function() {
                            this.__patch__(this._vnode, this.kept, !1, !0), this._vnode = this.kept
                        },
                        updated: function() {
                            var t = this.prevChildren,
                                e = this.moveClass || (this.name || "v") + "-move";
                            t.length && this.hasMove(t[0].elm, e) && (t.forEach(Ve), t.forEach(We), t.forEach(Xe), this._reflow = document.body.offsetHeight, t.forEach(function(t) {
                                if (t.data.moved) {
                                    var n = t.elm,
                                        i = n.style;
                                    _e(n, e), i.transform = i.WebkitTransform = i.transitionDuration = "", n.addEventListener(Hr, n._moveCb = function t(i) {
                                        i && !/transform$/.test(i.propertyName) || (n.removeEventListener(Hr, t), n._moveCb = null, Me(n, e))
                                    })
                                }
                            }))
                        },
                        methods: {
                            hasMove: function(t, e) {
                                if (!zr) return !1;
                                if (this._hasMove) return this._hasMove;
                                var n = t.cloneNode();
                                t._transitionClasses && t._transitionClasses.forEach(function(t) {
                                    xe(n, t)
                                }), ye(n, e), n.style.display = "none", this.$el.appendChild(n);
                                var i = Te(n);
                                return this.$el.removeChild(n), this._hasMove = i.hasTransform
                            }
                        }
                    }
                };
                Rt.config.mustUseProp = rr, Rt.config.isReservedTag = fr, Rt.config.isReservedAttr = nr, Rt.config.getTagNamespace = zt, Rt.config.isUnknownElement = function(t) {
                    if (!On) return !0;
                    if (fr(t)) return !1;
                    if (t = t.toLowerCase(), null != mr[t]) return mr[t];
                    var e = document.createElement(t);
                    return t.indexOf("-") > -1 ? mr[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : mr[t] = /HTMLUnknownElement/.test(e.toString())
                }, v(Rt.options.directives, Zr), v(Rt.options.components, ta), Rt.prototype.__patch__ = On ? Yr : y, Rt.prototype.$mount = function(t, e) {
                    return t = t && On ? Bt(t) : void 0, i = t, r = e, (n = this).$el = i, n.$options.render || (n.$options.render = ei), ct(n, "beforeMount"), new Li(n, function() {
                        n._update(n._render(), r)
                    }, y, null, !0), r = !1, null == n.$vnode && (n._isMounted = !0, ct(n, "mounted")), n;
                    var n, i, r
                }, Rt.nextTick(function() {
                    Pn.devtools && qn && qn.emit("init", Rt)
                }, 0);
                var ea, na = /\{\{((?:.|\n)+?)\}\}/g,
                    ia = /[-.*+?^${}()|[\]\/\\]/g,
                    ra = p(function(t) {
                        var e = t[0].replace(ia, "\\$&"),
                            n = t[1].replace(ia, "\\$&");
                        return new RegExp(e + "((?:.|\\n)+?)" + n, "g")
                    }),
                    aa = {
                        staticKeys: ["staticClass"],
                        transformNode: function(t, e) {
                            e.warn;
                            var n = re(t, "class");
                            n && (t.staticClass = JSON.stringify(n));
                            var i = ie(t, "class", !1);
                            i && (t.classBinding = i)
                        },
                        genData: function(t) {
                            var e = "";
                            return t.staticClass && (e += "staticClass:" + t.staticClass + ","), t.classBinding && (e += "class:" + t.classBinding + ","), e
                        }
                    },
                    oa = {
                        staticKeys: ["staticStyle"],
                        transformNode: function(t, e) {
                            e.warn;
                            var n = re(t, "style");
                            n && (t.staticStyle = JSON.stringify(Rr(n)));
                            var i = ie(t, "style", !1);
                            i && (t.styleBinding = i)
                        },
                        genData: function(t) {
                            var e = "";
                            return t.staticStyle && (e += "staticStyle:" + t.staticStyle + ","), t.styleBinding && (e += "style:(" + t.styleBinding + "),"), e
                        }
                    },
                    sa = u("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),
                    ca = u("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),
                    la = u("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),
                    ua = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
                    ha = "[a-zA-Z_][\\w\\-\\.]*",
                    da = "((?:" + ha + "\\:)?" + ha + ")",
                    pa = new RegExp("^<" + da),
                    fa = /^\s*(\/?)>/,
                    ma = new RegExp("^<\\/" + da + "[^>]*>"),
                    va = /^<!DOCTYPE [^>]+>/i,
                    ga = /^<!--/,
                    ya = /^<!\[/,
                    xa = !1;
                "x".replace(/x(.)?/g, function(t, e) {
                    xa = "" === e
                });
                var ba, wa, _a, Ma, Ea, Ta, Sa, Aa, La, Pa, Ca, Ra, Oa = u("script,style,textarea", !0),
                    Ia = {},
                    Na = {
                        "&lt;": "<",
                        "&gt;": ">",
                        "&quot;": '"',
                        "&amp;": "&",
                        "&#10;": "\n",
                        "&#9;": "\t"
                    },
                    Da = /&(?:lt|gt|quot|amp);/g,
                    Ua = /&(?:lt|gt|quot|amp|#10|#9);/g,
                    ka = u("pre,textarea", !0),
                    Fa = function(t, e) {
                        return t && ka(t) && "\n" === e[0]
                    },
                    za = /^@|^v-on:/,
                    Ba = /^v-|^@|^:/,
                    ja = /(.*?)\s+(?:in|of)\s+(.*)/,
                    Ga = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
                    Ha = /^\(|\)$/g,
                    Va = /:(.*)$/,
                    Wa = /^:|^v-bind:/,
                    Xa = /\.[^.]+/g,
                    qa = p(function(t) {
                        return (ea = ea || document.createElement("div")).innerHTML = t, ea.textContent
                    }),
                    Ya = /^xmlns:NS\d+/,
                    $a = /^NS\d+:/,
                    Za = [aa, oa, {
                        preTransformNode: function(t, e) {
                            if ("input" === t.tag) {
                                var n = t.attrsMap;
                                if (n["v-model"] && (n["v-bind:type"] || n[":type"])) {
                                    var i = ie(t, "type"),
                                        r = re(t, "v-if", !0),
                                        a = r ? "&&(" + r + ")" : "",
                                        o = null != re(t, "v-else", !0),
                                        s = re(t, "v-else-if", !0),
                                        c = Je(t);
                                    $e(c), ee(c, "type", "checkbox"), Ye(c, e), c.processed = !0, c.if = "(" + i + ")==='checkbox'" + a, Ze(c, {
                                        exp: c.if,
                                        block: c
                                    });
                                    var l = Je(t);
                                    re(l, "v-for", !0), ee(l, "type", "radio"), Ye(l, e), Ze(c, {
                                        exp: "(" + i + ")==='radio'" + a,
                                        block: l
                                    });
                                    var u = Je(t);
                                    return re(u, "v-for", !0), ee(u, ":type", i), Ye(u, e), Ze(c, {
                                        exp: r,
                                        block: u
                                    }), o ? c.else = !0 : s && (c.elseif = s), c
                                }
                            }
                        }
                    }],
                    Ja = {
                        expectHTML: !0,
                        modules: Za,
                        directives: {
                            model: function(t, e, n) {
                                var i, r, a, o, s, c, l, u, h, d, p, f, m, v = e.value,
                                    g = e.modifiers,
                                    y = t.tag,
                                    x = t.attrsMap.type;
                                if (t.component) return ae(t, v, g), !1;
                                if ("select" === y) p = t, f = v, m = 'var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ' + (g && g.number ? "_n(val)" : "val") + "});", ne(p, "change", m = m + " " + oe(f, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]"), null, !0);
                                else if ("input" === y && "checkbox" === x) s = t, c = v, l = g && g.number, u = ie(s, "value") || "null", h = ie(s, "true-value") || "true", d = ie(s, "false-value") || "false", Qt(s, "checked", "Array.isArray(" + c + ")?_i(" + c + "," + u + ")>-1" + ("true" === h ? ":(" + c + ")" : ":_q(" + c + "," + h + ")")), ne(s, "change", "var $$a=" + c + ",$$el=$event.target,$$c=$$el.checked?(" + h + "):(" + d + ");if(Array.isArray($$a)){var $$v=" + (l ? "_n(" + u + ")" : u) + ",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(" + c + "=$$a.concat([$$v]))}else{$$i>-1&&(" + c + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{" + oe(c, "$$c") + "}", null, !0);
                                else if ("input" === y && "radio" === x) i = t, r = v, a = g && g.number, o = ie(i, "value") || "null", Qt(i, "checked", "_q(" + r + "," + (o = a ? "_n(" + o + ")" : o) + ")"), ne(i, "change", oe(r, o), null, !0);
                                else if ("input" === y || "textarea" === y) ! function(t, e, n) {
                                    var i = t.attrsMap.type,
                                        r = n || {},
                                        a = r.lazy,
                                        o = r.number,
                                        s = r.trim,
                                        c = !a && "range" !== i,
                                        l = a ? "change" : "range" === i ? Ar : "input",
                                        u = "$event.target.value";
                                    s && (u = "$event.target.value.trim()"), o && (u = "_n(" + u + ")");
                                    var h = oe(e, u);
                                    c && (h = "if($event.target.composing)return;" + h), Qt(t, "value", "(" + e + ")"), ne(t, l, h, null, !0), (s || o) && ne(t, "blur", "$forceUpdate()")
                                }(t, v, g);
                                else if (!Pn.isReservedTag(y)) return ae(t, v, g), !1;
                                return !0
                            },
                            text: function(t, e) {
                                e.value && Qt(t, "textContent", "_s(" + e.value + ")")
                            },
                            html: function(t, e) {
                                e.value && Qt(t, "innerHTML", "_s(" + e.value + ")")
                            }
                        },
                        isPreTag: function(t) {
                            return "pre" === t
                        },
                        isUnaryTag: sa,
                        mustUseProp: rr,
                        canBeLeftOpenTag: ca,
                        isReservedTag: fr,
                        getTagNamespace: zt,
                        staticKeys: Za.reduce(function(t, e) {
                            return t.concat(e.staticKeys || [])
                        }, []).join(",")
                    },
                    Ka = p(function(t) {
                        return u("type,tag,attrsList,attrsMap,plain,parent,children,attrs" + (t ? "," + t : ""))
                    }),
                    Qa = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/,
                    to = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/,
                    eo = {
                        esc: 27,
                        tab: 9,
                        enter: 13,
                        space: 32,
                        up: 38,
                        left: 37,
                        right: 39,
                        down: 40,
                        delete: [8, 46]
                    },
                    no = function(t) {
                        return "if(" + t + ")return null;"
                    },
                    io = {
                        stop: "$event.stopPropagation();",
                        prevent: "$event.preventDefault();",
                        self: no("$event.target !== $event.currentTarget"),
                        ctrl: no("!$event.ctrlKey"),
                        shift: no("!$event.shiftKey"),
                        alt: no("!$event.altKey"),
                        meta: no("!$event.metaKey"),
                        left: no("'button' in $event && $event.button !== 0"),
                        middle: no("'button' in $event && $event.button !== 1"),
                        right: no("'button' in $event && $event.button !== 2")
                    },
                    ro = {
                        on: function(t, e) {
                            t.wrapListeners = function(t) {
                                return "_g(" + t + "," + e.value + ")"
                            }
                        },
                        bind: function(t, e) {
                            t.wrapData = function(n) {
                                return "_b(" + n + ",'" + t.tag + "'," + e.value + "," + (e.modifiers && e.modifiers.prop ? "true" : "false") + (e.modifiers && e.modifiers.sync ? ",true" : "") + ")"
                            }
                        },
                        cloak: y
                    },
                    ao = function(t) {
                        this.options = t, this.warn = t.warn || Jt, this.transforms = Kt(t.modules, "transformCode"), this.dataGenFns = Kt(t.modules, "genData"), this.directives = v(v({}, ro), t.directives);
                        var e = t.isReservedTag || En;
                        this.maybeComponent = function(t) {
                            return !e(t.tag)
                        }, this.onceId = 0, this.staticRenderFns = []
                    },
                    oo = (new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b") + "\\b"), new RegExp("\\b" + "delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b") + "\\s*\\([^\\)]*\\)"), (Ra = function(t, e) {
                        var n, i, r = function(t, e) {
                            function n(t) {
                                t.pre && (s = !1), Ta(t.tag) && (c = !1);
                                for (var n = 0; n < Ea.length; n++) Ea[n](t, e)
                            }
                            ba = e.warn || Jt, Ta = e.isPreTag || En, Sa = e.mustUseProp || En, Aa = e.getTagNamespace || En, _a = Kt(e.modules, "transformNode"), Ma = Kt(e.modules, "preTransformNode"), Ea = Kt(e.modules, "postTransformNode"), wa = e.delimiters;
                            var i, r, a = [],
                                o = !1 !== e.preserveWhitespace,
                                s = !1,
                                c = !1;
                            return function(t, e) {
                                function n(e) {
                                    u += e, t = t.substring(e)
                                }
  
                                function i(t, n, i) {
                                    var r, s;
                                    if (null == n && (n = u), null == i && (i = u), t && (s = t.toLowerCase()), t)
                                        for (r = o.length - 1; r >= 0 && o[r].lowerCasedTag !== s; r--);
                                    else r = 0;
                                    if (r >= 0) {
                                        for (var c = o.length - 1; c >= r; c--) e.end && e.end(o[c].tag, n, i);
                                        o.length = r, a = r && o[r - 1].tag
                                    } else "br" === s ? e.start && e.start(t, [], !0, n, i) : "p" === s && (e.start && e.start(t, [], !1, n, i), e.end && e.end(t, n, i))
                                }
                                for (var r, a, o = [], s = e.expectHTML, c = e.isUnaryTag || En, l = e.canBeLeftOpenTag || En, u = 0; t;) {
                                    if (r = t, a && Oa(a)) {
                                        var h = 0,
                                            d = a.toLowerCase(),
                                            p = Ia[d] || (Ia[d] = new RegExp("([\\s\\S]*?)(</" + d + "[^>]*>)", "i")),
                                            f = t.replace(p, function(t, n, i) {
                                                return h = i.length, Oa(d) || "noscript" === d || (n = n.replace(/<!--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), Fa(d, n) && (n = n.slice(1)), e.chars && e.chars(n), ""
                                            });
                                        u += t.length - f.length, t = f, i(d, u - h, u)
                                    } else {
                                        var m = t.indexOf("<");
                                        if (0 === m) {
                                            if (ga.test(t)) {
                                                var v = t.indexOf("--\x3e");
                                                if (v >= 0) {
                                                    e.shouldKeepComment && e.comment(t.substring(4, v)), n(v + 3);
                                                    continue
                                                }
                                            }
                                            if (ya.test(t)) {
                                                var g = t.indexOf("]>");
                                                if (g >= 0) {
                                                    n(g + 2);
                                                    continue
                                                }
                                            }
                                            var y = t.match(va);
                                            if (y) {
                                                n(y[0].length);
                                                continue
                                            }
                                            var x = t.match(ma);
                                            if (x) {
                                                var b = u;
                                                n(x[0].length), i(x[1], b, u);
                                                continue
                                            }
                                            var w = function() {
                                                var e = t.match(pa);
                                                if (e) {
                                                    var i, r, a = {
                                                        tagName: e[1],
                                                        attrs: [],
                                                        start: u
                                                    };
                                                    for (n(e[0].length); !(i = t.match(fa)) && (r = t.match(ua));) n(r[0].length), a.attrs.push(r);
                                                    if (i) return a.unarySlash = i[1], n(i[0].length), a.end = u, a
                                                }
                                            }();
                                            if (w) {
                                                ! function(t) {
                                                    var n, r, u, h = t.tagName,
                                                        d = t.unarySlash;
                                                    s && ("p" === a && la(h) && i(a), l(h) && a === h && i(h));
                                                    for (var p = c(h) || !!d, f = t.attrs.length, m = new Array(f), v = 0; v < f; v++) {
                                                        var g = t.attrs[v];
                                                        xa && -1 === g[0].indexOf('""') && ("" === g[3] && delete g[3], "" === g[4] && delete g[4], "" === g[5] && delete g[5]);
                                                        var y = g[3] || g[4] || g[5] || "",
                                                            x = "a" === h && "href" === g[1] ? e.shouldDecodeNewlinesForHref : e.shouldDecodeNewlines;
                                                        m[v] = {
                                                            name: g[1],
                                                            value: (n = y, r = x, u = r ? Ua : Da, n.replace(u, function(t) {
                                                                return Na[t]
                                                            }))
                                                        }
                                                    }
                                                    p || (o.push({
                                                        tag: h,
                                                        lowerCasedTag: h.toLowerCase(),
                                                        attrs: m
                                                    }), a = h), e.start && e.start(h, m, p, t.start, t.end)
                                                }(w), Fa(a, t) && n(1);
                                                continue
                                            }
                                        }
                                        var _ = void 0,
                                            M = void 0,
                                            E = void 0;
                                        if (m >= 0) {
                                            for (M = t.slice(m); !(ma.test(M) || pa.test(M) || ga.test(M) || ya.test(M) || (E = M.indexOf("<", 1)) < 0);) m += E, M = t.slice(m);
                                            _ = t.substring(0, m), n(m)
                                        }
                                        m < 0 && (_ = t, t = ""), e.chars && _ && e.chars(_)
                                    }
                                    if (t === r) {
                                        e.chars && e.chars(t);
                                        break
                                    }
                                }
                                i()
                            }(t, {
                                warn: ba,
                                expectHTML: e.expectHTML,
                                isUnaryTag: e.isUnaryTag,
                                canBeLeftOpenTag: e.canBeLeftOpenTag,
                                shouldDecodeNewlines: e.shouldDecodeNewlines,
                                shouldDecodeNewlinesForHref: e.shouldDecodeNewlinesForHref,
                                shouldKeepComment: e.comments,
                                start: function(t, o, l) {
                                    var u = r && r.ns || Aa(t);
                                    Un && "svg" === u && (o = function(t) {
                                        for (var e = [], n = 0; n < t.length; n++) {
                                            var i = t[n];
                                            Ya.test(i.name) || (i.name = i.name.replace($a, ""), e.push(i))
                                        }
                                        return e
                                    }(o));
                                    var h, d, p, f, m, v = qe(t, o, r);
                                    u && (v.ns = u), !("style" !== (h = v).tag && ("script" !== h.tag || h.attrsMap.type && "text/javascript" !== h.attrsMap.type) || Xn()) && (v.forbidden = !0);
                                    for (var g = 0; g < Ma.length; g++) v = Ma[g](v, e) || v;
                                    if (s || (null != re(m = v, "v-pre") && (m.pre = !0), v.pre && (s = !0)), Ta(v.tag) && (c = !0), s ? function(t) {
                                            var e = t.attrsList.length;
                                            if (e)
                                                for (var n = t.attrs = new Array(e), i = 0; i < e; i++) n[i] = {
                                                    name: t.attrsList[i].name,
                                                    value: JSON.stringify(t.attrsList[i].value)
                                                };
                                            else t.pre || (t.plain = !0)
                                        }(v) : v.processed || ($e(v), function(t) {
                                            var e = re(t, "v-if");
                                            if (e) t.if = e, Ze(t, {
                                                exp: e,
                                                block: t
                                            });
                                            else {
                                                null != re(t, "v-else") && (t.else = !0);
                                                var n = re(t, "v-else-if");
                                                n && (t.elseif = n)
                                            }
                                        }(v), null != re(f = v, "v-once") && (f.once = !0), Ye(v, e)), i ? a.length || i.if && (v.elseif || v.else) && Ze(i, {
                                            exp: v.elseif,
                                            block: v
                                        }) : i = v, r && !v.forbidden)
                                        if (v.elseif || v.else) d = v, (p = function(t) {
                                            for (var e = t.length; e--;) {
                                                if (1 === t[e].type) return t[e];
                                                t.pop()
                                            }
                                        }(r.children)) && p.if && Ze(p, {
                                            exp: d.elseif,
                                            block: d
                                        });
                                        else if (v.slotScope) {
                                        r.plain = !1;
                                        var y = v.slotTarget || '"default"';
                                        (r.scopedSlots || (r.scopedSlots = {}))[y] = v
                                    } else r.children.push(v), v.parent = r;
                                    l ? n(v) : (r = v, a.push(v))
                                },
                                end: function() {
                                    var t = a[a.length - 1],
                                        e = t.children[t.children.length - 1];
                                    e && 3 === e.type && " " === e.text && !c && t.children.pop(), a.length -= 1, r = a[a.length - 1], n(t)
                                },
                                chars: function(t) {
                                    if (r && (!Un || "textarea" !== r.tag || r.attrsMap.placeholder !== t)) {
                                        var e, n = r.children;
                                        (t = c || t.trim() ? "script" === (i = r).tag || "style" === i.tag ? t : qa(t) : o && n.length ? " " : "") && (!s && " " !== t && (e = function(t, e) {
                                            var n = wa ? ra(wa) : na;
                                            if (n.test(t)) {
                                                for (var i, r, a, o = [], s = [], c = n.lastIndex = 0; i = n.exec(t);) {
                                                    (r = i.index) > c && (s.push(a = t.slice(c, r)), o.push(JSON.stringify(a)));
                                                    var l = Zt(i[1].trim());
                                                    o.push("_s(" + l + ")"), s.push({
                                                        "@binding": l
                                                    }), c = r + i[0].length
                                                }
                                                return c < t.length && (s.push(a = t.slice(c)), o.push(JSON.stringify(a))), {
                                                    expression: o.join("+"),
                                                    tokens: s
                                                }
                                            }
                                        }(t)) ? n.push({
                                            type: 2,
                                            expression: e.expression,
                                            tokens: e.tokens,
                                            text: t
                                        }) : " " === t && n.length && " " === n[n.length - 1].text || n.push({
                                            type: 3,
                                            text: t
                                        }))
                                    }
                                    var i
                                },
                                comment: function(t) {
                                    r.children.push({
                                        type: 3,
                                        text: t,
                                        isComment: !0
                                    })
                                }
                            }), i
                        }(t.trim(), e);
                        !1 !== e.optimize && (i = e, (n = r) && (La = Ka(i.staticKeys || ""), Pa = i.isReservedTag || En, function t(e) {
                            if (e.static = 2 !== (c = e).type && (3 === c.type || !(!c.pre && (c.hasBindings || c.if || c.for || vn(c.tag) || !Pa(c.tag) || function(t) {
                                    for (; t.parent;) {
                                        if ("template" !== (t = t.parent).tag) return !1;
                                        if (t.for) return !0
                                    }
                                    return !1
                                }(c) || !Object.keys(c).every(La)))), 1 === e.type) {
                                if (!Pa(e.tag) && "slot" !== e.tag && null == e.attrsMap["inline-template"]) return;
                                for (var n = 0, i = e.children.length; n < i; n++) {
                                    var r = e.children[n];
                                    t(r), r.static || (e.static = !1)
                                }
                                if (e.ifConditions)
                                    for (var a = 1, o = e.ifConditions.length; a < o; a++) {
                                        var s = e.ifConditions[a].block;
                                        t(s), s.static || (e.static = !1)
                                    }
                            }
                            var c
                        }(n), function t(e, n) {
                            if (1 === e.type) {
                                if ((e.static || e.once) && (e.staticInFor = n), e.static && e.children.length && (1 !== e.children.length || 3 !== e.children[0].type)) return void(e.staticRoot = !0);
                                if (e.staticRoot = !1, e.children)
                                    for (var i = 0, r = e.children.length; i < r; i++) t(e.children[i], n || !!e.for);
                                if (e.ifConditions)
                                    for (var a = 1, o = e.ifConditions.length; a < o; a++) t(e.ifConditions[a].block, n)
                            }
                        }(n, !1)));
                        var a = en(r, e);
                        return {
                            ast: r,
                            render: a.render,
                            staticRenderFns: a.staticRenderFns
                        }
                    }, function(t) {
                        function e(e, n) {
                            var i = Object.create(t),
                                r = [],
                                a = [];
                            if (i.warn = function(t, e) {
                                    (e ? a : r).push(t)
                                }, n)
                                for (var o in n.modules && (i.modules = (t.modules || []).concat(n.modules)), n.directives && (i.directives = v(Object.create(t.directives || null), n.directives)), n) "modules" !== o && "directives" !== o && (i[o] = n[o]);
                            var s = Ra(e, i);
                            return s.errors = r, s.tips = a, s
                        }
                        return {
                            compile: e,
                            compileToFunctions: (n = e, i = Object.create(null), function(t, e, r) {
                                (e = v({}, e)).warn, delete e.warn;
                                var a = e.delimiters ? String(e.delimiters) + t : t;
                                if (i[a]) return i[a];
                                var o = n(t, e),
                                    s = {},
                                    c = [];
                                return s.render = dn(o.render, c), s.staticRenderFns = o.staticRenderFns.map(function(t) {
                                    return dn(t, c)
                                }), i[a] = s
                            })
                        };
                        var n, i
                    })(Ja).compileToFunctions),
                    so = !!On && pn(!1),
                    co = !!On && pn(!0),
                    lo = p(function(t) {
                        var e = Bt(t);
                        return e && e.innerHTML
                    }),
                    uo = Rt.prototype.$mount;
                return Rt.prototype.$mount = function(t, e) {
                    if ((t = t && Bt(t)) === document.body || t === document.documentElement) return this;
                    var n = this.$options;
                    if (!n.render) {
                        var i = n.template;
                        if (i)
                            if ("string" == typeof i) "#" === i.charAt(0) && (i = lo(i));
                            else {
                                if (!i.nodeType) return this;
                                i = i.innerHTML
                            } else t && (i = function(t) {
                            if (t.outerHTML) return t.outerHTML;
                            var e = document.createElement("div");
                            return e.appendChild(t.cloneNode(!0)), e.innerHTML
                        }(t));
                        if (i) {
                            var r = oo(i, {
                                    shouldDecodeNewlines: so,
                                    shouldDecodeNewlinesForHref: co,
                                    delimiters: n.delimiters,
                                    comments: n.comments
                                }, this),
                                a = r.render,
                                o = r.staticRenderFns;
                            n.render = a, n.staticRenderFns = o
                        }
                    }
                    return uo.call(this, t, e)
                }, Rt.compile = oo, Rt
            }, "object" == typeof n && void 0 !== e ? e.exports = r() : "function" == typeof define && define.amd ? define(r) : i.Vue = r()
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    13: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = function() {
            function t(e, n) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "#47c";
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.message = e, this.url = n, this.color = i, this.show()
            }
            return i(t, [{
                key: "show",
                value: function() {
                    if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                        var t = ["%c " + this.message + " %c " + this.url + " \n", "color: #fff; background: " + this.color + "; padding:3px 0;", "padding:3px 1px;"];
                        console.log.apply(console, t)
                    } else window.console && console.log(this.message + " " + this.url)
                }
            }]), t
        }();
        n.default = r
    }, {}],
    14: [function(t, e, n) {
        "use strict";
        var i = t("viewport-units-buggyfill"),
            r = t("./pc/modules/background/Background").default,
            a = t("./pc/modules/smooth_scroll_manager/SmoothScrollManager").default,
            o = t("./pc/modules/Pjax").default,
            s = t("./pc/modules/common/buildContactDialog").default,
            c = new r,
            l = new o(new a(c), c),
            u = s(),
            h = window.navigator.userAgent,
            d = document.querySelector("link[as=style]");
        (h.indexOf("Edge") > -1 || h.indexOf("Chrome") < 0) && (d.rel = "stylesheet"), setTimeout(function() {
            i.init(), l.onLoad(), c.init(function() {
                u.show(), l.start()
            })
        }, 100)
    }, {
        "./pc/modules/Pjax": 23,
        "./pc/modules/background/Background": 24,
        "./pc/modules/common/buildContactDialog": 35,
        "./pc/modules/smooth_scroll_manager/SmoothScrollManager": 49,
        "viewport-units-buggyfill": 11
    }],
    15: [function(t, e, n) {
        "use strict";
        e.exports = {
            initBeforeTransit: function(t, e) {},
            initAfterTransit: function(t, e) {},
            clear: function() {}
        }
    }, {}],
    16: [function(t, e, n) {
        "use strict";
        var i = t("js-util/Hover"),
            r = t("../modules/common/CustomCursorLink").default;
        e.exports = {
            initBeforeTransit: function(t, e, n) {
                for (var a = t.querySelectorAll(".js-hover"), o = 0; o < a.length; o++) new i(a[o]);
                var s = t.querySelectorAll(".js-cc-link");
                for (o = 0; o < s.length; o++) new r(s[o], n.cursor)
            },
            initAfterTransit: function(t, e) {}
        }
    }, {
        "../modules/common/CustomCursorLink": 32,
        "js-util/Hover": 4
    }],
    17: [function(t, e, n) {
        "use strict";
        var i = t("../modules/culture/buildCulture").default,
            r = t("js-util/MathEx"),
            a = null;
        e.exports = {
            initBeforeTransit: function(t, e) {},
            initAfterTransit: function(t, e) {
                i(e).then(function(t) {
                    a = t(), e.progressCircle.drag = function(t) {
                        a.showItemId = -1, a.zAnchor = r.clamp(30 * (t - e.progressCircle.mouseDownY) + a.zAnchorPrev, 0, 300 * a.max), e.progressCircle.updateProgress(Math.round(a.zAnchor / 300), a.max)
                    }, e.progressCircle.dragEnd = function(t) {
                        a.zAnchorPrev = a.zAnchor
                    }
                })
            },
            clear: function(t) {
                a && a.stop(), null, a = null, t.progressCircle.drag = null, t.progressCircle.dragEnd = null
            }
        }
    }, {
        "../modules/culture/buildCulture": 40,
        "js-util/MathEx": 5
    }],
    18: [function(t, e, n) {
        "use strict";
        var i = t("js-util/MathEx"),
            r = t("../modules/index/buildChooseYourLife").default,
            a = t("../modules/index/IndexContent").default,
            o = null,
            s = null,
            c = null,
            l = null;
        e.exports = {
            initBeforeTransit: function(t, e) {
                o = r(t, e), s = new a(t, e), e.progressCircle.drag = function(t) {
                    s.sectionIndex = i.clamp(Math.floor((t - e.progressCircle.mouseDownY) / 100) + s.sectionIndexPrev, 0, s.sectionMax), s.switchSection(), e.progressCircle.updateProgress(s.sectionIndex, s.sectionMax)
                }, e.progressCircle.dragEnd = function(t) {
                    s.sectionIndexPrev = s.sectionIndex
                }, e.scrollManager.renderNext = function() {
                    s.render()
                }, c = document.querySelector(".js-global-logo"), l = function() {
                    1 !== e.gNav.isOpenedNavi && (s.sectionIndex = 0, s.switchSection())
                }, c.addEventListener("click", l)
            },
            initAfterTransit: function(t, e) {
                setTimeout(function() {
                    o.start()
                }, 1e3)
            },
            clear: function(t) {
                c.removeEventListener("click", l), o = null, s = null, c = null, l = null, t.progressCircle.drag = null, t.progressCircle.dragEnd = null
            }
        }
    }, {
        "../modules/index/IndexContent": 41,
        "../modules/index/buildChooseYourLife": 42,
        "js-util/MathEx": 5
    }],
    19: [function(t, e, n) {
        "use strict";
        var i = t("../modules/pride/buildPrideValue").default;
        e.exports = {
            initBeforeTransit: function(t, e) {
                i(e.cursor)
            },
            initAfterTransit: function(t, e) {},
            clear: function() {
                null
            }
        }
    }, {
        "../modules/pride/buildPrideValue": 43
    }],
    20: [function(t, e, n) {
        "use strict";
        var i = t("../../../modules/yankee_intern/Facilities").default,
            r = null;
        e.exports = {
            initBeforeTransit: function(t, e) {
                r = new i(t, e.cursor), e.scrollManager.resizeNext = function() {
                    r.resize()
                };
                var n = t.querySelector(".p-intern-category-kv__wrap");
                e.scrollManager.renderNext = function() {
                    n.style = "transform: rotateX(" + .1 * e.bg.camera.position.y + "deg) rotateY(" + -.15 * e.bg.camera.position.x + "deg)"
                }
            },
            initAfterTransit: function(t, e) {
                r.start()
            },
            clear: function() {
                r = null
            }
        }
    }, {
        "../../../modules/yankee_intern/Facilities": 50
    }],
    21: [function(t, e, n) {
        arguments[4][20][0].apply(n, arguments)
    }, {
        "../../../modules/yankee_intern/Facilities": 50,
        dup: 20
    }],
    22: [function(t, e, n) {
        "use strict";
        var i = t("../../modules/index/buildChooseYourLife").default,
            r = null;
        e.exports = {
            initBeforeTransit: function(t, e) {
                r = i(t, e), e.scrollManager.renderNext = function() {
                    r.render()
                }
            },
            initAfterTransit: function(t, e) {
                r.start()
            },
            clear: function() {
                r = null
            }
        }
    }, {
        "../../modules/index/buildChooseYourLife": 42
    }],
    23: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("../../common/ConsoleSignature").default,
            // a = t("./common/buildGlobalNavi").default,
            o = t("./common/buildGlobalCatLabel").default,
            s = t("./common/buildCustomCursor").default,
            c = t("./common/ProgressCircle").default,
            l = ".js-pjax-page",
            u = ".js-pjax-contents",
            h = {
                common: t("../init/common.js"),
                blank: t("../init/blank.js"),
                index: t("../init/index.js"),
                pride: t("../init/pride.js"),
                culture: t("../init/culture.js"),
                yankeeIntern: {
                    index: t("../init/yankee_intern/index.js"),
                    business: {
                        index: t("../init/yankee_intern/business/index.js")
                    },
                    hacker: {
                        index: t("../init/yankee_intern/hacker/index.js")
                    }
                }
            },
            d = (new r("page transition in this website with original pjax module", "https://github.com/ykob/pjax", "#497"), function() {
                function t(e, n) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.scrollManager = e, this.bg = n, this.progressCircle = new c, this.gCatLabel = o(), this.cursor = s(), this.xhr = new XMLHttpRequest, this.elmPage = document.querySelector(l), this.elmContents = document.querySelector(u), this.href = location.pathname + location.search, this.page = null, this.isTransition = !1, this.isPageLoaded = !1, this.on()
                }
                return i(t, [{
                    key: "onLoad",
                    value: function() {
                        var t = this;
                        this.selectPageFunc(), h.common.initBeforeTransit(document, this.isPageLoaded, {
                            bg: this.bg,
                            scrollManager: this.scrollManager,
                            cursor: this.cursor
                        }), this.page.initBeforeTransit(this.elmContents, {
                            bg: this.bg,
                            scrollManager: this.scrollManager,
                            gCatLabel: this.gCatLabel,
                            gNav: this.gNav,
                            cursor: this.cursor,
                            progressCircle: this.progressCircle
                        }), this.scrollManager.start(), setTimeout(function() {
                            t.gNav.isValid = !0, t.progressCircle.init(t.scrollManager, t.gNav, t.cursor), t.switchProgressCircle()
                        }, 400), setTimeout(function() {
                            var e = [document.querySelector(".p-global-logo")];
                            t.gCatLabel.isValid = !0;
                            for (var n = 0; n < e.length; n++) e[n].classList.add("is-shown")
                        }, 800)
                    }
                }, {
                    key: "start",
                    value: function() {
                        this.onPjaxLinks(document), this.elmContents.classList.add("is-arrived"), this.transitEnd(), this.isPageLoaded = !0
                    }
                }, {
                    key: "selectPageFunc",
                    value: function() {
                        switch (this.elmPage.dataset.pageId) {
                            case "index":
                                this.page = h.index, this.gCatLabel.setLabel("top");
                                break;
                            case "pride":
                                this.page = h.pride, this.gCatLabel.setLabel("pride");
                                break;
                            case "culture":
                                this.page = h.culture, this.gCatLabel.setLabel("culture");
                                break;
                            case "yankee_intern":
                                this.page = h.yankeeIntern.index, this.gCatLabel.setLabel("top");
                                break;
                            case "yankee_business":
                                this.page = h.yankeeIntern.business.index, this.gCatLabel.setLabel("business");
                                break;
                            case "yankee_hacker":
                                this.page = h.yankeeIntern.hacker.index, this.gCatLabel.setLabel("hacker");
                                break;
                            case "yankee_business_story01":
                            case "yankee_business_story02":
                            case "yankee_hacker_story01":
                            case "yankee_hacker_story02":
                                this.page = h.blank, this.gCatLabel.setLabel("story");
                                break;
                            case "company":
                                this.page = h.blank, this.gCatLabel.setLabel("company");
                                break;
                            case "privacypolicy":
                                this.page = h.blank, this.gCatLabel.setLabel("privacypolicy");
                                break;
                            default:
                                this.page = h.blank
                        }
                        this.switchProgressCircle()
                    }
                }, {
                    key: "switchProgressCircle",
                    value: function() {
                        switch (this.elmPage.dataset.pageId) {
                            case "index":
                            case "culture":
                                this.progressCircle.switchMode(1);
                                break;
                            default:
                                this.progressCircle.switchMode(0)
                        }
                    }
                }, {
                    key: "send",
                    value: function() {
                        this.scrollManager.off(), this.xhr.open("GET", this.href, !0), this.xhr.send()
                    }
                }, {
                    key: "replaceContent",
                    value: function() {
                        var t = this;
                        this.page.clear({
                            bg: this.bg,
                            scrollManager: this.scrollManager,
                            gCatLabel: this.gCatLabel,
                            cursor: this.cursor,
                            progressCircle: this.progressCircle
                        });
                        var e = this.elmContents;
                        e.classList.remove("js-contents");
                        var n = document.createElement("div");
                        n.innerHTML = this.xhr.responseText;
                        var i = n.querySelector(l),
                            r = n.querySelector(u);
                        this.elmPage.dataset.pageId = i.dataset.pageId, this.elmPage.appendChild(r), this.elmContents = r, document.title = n.querySelector("title").innerHTML, window.scrollTo(0, 0), setTimeout(function() {
                            r.classList.add("is-arrived")
                        }, 100), window.ga && ga("send", "pageview", window.location.pathname.replace(/^\/?/, "/") + window.location.search), this.selectPageFunc(), setTimeout(function() {
                            t.elmPage.removeChild(e)
                        }, 1e3), h.common.initBeforeTransit(this.elmContents, this.isPageLoaded, {
                            scrollManager: this.scrollManager,
                            cursor: this.cursor
                        }), this.page.initBeforeTransit(this.elmContents, {
                            bg: this.bg,
                            scrollManager: this.scrollManager,
                            gCatLabel: this.gCatLabel,
                            gNav: this.gNav,
                            cursor: this.cursor,
                            progressCircle: this.progressCircle
                        }), this.onPjaxLinks(this.elmContents), this.scrollManager.start(function() {
                            t.transitEnd()
                        })
                    }
                }, {
                    key: "transitStart",
                    value: function() {
                        this.isTransition || (this.isTransition = !0, this.scrollManager.pause(), this.gNav.closeNavi(!0), this.href = location.pathname + location.search, this.send(), this.elmContents.classList.add("is-fixed"), this.elmContents.style.transform = "translate3d(0, " + -this.scrollManager.scrollTop + "px, 0)", this.elmContents.classList.remove("is-arrived"), this.elmContents.classList.add("is-leaved"), this.bg.transit())
                    }
                }, {
                    key: "transitEnd",
                    value: function() {
                        this.isTransition = !1, this.href === location.pathname + location.search ? (h.common.initAfterTransit(this.elmContents, {
                            scrollManager: this.scrollManager,
                            cursor: this.cursor
                        }), this.page.initAfterTransit(this.elmContents, {
                            bg: this.bg,
                            scrollManager: this.scrollManager,
                            gCatLabel: this.gCatLabel,
                            cursor: this.cursor,
                            progressCircle: this.progressCircle
                        }), this.progressCircle.wrap.classList.remove("is-opened-gnav"), this.progressCircle.label.classList.remove("is-opened-gnav")) : this.transitStart()
                    }
                }, {
                    key: "on",
                    value: function() {
                        var t = this;
                        this.xhr.onreadystatechange = function() {
                            switch (t.xhr.readyState) {
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                    break;
                                case 4:
                                    switch (t.xhr.status) {
                                        case 200:
                                            t.replaceContent();
                                            break;
                                        case 404:
                                            console.error("Async request by Pjax has error, 404 not found."), t.replaceContent();
                                            break;
                                        case 500:
                                            console.error("Async request by Pjax has error, 500 Internal Server Error.")
                                    }
                            }
                        }, window.addEventListener("popstate", function(e) {
                            e.preventDefault(), history.scrollRestoration = "manual", t.transitStart(!0)
                        })
                    }
                }, {
                    key: "onPjaxLinks",
                    value: function(t, e, n) {
                        for (var i = this, r = [t.getElementsByTagName("a"), e ? e.getElementsByTagName("a") : [], n ? n.getElementsByTagName("a") : []], a = 0; a < r.length; a++)
                            for (var o = function() {
                                    var t = r[a][s],
                                        e = t.getAttribute("href"),
                                        n = t.getAttribute("target");
                                    (t.classList.contains(".js-pjax-link".replace(".", "")) || !e.match(/^http/) && "_blank" !== n) && t.addEventListener("click", function(t) {
                                        var n;
                                        t.preventDefault(), (n = e) != location.pathname + location.search && (history.pushState(null, null, n), i.transitStart())
                                    })
                                }, s = 0; s < r[a].length; s++) o()
                    }
                }]), t
            }());
        n.default = d
    }, {
        "../../common/ConsoleSignature": 13,
        "../init/blank.js": 15,
        "../init/common.js": 16,
        "../init/culture.js": 17,
        "../init/index.js": 18,
        "../init/pride.js": 19,
        "../init/yankee_intern/business/index.js": 20,
        "../init/yankee_intern/hacker/index.js": 21,
        "../init/yankee_intern/index.js": 22,
        "./common/ProgressCircle": 34,
        "./common/buildCustomCursor": 36,
        "./common/buildGlobalCatLabel": 37,
        // "./common/buildGlobalNavi": 38
    }],
    24: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("three/build/three.js"),
            a = t("js-util/MathEx"),
            o = t("js-util/isiOS"),
            s = t("js-util/isAndroid"),
            c = t("../common/easings"),
            l = t("./loadTexs").default,
            u = t("./Logo").default,
            h = t("./Star").default,
            d = t("./StarV").default,
            p = t("./StarFar").default,
            f = t("./Pyramid").default,
            m = t("./Fog").default,
            v = 1.8,
            g = function() {
                function t() {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.resolution = new r.Vector2, this.mousemove = new r.Vector2, this.cameraAnchor = new r.Vector2, this.canvas = document.getElementById("canvas-webgl"), this.renderer = new r.WebGLRenderer({
                        alpha: !0,
                        antialias: !0,
                        canvas: this.canvas
                    }), this.scene = new r.Scene, this.camera = new r.PerspectiveCamera, this.time = 0, this.clock = new r.Clock({
                        autoStart: !1
                    }), this.camera.far = 5e4, this.camera.setFocalLength(35), this.logo = new u, this.star = new h(v), this.starV = new d(v), this.starFar = new p(v), this.pyramid = new f(v), this.fog = new m(v), this.callback = null, this.finishedIntro = !1
                }
                return i(t, [{
                    key: "scrollStar",
                    value: function(t, e) {
                        this.star.scroll(t, e), this.starV.scroll(.5 * t), this.starFar.scroll(.2 * t), this.pyramid.scroll(t)
                    }
                }, {
                    key: "render",
                    value: function() {
                        var t = this.clock.getDelta();
                        this.time += t;
                        var e = a.clamp(this.time, 0, 4) / 4;
                        if (this.camera.position.z = 3e3 - 2e3 * c.expoOut(e), this.logo.obj.position.z = 1800 - 1800 * c.expoOut(e), this.time >= 2 && !1 === this.finishedIntro && (this.callback(), this.callback = null, this.finishedIntro = !0), this.logo.render(t), this.star.render(t), this.starV.render(t), this.starFar.render(t), this.pyramid.render(t), this.fog.render(t), !0 === this.finishedIntro) {
                            var n = Math.sqrt(Math.pow(this.cameraAnchor.x - this.camera.position.x, 2) + Math.pow(this.cameraAnchor.y - this.camera.position.y, 2)),
                                i = .03 * n;
                            this.camera.position.x += this.cameraAnchor.x - this.camera.position.x != 0 ? (this.cameraAnchor.x - this.camera.position.x) / n * i : 0, this.camera.position.y += this.cameraAnchor.y - this.camera.position.y != 0 ? (this.cameraAnchor.y - this.camera.position.y) / n * i : 0, Math.abs(this.camera.position.x) < .01 && (this.camera.position.x = 0), Math.abs(this.camera.position.y) < .01 && (this.camera.position.y = 0)
                        }
                        this.renderer.render(this.scene, this.camera)
                    }
                }, {
                    key: "renderLoop",
                    value: function() {
                        var t = this;
                        this.render(), requestAnimationFrame(function() {
                            t.renderLoop()
                        })
                    }
                }, {
                    key: "resizeCamera",
                    value: function() {
                        this.camera.aspect = this.resolution.x / this.resolution.y, this.camera.updateProjectionMatrix()
                    }
                }, {
                    key: "resizeWindow",
                    value: function() {
                        this.resolution.set(document.body.clientWidth, window.innerHeight), this.canvas.width = this.resolution.x, this.canvas.height = this.resolution.y, this.resizeCamera(), this.renderer.setSize(this.resolution.x, this.resolution.y)
                    }
                }, {
                    key: "transit",
                    value: function() {
                        this.star.transit(), this.starV.transit(), this.starFar.transit(), this.pyramid.transit(), this.fog.transit()
                    }
                }, {
                    key: "init",
                    value: function(t) {
                        var e = this;
                        this.callback = t, l({
                            logo: "/images/kb-logo-intro.png",
                            fog: "/img/pc/common/fog.png"
                        }, function(t) {
                            e.logo.createObj(t.logo), e.star.createObj(), e.starV.createObj(), e.starFar.createObj(), e.pyramid.createObj(), e.fog.createObj(t.fog), e.scene.add(e.logo.obj), e.scene.add(e.star.obj), e.scene.add(e.starV.obj), e.scene.add(e.starFar.obj), e.scene.add(e.pyramid.obj), e.scene.add(e.fog.obj), e.renderer.setClearColor(16777215, 0), e.camera.position.set(0, 0, 3e3), e.resizeWindow(), e.clock.start(), e.renderLoop(), e.on()
                        })
                    }
                }, {
                    key: "on",
                    value: function() {
                        var t = this;
                        window.addEventListener("mousemove", function(e) {
                            !0 !== o() && !0 !== s() && (t.mousemove.set(e.clientX / t.resolution.x * 2 - 1, -(e.clientY / t.resolution.y * 2 - 1)), t.cameraAnchor.set(60 * t.mousemove.x, 30 * t.mousemove.y))
                        }, !1), window.addEventListener("mouseout", function(e) {
                            t.mousemove.set(0, 0), t.cameraAnchor.set(0, 0)
                        })
                    }
                }]), t
            }();
        n.default = g
    }, {
        "../common/easings": 39,
        "./Fog": 25,
        "./Logo": 26,
        "./Pyramid": 27,
        "./Star": 28,
        "./StarFar": 29,
        "./StarV": 30,
        "./loadTexs": 31,
        "js-util/MathEx": 5,
        "js-util/isAndroid": 7,
        "js-util/isiOS": 9,
        "three/build/three.js": 10
    }],
    25: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("three"),
            a = t("glslify"),
            o = t("js-util/MathEx"),
            s = function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.uniforms = {
                        time: {
                            type: "f",
                            value: 0
                        },
                        timeTransit: {
                            type: "f",
                            value: 0
                        },
                        durationTransit: {
                            type: "f",
                            value: e
                        },
                        tex: {
                            type: "t",
                            value: null
                        }
                    }, this.isTransition = 0, this.num = 24, this.obj = null
                }
                return i(t, [{
                    key: "createObj",
                    value: function(t) {
                        var e = new r.InstancedBufferGeometry,
                            n = new r.PlaneBufferGeometry(1800, 1800, 2, 2);
                        e.addAttribute("position", n.attributes.position), e.addAttribute("normal", n.attributes.normal), e.addAttribute("uv", n.attributes.uv), e.setIndex(n.index);
                        for (var i = new r.InstancedBufferAttribute(new Float32Array(3 * this.num), 3, 1), s = new r.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), c = new r.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), l = new r.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), u = 0, h = this.num; u < h; u++) i.setXYZ(u, (2 * u - this.num) / this.num * 1800, Math.random() * Math.sin(o.radians(u / this.num * 180)) * -1800 - 800, 500 * (2 * Math.random() - 1)), s.setXYZ(u, Math.random()), c.setXYZ(u, 2 * Math.random() + 1), l.setXYZ(u, 360 * Math.random());
                        e.addAttribute("instancePosition", i), e.addAttribute("delay", s), e.addAttribute("rotate", c), e.addAttribute("hDiff", l);
                        var d = new r.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float delay;\nattribute float rotate;\nattribute float hDiff;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransit;\nuniform float durationTransit;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nconst float duration = 20.0;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main(void) {\n  // fadein when page loaded.\n  float fadeIn = clamp(time - 0.3, 0.0, 1.0);\n\n  // calcurate transit.\n  float stepTransit = mod(timeTransit, durationTransit) / durationTransit;\n  float easeTransit = exponentialOut(stepTransit);\n  vec3 translateMod = vec3(\n    instancePosition.x,\n    instancePosition.y,\n    mod(instancePosition.z + (easeTransit * 2.0 + 1.0) * 2000.0, 4000.0) - 2000.0\n    );\n  mat4 translateMat = calcTranslateMat4(translateMod);\n  float transitOpactiy = 1.0 - abs(translateMod.z / 2000.0);\n\n  // default animation.\n  float now = mod(time + delay * duration, duration) / duration;\n\n  mat4 rotateMat = calcRotateMat4Z(radians(rotate * 360.0) + time * 0.1);\n  vec3 rotatePosition = (translateMat * rotateMat * vec4(position, 1.0)).xyz;\n\n  vec3 moveRise = vec3(\n    0.0,\n    now * 1200.0,\n    0.0\n    );\n  vec3 updatePosition = moveRise + rotatePosition;\n\n  // h 0.666 - 1.125\n  vec3 hsv = vec3(sin(radians(time * 30.0 + hDiff)) * 0.23 + 0.895, 0.8, 0.4);\n  vec3 rgb = convertHsvToRgb(hsv);\n  float blink = sin(radians(now * 180.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n  vOpacity = transitOpactiy * blink * fadeIn;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
                            fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n\n  vec4 texColor = texture2D(tex, vUv + vec2(sin(time + vUv.x * 8.0) * 0.02, cos(time - vUv.y * 12.0) * 0.02));\n  vec3 color = texColor.rgb * vColor;\n  float opacity = texColor.a * vOpacity * 0.35;\n\n  gl_FragColor = vec4(color, opacity);\n}\n"]),
                            transparent: !0,
                            depthWrite: !1,
                            blending: r.AdditiveBlending
                        });
                        this.uniforms.tex.value = t, this.obj = new r.Mesh(e, d)
                    }
                }, {
                    key: "transit",
                    value: function() {
                        this.uniforms.timeTransit.value = 0, this.isTransition = 1
                    }
                }, {
                    key: "resetPositions",
                    value: function() {
                        for (var t = this.obj.geometry.attributes.instancePosition, e = 0, n = this.num; e < n; e++) t.setXYZ(e, (2 * e - this.num) / this.num * 1800, Math.random() * Math.sin(o.radians(e / this.num * 180)) * -1800 - 800, 500 * (2 * Math.random() - 1));
                        t.needsUpdate = !0
                    }
                }, {
                    key: "render",
                    value: function(t) {
                        this.uniforms.time.value += t, this.isTransition > 0 && (this.uniforms.timeTransit.value += t, this.uniforms.timeTransit.value >= .1 * this.uniforms.durationTransit.value && 1 == this.isTransition && (this.resetPositions(), this.isTransition = 2), this.uniforms.timeTransit.value >= this.uniforms.durationTransit.value && (this.uniforms.timeTransit.value = 0, this.isTransition = 0))
                    }
                }]), t
            }();
        n.default = s
    }, {
        glslify: 2,
        "js-util/MathEx": 5,
        three: 10
    }],
    26: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("three"),
            a = t("glslify"),
            o = function() {
                function t() {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.uniforms = {
                        time: {
                            type: "f",
                            value: 0
                        },
                        tex: {
                            type: "t",
                            value: null
                        }
                    }, this.obj = null
                }
                return i(t, [{
                    key: "createObj",
                    value: function(t) {
                        var e = new r.PlaneBufferGeometry(512, 128, 2, 2),
                            n = new r.RawShaderMaterial({
                                uniforms: this.uniforms,
                                vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
                                fragmentShader: a(['precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvoid main() {\n  // fadein when page loaded.\n  float fadeIn = clamp(time, 0.0, 0.8) / 0.8;\n  float fadeOut = 1.0 - clamp(time - 1.2, 0.0, 0.8) / 0.8;\n\n  vec4 texColor = texture2D(tex, vUv);\n\n  float noise = smoothstep(-0.5, 0.5, cnoise(vec3(vPosition.xy * 0.018, step(time, 1.2) * 100.0))) + (fadeIn * fadeOut * 2.0 - 1.0);\n\n  gl_FragColor = vec4(texColor.rgb, texColor.a * noise);\n}\n']),
                                transparent: !0,
                                depthWrite: !1
                            });
                        this.uniforms.tex.value = t, this.obj = new r.Mesh(e, n)
                    }
                }, {
                    key: "render",
                    value: function(t) {
                        this.uniforms.time.value += t
                    }
                }]), t
            }();
        n.default = o
    }, {
        glslify: 2,
        three: 10
    }],
    27: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("three"),
            a = t("glslify"),
            o = t("js-util/MathEx"),
            s = function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.uniforms = {
                        time: {
                            type: "f",
                            value: 0
                        },
                        timeTransit: {
                            type: "f",
                            value: 0
                        },
                        durationTransit: {
                            type: "f",
                            value: e
                        },
                        translate: {
                            type: "f",
                            value: 0
                        }
                    }, this.isTransition = 0, this.num = 40, this.obj = null
                }
                return i(t, [{
                    key: "createObj",
                    value: function() {
                        for (var t = new r.InstancedBufferGeometry, e = new r.TetrahedronGeometry(120, 0).vertices, n = [0, 1, 2, 3, 1, 0, 2, 3, 0, 2, 1, 3, 0], i = [], s = [], c = [], l = 0; l < n.length; l++) {
                            var u = e[n[l]];
                            i.push(u.x, u.y, u.z), s.push(l / (n.length - 1), 0), c.push(l)
                        }
                        t.addAttribute("position", new r.BufferAttribute(new Float32Array(i), 3)), t.addAttribute("uv", new r.BufferAttribute(new Float32Array(s), 2)), t.setIndex(c);
                        for (var h = new r.InstancedBufferAttribute(new Float32Array(3 * this.num), 3, 1), d = new r.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), p = new r.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), f = new r.InstancedBufferAttribute(new Float32Array(this.num), 1, 1), m = (l = 0, this.num); l < m; l++) h.setXYZ(l, 2e3 * (2 * Math.random() - 1), 2e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1) - 700), d.setXYZ(l, o.radians(360 * Math.random())), p.setXYZ(l, .9 * Math.random() + .1), f.setXYZ(l, 10 * Math.random());
                        t.addAttribute("instancePosition", h), t.addAttribute("rotate", d), t.addAttribute("speed", p), t.addAttribute("delay", f);
                        var v = new r.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float rotate;\nattribute float speed;\nattribute float delay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransit;\nuniform float durationTransit;\nuniform float translate;\n\nvarying vec2 vUv;\nvarying float vDelay;\nvarying float vOpacity;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main(void) {\n  // fadein when page loaded.\n  float fadeIn = clamp(time - 0.5, 0.0, 1.0);\n\n  // calcurate transit timer.\n  float stepTransit = mod(timeTransit, durationTransit) / durationTransit;\n  float easeTransit = exponentialOut(stepTransit);\n  vec3 translateMod = vec3(\n    instancePosition.x,\n    mod(instancePosition.y + translate + 2000.0, 4000.0) - 2000.0,\n    mod(instancePosition.z + (easeTransit * 2.0 + 1.0) * 3000.0, 6000.0) - 3000.0\n    );\n  mat4 translateMat = calcTranslateMat4(translateMod);\n  mat4 rotateMat = calcRotateMat4(vec3(rotate + time * speed * 0.1));\n  vec3 updatePosition = (translateMat * rotateMat * vec4(position, 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vUv = uv;\n  vDelay = delay;\n  vOpacity = fadeIn;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
                            fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec2 vUv;\nvarying float vDelay;\nvarying float vOpacity;\n\nvoid main() {\n  float drawLine = step(sin(vUv.x * 7.0 + (time + vDelay) * 2.0 + sin((time + vDelay) * 2.0) * 0.5), -0.9);\n  float opacity = drawLine * 0.2 + 0.05;\n\n  gl_FragColor = vec4(vec3(1.0), opacity * vOpacity);\n}\n"]),
                            transparent: !0,
                            blending: r.AdditiveBlending
                        });
                        this.obj = new r.Line(t, v)
                    }
                }, {
                    key: "scroll",
                    value: function(t, e) {
                        this.uniforms.translate.value += .4 * t
                    }
                }, {
                    key: "transit",
                    value: function() {
                        this.isTransition = 1, this.uniforms.timeTransit.value = 0
                    }
                }, {
                    key: "resetPositions",
                    value: function() {
                        for (var t = this.obj.geometry.attributes.instancePosition, e = 0, n = this.num; e < n; e++) t.setXYZ(e, 2e3 * (2 * Math.random() - 1), 2e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1));
                        t.needsUpdate = !0
                    }
                }, {
                    key: "render",
                    value: function(t) {
                        this.uniforms.time.value += t, this.isTransition > 0 && (this.uniforms.timeTransit.value += t, this.uniforms.timeTransit.value >= .1 * this.uniforms.durationTransit.value && 1 == this.isTransition && (this.resetPositions(), this.isTransition = 2), this.uniforms.timeTransit.value >= this.uniforms.durationTransit.value && (this.uniforms.timeTransit.value = 0, this.isTransition = 0))
                    }
                }]), t
            }();
        n.default = s
    }, {
        glslify: 2,
        "js-util/MathEx": 5,
        three: 10
    }],
    28: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("three"),
            a = t("glslify"),
            o = (t("js-util/MathEx"), function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.uniforms = {
                        time: {
                            type: "f",
                            value: 0
                        },
                        timeTransit: {
                            type: "f",
                            value: 0
                        },
                        durationTransit: {
                            type: "f",
                            value: e
                        },
                        translate: {
                            type: "f",
                            value: 0
                        },
                        scale: {
                            type: "f",
                            value: 0
                        }
                    }, this.isTransition = 0, this.num = 80, this.obj = null
                }
                return i(t, [{
                    key: "createObj",
                    value: function() {
                        var t = new r.InstancedBufferGeometry,
                            e = new r.BoxBufferGeometry(2, 2, 2);
                        t.addAttribute("position", e.attributes.position), t.setIndex(e.index);
                        for (var n = new r.InstancedBufferAttribute(new Float32Array(3 * this.num), 3, 1), i = 0, o = this.num; i < o; i++) n.setXYZ(i, 2e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1) - 700);
                        t.addAttribute("instancePosition", n);
                        var s = new r.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 instancePosition;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransit;\nuniform float durationTransit;\nuniform float translate;\nuniform float scale;\n\nvarying float vOpacity;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main(void) {\n  // fadein when page loaded.\n  float fadeIn = clamp(time - 0.6, 0.0, 1.0);\n\n  // calcurate transit timer.\n  float stepTransit = mod(timeTransit, durationTransit) / durationTransit;\n  float easeTransit = exponentialOut(stepTransit);\n  vec3 translateMod = vec3(\n    instancePosition.x,\n    mod(instancePosition.y + translate + 1000.0, 2000.0) - 1000.0,\n    mod(instancePosition.z + (easeTransit * 2.0 + 1.0) * 3000.0, 6000.0) - 3000.0\n    );\n  mat4 translateMat = calcTranslateMat4(translateMod);\n\n  // scale star with scroll and transit.\n  mat4 scaleMat = calcScaleMat4(vec3(\n    1.0,\n    scale,\n    abs(mod((easeTransit * 2.0 + 1.0) * 3000.0, 6000.0) - 3000.0) / 12.0 + 1.0\n    ));\n  vec3 updatePosition = (translateMat * scaleMat * vec4(position, 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vOpacity = fadeIn;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"]),
                            fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity * 0.5);\n}\n"]),
                            transparent: !0
                        });
                        this.obj = new r.Mesh(t, s)
                    }
                }, {
                    key: "scroll",
                    value: function(t, e) {
                        this.uniforms.translate.value += t, this.isTransition > 0 || (this.uniforms.scale.value = e)
                    }
                }, {
                    key: "transit",
                    value: function() {
                        this.isTransition = 1, this.uniforms.timeTransit.value = 0, this.uniforms.scale.value = 1
                    }
                }, {
                    key: "resetPositions",
                    value: function() {
                        for (var t = this.obj.geometry.attributes.instancePosition, e = 0, n = this.num; e < n; e++) t.setXYZ(e, 2e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1));
                        t.needsUpdate = !0
                    }
                }, {
                    key: "render",
                    value: function(t) {
                        this.uniforms.time.value += t, this.isTransition > 0 && (this.uniforms.timeTransit.value += t, this.uniforms.timeTransit.value >= .1 * this.uniforms.durationTransit.value && 1 == this.isTransition && (this.resetPositions(), this.isTransition = 2), this.uniforms.timeTransit.value >= this.uniforms.durationTransit.value && (this.uniforms.timeTransit.value = 0, this.isTransition = 0))
                    }
                }]), t
            }());
        n.default = o
    }, {
        glslify: 2,
        "js-util/MathEx": 5,
        three: 10
    }],
    29: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("three"),
            a = t("glslify"),
            o = (t("js-util/MathEx"), function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.uniforms = {
                        time: {
                            type: "f",
                            value: 0
                        },
                        timeTransit: {
                            type: "f",
                            value: 0
                        },
                        durationTransit: {
                            type: "f",
                            value: e
                        },
                        translate: {
                            type: "f",
                            value: 0
                        }
                    }, this.isTransition = 0, this.num = 4e3, this.obj = null
                }
                return i(t, [{
                    key: "createObj",
                    value: function() {
                        for (var t = new r.BufferGeometry, e = new r.BufferAttribute(new Float32Array(3 * this.num), 3), n = 0, i = this.num; n < i; n++) e.setXYZ(n, 5e3 * (2 * Math.random() - 1), 5e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1) - 5e3);
                        t.addAttribute("position", e);
                        var o = new r.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransit;\nuniform float durationTransit;\nuniform float translate;\n\nvarying float vOpacity;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main(void) {\n  // fadein when page loaded.\n  float fadeIn = clamp(time - 0.8, 0.0, 1.0);\n\n  // calcurate transit timer.\n  float stepTransit = mod(timeTransit, durationTransit) / durationTransit;\n  float easeTransit = exponentialOut(stepTransit);\n  vec3 translateMod = vec3(\n    position.x,\n    mod(position.y + translate + 5000.0, 10000.0) - 5000.0,\n    mod(position.z + (easeTransit * 2.0 + 1.0) * 3000.0, 6000.0) - 3000.0\n    );\n  mat4 translateMat = calcTranslateMat4(translateMod);\n  vec3 updatePosition = (translateMat * vec4(position, 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vOpacity = fadeIn;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 1.0;\n}\n"]),
                            fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity * 0.4);\n}\n"]),
                            transparent: !0
                        });
                        this.obj = new r.Points(t, o)
                    }
                }, {
                    key: "scroll",
                    value: function(t) {
                        this.uniforms.translate.value += t, this.isTransition
                    }
                }, {
                    key: "transit",
                    value: function() {
                        this.isTransition = 1, this.uniforms.timeTransit.value = 0
                    }
                }, {
                    key: "render",
                    value: function(t) {
                        this.uniforms.time.value += t, this.isTransition > 0 && (this.uniforms.timeTransit.value += t, this.uniforms.timeTransit.value >= .1 * this.uniforms.durationTransit.value && 1 == this.isTransition && (this.isTransition = 2), this.uniforms.timeTransit.value >= this.uniforms.durationTransit.value && (this.uniforms.timeTransit.value = 0, this.isTransition = 0))
                    }
                }]), t
            }());
        n.default = o
    }, {
        glslify: 2,
        "js-util/MathEx": 5,
        three: 10
    }],
    30: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("three"),
            a = t("glslify"),
            o = (t("js-util/MathEx"), function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.uniforms = {
                        time: {
                            type: "f",
                            value: 0
                        },
                        timeTransit: {
                            type: "f",
                            value: 0
                        },
                        durationTransit: {
                            type: "f",
                            value: e
                        },
                        translate: {
                            type: "f",
                            value: 0
                        }
                    }, this.isTransition = 0, this.num = 40, this.obj = null
                }
                return i(t, [{
                    key: "createObj",
                    value: function() {
                        var t = new r.InstancedBufferGeometry,
                            e = new r.BoxBufferGeometry(1, 20, 1);
                        t.addAttribute("position", e.attributes.position), t.setIndex(e.index);
                        for (var n = new r.InstancedBufferAttribute(new Float32Array(3 * this.num), 3, 1), i = 0, o = this.num; i < o; i++) n.setXYZ(i, 2e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1) - 1e3);
                        t.addAttribute("instancePosition", n);
                        var s = new r.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: a(["#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 instancePosition;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransit;\nuniform float durationTransit;\nuniform float translate;\n\nvarying float vOpacity;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main(void) {\n  // fadein when page loaded.\n  float fadeIn = clamp(time - 0.8, 0.0, 1.0);\n\n  // calcurate transit timer.\n  float stepTransit = mod(timeTransit, durationTransit) / durationTransit;\n  float easeTransit = exponentialOut(stepTransit);\n  vec3 translateMod = vec3(\n    instancePosition.x,\n    mod(instancePosition.y + translate + 1000.0, 2000.0) - 1000.0,\n    mod(instancePosition.z + (easeTransit * 2.0 + 1.0) * 3000.0, 6000.0) - 3000.0\n    );\n  mat4 translateMat = calcTranslateMat4(translateMod);\n  vec3 updatePosition = (translateMat * vec4(position, 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vOpacity = fadeIn;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 1.0;\n}\n"]),
                            fragmentShader: a(["precision highp float;\n#define GLSLIFY 1\n\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity * 0.4);\n}\n"]),
                            transparent: !0
                        });
                        this.obj = new r.Mesh(t, s)
                    }
                }, {
                    key: "scroll",
                    value: function(t, e) {
                        this.uniforms.translate.value += t, this.isTransition
                    }
                }, {
                    key: "transit",
                    value: function() {
                        this.isTransition = 1, this.uniforms.timeTransit.value = 0
                    }
                }, {
                    key: "resetPositions",
                    value: function() {
                        for (var t = this.obj.geometry.attributes.instancePosition, e = 0, n = this.num; e < n; e++) t.setXYZ(e, 2e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1), 1e3 * (2 * Math.random() - 1));
                        t.needsUpdate = !0
                    }
                }, {
                    key: "render",
                    value: function(t) {
                        this.uniforms.time.value += t, this.isTransition > 0 && (this.uniforms.timeTransit.value += t, this.uniforms.timeTransit.value >= .1 * this.uniforms.durationTransit.value && 1 == this.isTransition && (this.resetPositions(), this.isTransition = 2), this.uniforms.timeTransit.value >= this.uniforms.durationTransit.value && (this.uniforms.timeTransit.value = 0, this.isTransition = 0))
                    }
                }]), t
            }());
        n.default = o
    }, {
        glslify: 2,
        "js-util/MathEx": 5,
        three: 10
    }],
    31: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.default = function(t, e) {
            var n = Object.keys(t).length,
                a = {},
                o = 0,
                s = function() {
                    var s = c;
                    t.hasOwnProperty(s) && r.load(t[s], function(t) {
                        t.repeat = i.RepeatWrapping, a[s] = t, ++o >= n && e(a)
                    })
                };
            for (var c in t) s()
        };
        var i = t("three/build/three.js"),
            r = new i.TextureLoader
    }, {
        "three/build/three.js": 10
    }],
    32: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = function() {
            function t(e, n) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.elm = e, this.cursor = n, this.on()
            }
            return i(t, [{
                key: "on",
                value: function() {
                    var t = this;
                    this.elm.addEventListener("mouseover", function() {
                        t.cursor.state = 1
                    }), this.elm.addEventListener("mouseleave", function() {
                        t.cursor.state = 0
                    })
                }
            }]), t
        }();
        n.default = r
    }, {}],
    33: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = t("gl-matrix");
        n.default = {
            updateVelocity: function(t, e, n) {
                i.vec3.scale(e, e, 1 / n), i.vec3.add(t, t, e)
            },
            applyFriction: function(t, e, n) {
                var r = [0, 0, 0];
                i.vec3.scale(r, t, -1);
                i.vec3.normalize(r, r), i.vec3.scale(r, r, e), i.vec3.add(t, t, r)
            },
            applyDrag: function(t, e) {
                var n = [0, 0, 0];
                i.vec3.scale(n, t, -1), i.vec3.normalize(n, n), i.vec3.scale(n, n, i.vec3.length(t) * e), i.vec3.add(t, t, n)
            },
            applyHook: function(t, e, n, r, a) {
                var o = [0, 0, 0];
                i.vec3.sub(o, t, n);
                var s = i.vec3.length(o) - r;
                i.vec3.normalize(o, o), i.vec3.scale(o, o, -1 * a * s), i.vec3.add(e, e, o)
            }
        }
    }, {
        "gl-matrix": 1
    }],
    34: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("js-util/MathEx"),
            a = function() {
                function t() {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.scrollManager = null, this.gNav = null, this.cursor = null, this.wrap = document.querySelector(".p-progress-circle"), this.label = document.querySelector(".p-progress-circle-label"), this.canvas = document.getElementById("progress-circle"), this.ctx = this.canvas.getContext("2d"), this.renderMode = 0, this.progress = 0, this.progressAnchor = 0, this.progressBg = 0, this.mouseDownY = 0, this.drag = null, this.dragEnd = null, this.isValid = !1, this.isGrabbing = !1
                }
                return i(t, [{
                    key: "init",
                    value: function(t, e, n) {
                        this.scrollManager = t, this.gNav = e, this.cursor = n, this.isValid = !0, this.wrap.classList.add("is-valid"), this.renderLoop(), this.on()
                    }
                }, {
                    key: "switchMode",
                    value: function(t) {
                        if (!1 !== this.isValid) switch (this.renderMode = t, this.progressAnchor = 0, t) {
                            case 0:
                                return this.wrap.classList.remove("is-grab"), void this.label.classList.remove("is-shown");
                            case 1:
                                return this.wrap.classList.add("is-grab"), void this.label.classList.add("is-shown");
                            default:
                                return
                        }
                    }
                }, {
                    key: "updateProgress",
                    value: function(t, e) {
                        this.progressAnchor = t / e, this.label.innerHTML = t + 1
                    }
                }, {
                    key: "render",
                    value: function() {
                        0 === this.renderMode && (this.progressAnchor = this.scrollManager.scrollProgress), this.progress = Math.abs(this.progressAnchor - this.progress) > .01 ? this.progress + .1 * (this.progressAnchor - this.progress) : this.progressAnchor, this.progressBg = Math.abs(1 - this.progressBg) > .01 ? this.progressBg + .1 * (1 - this.progressBg) : 1, this.ctx.clearRect(0, 0, 50, 50), this.ctx.beginPath(), this.ctx.strokeStyle = "#ffffff", this.ctx.arc(25, 25, 24, r.radians(-90), r.radians(360 * this.progress - 90), !1), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.strokeStyle = "#444444", this.ctx.arc(25, 25, 24, r.radians(360 * this.progress - 90), r.radians(270 * this.progressBg), !1), this.ctx.stroke()
                    }
                }, {
                    key: "renderLoop",
                    value: function() {
                        var t = this;
                        this.render(), requestAnimationFrame(function() {
                            t.renderLoop()
                        })
                    }
                }, {
                    key: "on",
                    value: function() {
                        var t = this;
                        this.wrap.addEventListener("mousedown", function(e) {
                            e.preventDefault(), 0 !== t.renderMode && 1 !== t.gNav.isOpenedNavi && (t.isGrabbing = !0, t.cursor.state = 5, t.mouseDownY = e.clientY)
                        }), this.wrap.addEventListener("mousemove", function(e) {
                            0 !== t.renderMode && 1 !== t.gNav.isOpenedNavi && (t.isGrabbing || (t.cursor.state = 4))
                        }), this.wrap.addEventListener("mouseleave", function(e) {
                            t.isGrabbing || (t.cursor.state = 0)
                        }), window.addEventListener("mousemove", function(e) {
                            !1 !== t.isGrabbing && t.drag && t.drag(e.clientY)
                        }), window.addEventListener("mouseup", function(e) {
                            t.isGrabbing = !1, t.cursor.state = 0, t.dragEnd && t.dragEnd(e.clientY)
                        })
                    }
                }]), t
            }();
        n.default = a
    }, {
        "js-util/MathEx": 5
    }],
    35: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.default = function() {
            var t = "global-contact-dialog";
            return new i({
                el: "#vue-contact-dialog",
                data: {
                    state: 0
                },
                mounted: function() {},
                methods: {
                    show: function() {
                        "close" !== r.get(t) && (this.state = 1)
                    },
                    hide: function() {
                        this.state = 2, r.set(t, "close", {
                            expires: 1
                        })
                    }
                }
            })
        };
        var i = t("vue/dist/vue.min"),
            r = t("js-cookie")
    }, {
        "js-cookie": 3,
        "vue/dist/vue.min": 12
    }],
    36: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.default = function() {
            var t = new i({
                el: "#vue-custom-cursor",
                data: {
                    vx: 0,
                    vy: 0,
                    ax: 0,
                    ay: 0,
                    state: 0
                },
                computed: {
                    setStyles: function() {
                        return "transform:translate3d(" + this.vx + "px, " + this.vy + "px, 0)"
                    }
                },
                methods: {
                    move: function() {
                        var t = Math.sqrt(Math.pow(this.ax - this.vx, 2) + Math.pow(this.ay - this.vy, 2)),
                            e = .08 * t;
                        this.vx += this.ax - this.vx == 0 ? 0 : (this.ax - this.vx) / t * e, this.vy += this.ay - this.vy == 0 ? 0 : (this.ay - this.vy) / t * e
                    },
                    setVelocity: function(t, e) {
                        this.ax = t, this.ay = e
                    }
                }
            });
            return window.addEventListener("mousemove", function(e) {
                    !0 !== r() && !0 !== a() && t.setVelocity(e.x, e.y)
                }),
                function e() {
                    !0 !== r() && !0 !== a() && (t.move(), requestAnimationFrame(function() {
                        e()
                    }))
                }(), t
        };
        var i = t("vue/dist/vue.min"),
            r = t("js-util/isiOS"),
            a = t("js-util/isAndroid")
    }, {
        "js-util/isAndroid": 7,
        "js-util/isiOS": 9,
        "vue/dist/vue.min": 12
    }],
    37: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.default = function() {
            return new i({
                el: "#vue-global-category",
                data: {
                    items: {
                        blank: {
                            width: 0,
                            content: ""
                        },
                        top: {
                            width: 136,
                            content: '<img src="/img/pc/common/logo_yankee_intern.svg" width="100" height="20" alt="Yankee Intern" />'
                        },
                        apparel: {
                            width: 187,
                            content: "Hassyadai.Apparel"
                        },
                        boost: {
                            width: 170,
                            content: "Hassyadai.Boost"
                        },
                        pride: {
                            width: 73,
                            content: "Pride"
                        },
                        culture: {
                            width: 103,
                            content: "Culture"
                        },
                        business: {
                            width: 180,
                            content: '<img src="/img/pc/common/logo_yankee_business.svg" width="150" height="17" alt="Yankee Business" />'
                        },
                        hacker: {
                            width: 180,
                            content: '<img src="/img/pc/common/logo_yankee_hacker.svg" width="149" height="17" alt="Yankee Hacker" />'
                        },
                        story: {
                            width: 80,
                            content: "Story"
                        },
                        company: {
                            width: 110,
                            content: "Company"
                        },
                        privacypolicy: {
                            width: 158,
                            content: "Privacy Policy"
                        }
                    },
                    currentKey: "blank",
                    isValid: !1
                },
                mounted: function() {},
                computed: {
                    setLabelStyle: function() {
                        if (!1 !== this.isValid) return "width:" + this.items[this.currentKey].width + "px"
                    }
                },
                methods: {
                    setLabel: function(t) {
                        this.currentKey = t
                    }
                }
            })
        };
        var i = t("vue/dist/vue.min")
    }, {
        "vue/dist/vue.min": 12
    }],
    39: [function(t, e, n) {
        "use strict";
        e.exports = {
            expoOut: function(t) {
                return 1 == t ? t : 1 - Math.pow(2, -10 * t)
            },
            expoInOut: function(t) {
                return 0 == t || 1 == t ? t : t < .5 ? .5 * Math.pow(2, 20 * t - 10) : -.5 * Math.pow(2, 10 - 20 * t) + 1
            }
        }
    }, {}],
    40: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.default = function(t) {
            return new Promise(function(e, n) {
                var a = new XMLHttpRequest;
                a.open("GET", "/discovery/culture-json/", !0), a.send(), a.onreadystatechange = function() {
                    switch (a.readyState) {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        case 4:
                            switch (a.status) {
                                case 200:
                                    e(function() {
                                        return e = JSON.parse(a.response), new i({
                                            el: "#vue-culture",
                                            data: {
                                                items: e,
                                                max: e.length - 1,
                                                z: 3e3,
                                                zAnchor: 0,
                                                zAnchorPrev: 0,
                                                mouseDownY: 0,
                                                imgRotateX: 0,
                                                imgRotateXAnchor: 0,
                                                imgRotateY: 0,
                                                imgRotateYAnchor: 0,
                                                speed: .07,
                                                showItemId: -1,
                                                canControl: !1,
                                                isRendering: !1
                                            },
                                            mounted: function() {
                                                this.start()
                                            },
                                            computed: {},
                                            methods: {
                                                start: function() {
                                                    this.isRendering = !0, this.renderLoop(), t.progressCircle.updateProgress(0, this.max)
                                                },
                                                stop: function() {
                                                    this.isRendering = !1
                                                },
                                                setTitleStyle: function(t) {
                                                    var e = r.clamp(this.z - 300 * t, -1200, 1200),
                                                        n = Math.log(24 * Math.abs(this.z / 300 - t) + 1) / Math.log(128);
                                                    return "transform: translate3d(0px, 0px, " + e + "px); opacity: " + Math.max(1 - n, 0) + ";"
                                                },
                                                setPhotoStyle: function(t) {
                                                    var e = r.clamp(this.z - 300 * t, -1200, 1200),
                                                        n = Math.log(64 * Math.abs(this.z / 300 - t) + 1) / Math.log(128),
                                                        i = .8 * Math.max(1 - n, 0);
                                                    return "transform: translate3d(0px, 0px, " + e + "px); opacity: " + i + "; z-index: " + (this.max - t) * Math.ceil(i)
                                                },
                                                setPhotoImgStyle: function() {
                                                    return "transform: rotate3d(" + this.imgRotateX + ", " + this.imgRotateY + ", 0, 10deg)"
                                                },
                                                wheel: function(e) {
                                                    if (e.preventDefault(), !1 !== this.canControl) {
                                                        var n = 1 === e.deltaMode ? 0 !== e.deltaY ? e.deltaY / Math.abs(e.deltaY) * 80 : 0 : e.deltaY;
                                                        this.zAnchor = r.clamp(this.zAnchor + n, 0, 300 * this.max), this.showItemId = -1, t.progressCircle.updateProgress(Math.round(this.zAnchor / 300), this.max)
                                                    }
                                                },
                                                touchstart: function(t) {
                                                    this.touchStartY = t.touches[0].clientY, this.zAnchorPrev = this.zAnchor
                                                },
                                                touchmove: function(e) {
                                                    e.preventDefault();
                                                    var n = e.touches[0].clientY - this.touchStartY;
                                                    this.zAnchor = r.clamp(this.zAnchorPrev + n, 0, 300 * this.max), this.showItemId = -1, t.progressCircle.updateProgress(Math.round(this.zAnchor / 300), this.max)
                                                },
                                                touchend: function(t) {
                                                    this.isTouchMoved = !1
                                                },
                                                render: function() {
                                                    if (this.z += (this.zAnchor - this.z) * this.speed, this.imgRotateXAnchor = t.bg.mousemove.y, this.imgRotateYAnchor = t.bg.mousemove.x - 1, this.imgRotateX += .04 * (this.imgRotateXAnchor - this.imgRotateX), this.imgRotateY += .04 * (this.imgRotateYAnchor - this.imgRotateY), Math.abs(this.zAnchor - this.z) < 1 && (!1 === this.canControl && (this.canControl = !0, this.speed = .12), this.z = this.zAnchor, !1 === t.progressCircle.isGrabbing)) {
                                                        var e = Math.round(this.zAnchor / 300);
                                                        this.zAnchor = 300 * e, this.zAnchorPrev = this.zAnchor, t.progressCircle.updateProgress(e, this.max), this.showItemId = e
                                                    }
                                                },
                                                renderLoop: function() {
                                                    var t = this;
                                                    !1 !== this.isRendering && (this.render(), requestAnimationFrame(function() {
                                                        t.renderLoop()
                                                    }))
                                                }
                                            }
                                        });
                                        var e
                                    });
                                    break;
                                case 404:
                                    console.error("404 not found.");
                                    break;
                                case 500:
                                    console.error("500 Internal Server Error.")
                            }
                    }
                }
            })
        };
        var i = t("vue/dist/vue.min"),
            r = t("js-util/MathEx")
    }, {
        "js-util/MathEx": 5,
        "vue/dist/vue.min": 12
    }],
    41: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = function() {
            function t(e, n) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.ui = n, this.elm = {
                    scene: e.querySelector(".index-scene"),
                    sections: e.querySelectorAll(".index-section"),
                    sectionsIn: e.querySelectorAll(".index-section-in")
                }, this.sectionIndex = 0, this.sectionIndexPrev = 0, this.sectionMax = this.elm.sections.length - 1, this.wheelTimer = null, this.isWheeling = !1, this.touchStartY = 0, this.isTouchMoved = !1, this.init()
            }
            return i(t, [{
                key: "init",
                value: function() {
                    this.ui.progressCircle.updateProgress(this.sectionIndex, this.sectionMax);
                    for (var t = 0; t < this.sectionMax + 1; t++) this.sectionIndex == t ? this.elm.sections[t].classList.add("is-arrived-section") : this.elm.sections[t].classList.add("is-disabled")
                }
            }, {
                key: "switchSection",
                value: function() {
                    this.ui.progressCircle.updateProgress(this.sectionIndex, this.sectionMax), this.ui.scrollManager.hookes.smooth.anchor[1] = -2e3 * this.sectionIndex;
                    for (var t = 0; t < this.sectionMax + 1; t++) this.sectionIndex == t ? (this.elm.sections[t].classList.add("is-arrived-section"), this.elm.sections[t].classList.remove("is-leaved-section", "is-disabled")) : this.elm.sections[t].classList.contains("is-arrived-section") && (this.elm.sections[t].classList.remove("is-arrived-section"), this.elm.sections[t].classList.add("is-leaved-section"));
                    switch (this.sectionIndex) {
                        case 0:
                            this.ui.gCatLabel.setLabel("top");
                            break;
                        case 1:
                            this.ui.gCatLabel.setLabel("pride");
                            break;
                        case 2:
                            this.ui.gCatLabel.setLabel("apparel");
                            break;
                        case 3:
                            this.ui.gCatLabel.setLabel("boost");
                            break;
                        default:
                            this.ui.gCatLabel.setLabel("blank")
                    }
                }
            }, {
                key: "render",
                value: function() {
                    for (var t = 0; t < this.elm.sectionsIn.length; t++) this.elm.sectionsIn[t].style = "transform: rotateX(" + .1 * this.ui.bg.camera.position.y + "deg) rotateY(" + -.15 * this.ui.bg.camera.position.x + "deg)"
                }
            }]), t
        }();
        n.default = r
    }, {}],
    42: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.default = function(t, e) {
            return new i({
                el: t.querySelector(".vue-choose-your-life"),
                data: {
                    focusId: -1,
                    cameraX: 0,
                    cameraY: 0,
                    isValid: !1
                },
                computed: {
                    setWrapStyle: function() {
                        return "transform: rotateX(" + .1 * this.cameraY + "deg) rotateY(" + -.15 * this.cameraX + "deg)"
                    }
                },
                methods: {
                    start: function() {
                        this.isValid = !0
                    },
                    choose: function() {
                        this.isValid = !1, e.cursor.state = 0
                    },
                    mouseover: function(t) {
                        !0 !== e.progressCircle.isGrabbing && !1 !== this.isValid && (this.focusId = t, e.cursor.state = 1)
                    },
                    mouseleave: function() {
                        !0 !== e.progressCircle.isGrabbing && !1 !== this.isValid && (this.focusId = -1, e.cursor.state = 0)
                    },
                    render: function() {
                        this.cameraX = e.bg.camera.position.x, this.cameraY = e.bg.camera.position.y
                    }
                }
            })
        };
        var i = t("vue/dist/vue.min")
    }, {
        "vue/dist/vue.min": 12
    }],
    43: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.default = function(t) {
            return new i({
                el: "#vue-pride-value",
                data: {
                    items: [{
                        title: "Ethical",
                        text: "<br>"
                    }, {
                        title: "MAx",
                        text: "<br>"
                    }, {
                        title: "Fun idea",
                        text: "<br>"
                    }, {
                        title: "Crazy",
                        text: "<br>"
                    }, {
                        title: "Respect",
                        text: "<br>"
                    }, {
                        title: "Life Long Learner",
                        text: "<br>"
                    }, {
                        title: "Open",
                        text: "<br>"
                    }, {
                        title: "Positive",
                        text: "<br>"
                    }],
                    currentId: 0,
                    timerClicked: null,
                    isClicked: !1
                },
                mounted: function() {},
                computed: {
                    setCurrentNum: function() {
                        return this.currentId + 1 > 9 ? this.currentId + 1 : "0" + (this.currentId + 1)
                    },
                    setMaxNum: function() {
                        var t = this.items.length;
                        return t > 9 ? t : "0" + t
                    }
                },
                methods: {
                    goToPrev: function() {
                        var e = this;
                        t.state = 6, this.currentId = 0 === this.currentId ? this.items.length - 1 : this.currentId - 1, this.isClicked = !0, this.timerClicked = setTimeout(function() {
                            e.isClicked = !1
                        }, 50)
                    },
                    goToNext: function() {
                        var e = this;
                        t.state = 7, this.currentId = this.currentId === this.items.length - 1 ? 0 : this.currentId + 1, this.isClicked = !0, this.timerClicked = setTimeout(function() {
                            e.isClicked = !1
                        }, 10)
                    },
                    mouseover: function(e) {
                        t.state = e
                    },
                    mouseout: function() {
                        !0 !== this.isClicked && (t.state = 0)
                    }
                }
            })
        };
        var i = t("vue/dist/vue.min")
    }, {
        "vue/dist/vue.min": 12
    }],
    44: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("gl-matrix"),
            a = t("../common/Force3").default,
            o = function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.velocity = [0, 0, 0], this.acceleration = [0, 0, 0], this.anchor = [0, 0, 0], this.k = e && void 0 !== e.k ? e.k : .3, this.d = e && void 0 !== e.d ? e.d : .7, this.m = e && void 0 !== e.m ? e.m : 1
                }
                return i(t, [{
                    key: "render",
                    value: function() {
                        a.applyHook(this.velocity, this.acceleration, this.anchor, 0, this.k), a.applyDrag(this.acceleration, this.d), a.updateVelocity(this.velocity, this.acceleration, this.m);
                        var t = [0, 0, 0];
                        r.vec3.sub(t, this.anchor, this.velocity), r.vec3.length(this.acceleration) < .01 && r.vec3.length(t) < .01 && (this.acceleration = [0, 0, 0], this.velocity[1] = this.anchor[1])
                    }
                }]), t
            }();
        n.default = o
    }, {
        "../common/Force3": 33,
        "gl-matrix": 1
    }],
    45: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("js-util/MathEx"),
            a = t("js-util/isIE"),
            o = function() {
                function t(e, n, i, r) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.scrollManager = n, this.hookes = i, this.elm = e, this.height = 0, this.top = 0, this.rangeX = r && r.rangeX ? r.rangeX : 1e4, this.ratioX = r && r.ratioX ? r.ratioX : 0, this.unitX = r && r.unitX ? r.unitX : "px", this.rangeY = r && r.rangeY ? r.rangeY : 10, this.ratioY = r && r.ratioY ? r.ratioY : .012, this.unitY = r && r.unitY ? r.unitY : "%"
                }
                return i(t, [{
                    key: "init",
                    value: function(t) {
                        this.elm.style.transform = "";
                        var e = this.elm.getBoundingClientRect();
                        this.height = e.height, this.top = t + e.top, this.elm.style.backfaceVisibility = "hidden", this.render()
                    }
                }, {
                    key: "render",
                    value: function(t) {
                        if (t) {
                            var e = r.clamp(this.hookes.velocity[0] * this.ratioX, -1 * this.rangeX, this.rangeX),
                                n = r.clamp((this.hookes.velocity[1] - (this.top + .5 * this.height)) * this.ratioY, -1 * this.rangeY, this.rangeY);
                            this.elm.style.transform = a() ? "translate(" + e + this.unitX + ", " + n + this.unitY + ")" : "translate3D(" + e + this.unitX + ", " + n + this.unitY + ", 0)"
                        }
                    }
                }]), t
            }();
        n.default = o
    }, {
        "js-util/MathEx": 5,
        "js-util/isIE": 8
    }],
    46: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.elm = e, this.elmChildren = e.querySelectorAll(".js-scroll-item-child"), this.top = 0, this.bottom = 0
            }
            return i(t, [{
                key: "init",
                value: function(t) {
                    var e = this.elm.getBoundingClientRect();
                    this.top = t + e.top, this.bottom = this.top + e.height
                }
            }, {
                key: "show",
                value: function(t, e) {
                    if (t > this.top && e < this.bottom) {
                        this.elm.classList.add("is-shown");
                        for (var n = 0; n < this.elmChildren.length; n++) this.elmChildren[n].classList.add("is-shown")
                    }
                }
            }]), t
        }();
        n.default = r
    }, {}],
    47: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("./ScrollItem").default,
            a = t("./SmoothItem").default,
            o = t("./ParallaxItem").default,
            s = function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.scrollManager = e, this.scrollItems = [], this.smoothItems = [], this.parallaxItems = []
                }
                return i(t, [{
                    key: "init",
                    value: function() {
                        var t = document.querySelectorAll(".js-scroll-item"),
                            e = document.querySelectorAll(".js-smooth-item"),
                            n = document.querySelectorAll(".js-parallax-item");
                        this.scrollItems = [], this.smoothItems = [], this.parallaxItems = [];
                        for (var i = 0; i < t.length; i++) this.scrollItems[i] = new r(t[i], this.scrollManager);
                        for (i = 0; i < e.length; i++) this.smoothItems[i] = new a(e[i], this.scrollManager, this.scrollManager.hookes.smooth, e[i].dataset);
                        for (i = 0; i < n.length; i++) this.parallaxItems[i] = new o(n[i], this.scrollManager, this.scrollManager.hookes.parallax, n[i].dataset)
                    }
                }, {
                    key: "scroll",
                    value: function() {
                        for (var t = 0; t < this.scrollItems.length; t++) this.scrollItems[t].show(this.scrollManager.scrollTop + this.scrollManager.resolution.y, this.scrollManager.scrollTop)
                    }
                }, {
                    key: "resize",
                    value: function() {
                        for (var t = 0; t < this.scrollItems.length; t++) this.scrollItems[t].init(window.pageYOffset);
                        for (t = 0; t < this.smoothItems.length; t++) this.smoothItems[t].init(window.pageYOffset);
                        for (t = 0; t < this.parallaxItems.length; t++) this.parallaxItems[t].init(window.pageYOffset)
                    }
                }, {
                    key: "render",
                    value: function(t) {
                        for (var e = 0; e < this.smoothItems.length; e++) this.smoothItems[e].render(t);
                        for (e = 0; e < this.parallaxItems.length; e++) this.parallaxItems[e].render(t)
                    }
                }]), t
            }();
        n.default = s
    }, {
        "./ParallaxItem": 45,
        "./ScrollItem": 46,
        "./SmoothItem": 48
    }],
    48: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = function() {
            function t(e, n, i, r) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.scrollManager = n, this.hookes = i, this.elm = e, this.height = 0, this.top = 0, this.max = r && r.max ? r.max : null, this.min = r && r.min ? r.min : null, this.ratio = r && r.ratio ? r.ratio : .1, this.unit = r && r.unit ? r.unit : "px"
            }
            return i(t, [{
                key: "init",
                value: function(t) {
                    var e = this.elm.getBoundingClientRect();
                    this.height = e.height, this.top = t + e.top, this.elm.style.backfaceVisibility = "hidden"
                }
            }, {
                key: "render",
                value: function(t) {
                    var e = 0;
                    t && (e = this.hookes.velocity[1] * this.ratio, Math.abs(this.hookes.acceleration[1]) < .01 && (this.hookes.velocity[1] = this.hookes.anchor[1]), this.min && (e = Math.max(e, this.min)), this.max && (e = Math.min(e, this.max))), this.elm.style.transform = "translate3D(0, " + e + this.unit + ", 0)"
                }
            }]), t
        }();
        n.default = r
    }, {}],
    49: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("js-util/debounce"),
            a = t("js-util/isiOS"),
            o = t("js-util/isAndroid"),
            s = t("../../../common/ConsoleSignature").default,
            c = t("./Hookes").default,
            l = t("./ScrollItems").default,
            u = (new s("this content is rendered with scroll-manager", "https://github.com/ykob/scroll-manager"), function() {
                function t(e) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.bg = e, this.dummyScroll = document.querySelector(".js-dummy-scroll"), this.contents = null, this.scrollItems = new l(this), this.scrollTop = 0, this.scrollFrame = 0, this.scrollTopPause = 0, this.scrollProgress = 0, this.resolution = {
                        x: 0,
                        y: 0
                    }, this.bodyResolution = {
                        x: 0,
                        y: 0
                    }, this.X_SWITCH_SMOOTH = 0, this.hookes = {}, this.scrollPrev = null, this.scrollNext = null, this.resizeReset = null, this.resizePrev = null, this.resizeNext = null, this.renderPrev = null, this.renderNext = null, this.isWorkingScroll = !1, this.isWorkingRender = !1, this.isWorkingTransform = !1, this.isAlreadyAddEvent = !1
                }
                return i(t, [{
                    key: "start",
                    value: function(t) {
                        var e = this;
                        this.isWorkingScroll = !1, this.isWorkingRender = !1, this.isWorkingTransform = !1, this.contents = document.querySelector(".js-contents"), setTimeout(function() {
                            e.scrollTop = window.pageYOffset, e.resolution.x = window.innerWidth, e.resolution.y = window.innerHeight, e.initHookes(), e.scrollItems.init(), e.isWorkingScroll = !1;
                            var n = location.hash,
                                i = n ? document.querySelector(n) : null;
                            i && (e.scrollTop += i.getBoundingClientRect().top, window.scrollTo(0, e.scrollTop)), !1 === a() && !1 === o() && (e.hookes.contents.anchor[1] = e.hookes.contents.velocity[1] = -1 * e.scrollTop, e.hookes.parallax.anchor[1] = e.hookes.parallax.velocity[1] = e.scrollTop + .5 * e.resolution.y), e.contents.style.transform = "translate3D(0, " + e.hookes.contents.velocity[1] + "px, 0)", e.isWorkingScroll = !0, e.isWorkingRender = !0, e.isWorkingTransform = !0, e.renderLoop(), e.on(), e.resize(), e.scroll(), t && t()
                        }, 200)
                    }
                }, {
                    key: "pause",
                    value: function() {
                        this.isWorkingScroll = !1, !0 !== a() && !0 !== o() || (this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = -1 * this.scrollTop), this.scrollTopPause = this.scrollTop, window.scrollTo(0, this.scrollTop)
                    }
                }, {
                    key: "play",
                    value: function() {
                        this.isWorkingScroll = !0, !0 !== a() && !0 !== o() || (this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = 0), this.scrollTop = this.scrollTopPause, window.scrollTo(0, this.scrollTop)
                    }
                }, {
                    key: "initDummyScroll",
                    value: function() {
                        !0 === a() || !0 === o() ? (this.contents.style.transform = "", this.contents.classList.remove("is-fixed"), this.dummyScroll.style.height = "0") : (this.contents.classList.add("is-fixed"), this.dummyScroll.style.height = this.contents.clientHeight + "px"), this.render()
                    }
                }, {
                    key: "initHookes",
                    value: function() {
                        this.hookes = {
                            contents: new c({
                                k: .625,
                                d: .8
                            }),
                            smooth: new c({
                                k: .4,
                                d: .8
                            }),
                            parallax: new c({
                                k: .4,
                                d: .8
                            })
                        }
                    }
                }, {
                    key: "scrollBasis",
                    value: function() {
                        this.hookes.contents.anchor[1] = -1 * this.scrollTop, this.hookes.smooth.velocity[1] += this.scrollFrame, this.hookes.parallax.anchor[1] = this.scrollTop + .5 * this.resolution.y, this.scrollItems.scroll()
                    }
                }, {
                    key: "scroll",
                    value: function(t) {
                        if (!1 !== this.isWorkingScroll) {
                            var e = window.pageYOffset;
                            this.scrollFrame = e - this.scrollTop, this.scrollTop = e, this.scrollPrev && this.scrollPrev(), this.scrollBasis(), this.scrollNext && this.scrollNext()
                        }
                    }
                }, {
                    key: "tilt",
                    value: function(t) {
                        !1 !== this.isWorkingScroll && !1 === a() && !1 === o() && (this.hookes.parallax.anchor[0] = -100 * (t.clientX / this.resolution.x * 2 - 1))
                    }
                }, {
                    key: "resizeBasis",
                    value: function() {
                        this.scrollItems.resize(), this.bg.resizeWindow()
                    }
                }, {
                    key: "resize",
                    value: function() {
                        if (this.isWorkingScroll = !1, this.resizeReset && this.resizeReset(), this.scrollTop = window.pageYOffset, this.resolution.x = window.innerWidth, this.resolution.y = window.innerHeight, this.bodyResolution.x = this.contents.clientWidth, this.bodyResolution.y = this.contents.clientHeight, !1 === a() && !1 === o()) this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = -this.scrollTop, this.hookes.parallax.velocity[1] = this.hookes.parallax.anchor[1] = this.scrollTop + .5 * this.resolution.y;
                        else
                            for (var t in this.hookes) switch (t) {
                                case "contents":
                                case "parallax":
                                    this.hookes[t].anchor[1] = this.hookes[t].velocity[1] = 0;
                                    break;
                                default:
                                    this.hookes[t].velocity[1] = 0
                            }
                        this.resizePrev && this.resizePrev(), this.initDummyScroll(), this.render(), window.scrollTo(0, this.scrollTop), this.resizeBasis(), this.resizeNext && this.resizeNext(), this.isWorkingScroll = !0
                    }
                }, {
                    key: "render",
                    value: function() {
                        if (this.renderPrev && this.renderPrev(), !0 === this.isWorkingTransform && !1 === a() && !1 === o()) {
                            var t = Math.floor(1e3 * this.hookes.contents.velocity[1]) / 1e3;
                            this.contents.style.transform = "translate3D(0, " + t + "px, 0)"
                        }
                        for (var e in this.hookes) this.hookes[e].render();
                        this.scrollItems.render(this.isValidSmooth()), this.renderNext && this.renderNext(), this.scrollProgress = this.bodyResolution.y !== this.resolution.y ? this.scrollTop / (this.bodyResolution.y - this.resolution.y) : 0, this.bg.scrollStar(-this.hookes.smooth.acceleration[1], Math.abs(this.hookes.smooth.acceleration[1]) + 1)
                    }
                }, {
                    key: "renderLoop",
                    value: function() {
                        var t = this;
                        this.render(), this.isWorkingRender && requestAnimationFrame(function() {
                            t.renderLoop()
                        })
                    }
                }, {
                    key: "on",
                    value: function() {
                        var t = this;
                        this.isAlreadyAddEvent || (window.addEventListener("scroll", function(e) {
                            t.scroll(e)
                        }, !1), window.addEventListener("mousemove", function(e) {
                            t.tilt(e)
                        }, !1), window.addEventListener("resize", r(function(e) {
                            t.resize()
                        }, 400), !1), this.isAlreadyAddEvent = !0)
                    }
                }, {
                    key: "off",
                    value: function() {
                        this.scrollPrev = null, this.scrollNext = null, this.resizeReset = null, this.resizePrev = null, this.resizeNext = null, this.renderPrev = null, this.renderNext = null
                    }
                }, {
                    key: "isValidSmooth",
                    value: function() {
                        return this.isWorkingRender && !1 === a() && !1 === o() && !1 === a() && !1 === o()
                    }
                }]), t
            }());
        n.default = u
    }, {
        "../../../common/ConsoleSignature": 13,
        "./Hookes": 44,
        "./ScrollItems": 47,
        "js-util/debounce": 6,
        "js-util/isAndroid": 7,
        "js-util/isiOS": 9
    }],
    50: [function(t, e, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }();
        var r = t("js-util/MathEx"),
            a = t("../smooth_scroll_manager/Hookes").default,
            o = function() {
                function t(e, n) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.elm = {
                        wrap: e.querySelector(".p-intern-facilities"),
                        wrapIn: e.querySelector(".p-intern-facilities__wrap-in"),
                        items: e.querySelectorAll(".p-intern-facilities-item"),
                        scrollbar: e.querySelector(".p-intern-facilities__scroll-bar-in")
                    }, this.cursor = n, this.mouseDownX = 0, this.mouseUpX = 0, this.hookes = new a, this.scrollMax = 0, this.scrollBarRange = 0, this.isGrabbing = !1, this.init(), this.on()
                }
                return i(t, [{
                    key: "init",
                    value: function() {
                        for (var t = 0; t < this.elm.items.length; t++) this.elm.items[t].style.left = 122.22 * t + "%"
                    }
                }, {
                    key: "start",
                    value: function() {
                        this.resize(), this.renderLoop()
                    }
                }, {
                    key: "resize",
                    value: function() {
                        var t = this.elm.items[0].clientWidth;
                        this.scrollMax = 1.22 * t * (this.elm.items.length - 1), this.scrollBarRange = t / this.scrollMax * 100, this.elm.scrollbar.style.width = this.scrollBarRange + "%"
                    }
                }, {
                    key: "render",
                    value: function() {
                        this.hookes.render(), this.elm.wrapIn.style.transform = "translate3d(" + this.hookes.velocity[0] + "px, 0, 0)", this.elm.scrollbar.style.left = this.hookes.velocity[0] / this.scrollMax * -(100 - this.scrollBarRange) + "%"
                    }
                }, {
                    key: "renderLoop",
                    value: function() {
                        var t = this;
                        this.render(), requestAnimationFrame(function() {
                            t.renderLoop()
                        })
                    }
                }, {
                    key: "on",
                    value: function() {
                        var t = this;
                        this.elm.wrap.addEventListener("mousedown", function(e) {
                            t.mouseDownX = e.clientX, t.isGrabbing = !0, t.cursor.state = 3, t.elm.wrap.classList.add("is-grabbing")
                        }), this.elm.wrap.addEventListener("mousemove", function(e) {
                            t.isGrabbing || (t.cursor.state = 2)
                        }), this.elm.wrap.addEventListener("mouseleave", function(e) {
                            t.isGrabbing || (t.cursor.state = 0)
                        }), window.addEventListener("mousemove", function(e) {
                            e.preventDefault(), t.isGrabbing && (t.hookes.anchor[0] = r.clamp(3 * (e.clientX - t.mouseDownX) + t.mouseUpX, -t.scrollMax, 0))
                        }), window.addEventListener("mouseup", function() {
                            t.isGrabbing && (t.mouseUpX = t.hookes.anchor[0], t.isGrabbing = !1, t.cursor.state = 0, t.elm.wrap.classList.remove("is-grabbing"))
                        }), this.elm.wrap.addEventListener("touchstart", function(e) {
                            t.mouseDownX = e.touches[0].clientX, t.isGrabbing = !0, t.elm.wrap.classList.add("is-grabbing")
                        }), this.elm.wrap.addEventListener("touchmove", function(e) {
                            e.preventDefault(), t.isGrabbing && (t.hookes.anchor[0] = r.clamp(3 * (e.touches[0].clientX - t.mouseDownX) + t.mouseUpX, -t.scrollMax, 0))
                        }), this.elm.wrap.addEventListener("touchend", function() {
                            t.isGrabbing && (t.mouseUpX = t.hookes.anchor[0], t.isGrabbing = !1, t.cursor.state = 0, t.elm.wrap.classList.remove("is-grabbing"))
                        })
                    }
                }]), t
            }();
        n.default = o
    }, {
        "../smooth_scroll_manager/Hookes": 44,
        "js-util/MathEx": 5
    }]
  }, {}, [14]);